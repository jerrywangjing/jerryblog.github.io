<!DOCTYPE html>
<html lang="en">

<!-- Head tag -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="A developer">
    <meta name="keyword"  content="Jerry, wangjing, Jerry&#39;s Blog, 博客, 个人博客, iOS, 移动互联网, 开发">
    <link rel="shortcut icon" href="/img/favicon.ico">

    <title>
        
          RunLoop的实现原理及应用 - Jerry的博客 | Jerry&#39;s Blog
        
    </title>

    <link rel="canonical" href="https://jerrywangjing.github.io/2018/09/07/RunLoop的实现原理及应用/">

    <!-- Bootstrap Core CSS -->
    <link rel="stylesheet" href="/css/bootstrap.min.css">

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/hux-blog.min.css">

    <!-- Pygments Highlight CSS -->
    <link rel="stylesheet" href="/css/highlight.css">

    <!-- Custom Fonts -->
    <!-- <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css" rel="stylesheet" type="text/css"> -->
    <!-- Hux change font-awesome CDN to qiniu -->
    <link href="https://cdn.staticfile.org/font-awesome/4.5.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">


    <!-- Hux Delete, sad but pending in China
    <link href='http://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
    <link href='http://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/
    css'>
    -->


    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <!-- ga & ba script hoook -->
    <script></script>
</head>


<!-- hack iOS CSS :active style -->
<body ontouchstart="">

    <!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">Jerry&#39;s Blog</a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <!-- Known Issue, found by Hux:
            <nav>'s height woule be hold on by its content.
            so, when navbar scale out, the <nav> will cover tags.
            also mask any touch event of tags, unfortunately.
        -->
        <div id="huxblog_navbar">
            <div class="navbar-collapse">
                <ul class="nav navbar-nav navbar-right">
                    <li>
                        <a href="/">Home</a>
                    </li>

                    

                        
                    

                        
                        <li>
                            <a href="/about/">About</a>
                        </li>
                        
                    

                        
                        <li>
                            <a href="/tags/">Tags</a>
                        </li>
                        
                    

                        
                        <li>
                            <a href="/archives/">Archives</a>
                        </li>
                        
                    
                    
                </ul>
            </div>
        </div>
        <!-- /.navbar-collapse -->
    </div>
    <!-- /.container -->
</nav>
<script>
    // Drop Bootstarp low-performance Navbar
    // Use customize navbar with high-quality material design animation
    // in high-perf jank-free CSS3 implementation
    var $body   = document.body;
    var $toggle = document.querySelector('.navbar-toggle');
    var $navbar = document.querySelector('#huxblog_navbar');
    var $collapse = document.querySelector('.navbar-collapse');

    $toggle.addEventListener('click', handleMagic)
    function handleMagic(e){
        if ($navbar.className.indexOf('in') > 0) {
        // CLOSE
            $navbar.className = " ";
            // wait until animation end.
            setTimeout(function(){
                // prevent frequently toggle
                if($navbar.className.indexOf('in') < 0) {
                    $collapse.style.height = "0px"
                }
            },400)
        }else{
        // OPEN
            $collapse.style.height = "auto"
            $navbar.className += " in";
        }
    }
</script>


    <!-- Main Content -->
    
<!-- Image to hack wechat -->
<!-- <img src="https://jerrywangjing.github.io/img/icon_wechat.png" width="0" height="0"> -->
<!-- <img src="{{ site.baseurl }}/{% if page.header-img %}{{ page.header-img }}{% else %}{{ site.header-img }}{% endif %}" width="0" height="0"> -->

<!-- Post Header -->
<style type="text/css">
    header.intro-header{
        background-image: url('/img/home-bg.jpg')
    }
</style>
<header class="intro-header" >
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <div class="post-heading">
                    <div class="tags">
                        
                          <a class="tag" href="/tags/#iOS" title="iOS">iOS</a>
                        
                    </div>
                    <h1>RunLoop的实现原理及应用</h1>
                    <h2 class="subheading"></h2>
                    <span class="meta">
                        Posted by Jerry on
                        2018-09-07
                    </span>
                </div>
            </div>
        </div>
    </div>
</header>

<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">

    <!-- Post Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                post-container">

                <h3 id="什么是RunLoop"><a href="#什么是RunLoop" class="headerlink" title="什么是RunLoop?"></a>什么是RunLoop?</h3><p>为了保证线程能随时处理事件且不会退出，我们需要一个run loop 运行循环来一直保持能持续接收并处理各种事件，确保执行线程不被销毁。实现思路类似于如下代码：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line"><span class="comment">// Event loop</span></div><div class="line">function loop() &#123;</div><div class="line">    initialize();</div><div class="line">    <span class="keyword">do</span> &#123;</div><div class="line">        var message = get_next_message();</div><div class="line">        process_message(message);</div><div class="line">    &#125; <span class="keyword">while</span> (message != quit);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当创建一个线程后，开启一个loop() 使用do-while 循环来不断的接收并处理事件，直到线程退出。实现这种模型的关键点在于：如何管理事件/消息，如何让线程在没有处理消息时休眠以避免资源占用，在有消息到来时立即唤醒。</p>
<p>所以，RunLoop 实际上就是一个对象，这个对象管理了其需要处理的事件和消息，并提供了一个入口函数来执行上面 Event Loop 的逻辑。线程执行了这个函数后，就会一直处于这个函数内部 “接受消息-&gt;等待-&gt;处理” 的循环中，直到这个循环结束（比如传入 quit 的消息），函数返回。</p>
<p>OSX/iOS 系统中，提供了这两个对象：NSRunLoop 和 CFRunLoopRef，来实现线程的运行循环。</p>
<p><strong>CFRunLoopRef</strong> 是在 CoreFoundation 框架内的，它提供了纯 C 函数的 API，所有这些 API 都是线程安全的。<br><strong>NSRunLoop</strong> 是基于 CFRunLoopRef 的封装，提供了面向对象的 API，但是这些 API 不是线程安全的。</p>
<p>CFRunLoopRef 的代码是<a href="http://opensource.apple.com/source/CF/CF-855.17/CFRunLoop.c" target="_blank" rel="noopener">开源</a>的，你可以在<a href="http://opensource.apple.com/tarballs/CF/" target="_blank" rel="noopener">这里</a>下载到整个 CoreFoundation 的源码来查看。</p>
<h3 id="RunLoop与线程的关系"><a href="#RunLoop与线程的关系" class="headerlink" title="RunLoop与线程的关系"></a>RunLoop与线程的关系</h3><p>在iOS中有两个线程对象<code>pthread_t</code>和<code>NSThread</code>，苹果文档中有说明<code>NSThread</code>只是<code>pthread_t</code>的封装，但是在Foundation框架中并没有发现这两个对象之间的转换接口，但是可以肯定的是<code>pthread_t</code>和<code>NSThread</code>是一一对应的，而且CFRunLoopRef 是基于pthread 来管理的，可以说是线程的管理器。</p>
<p>苹果不允许直接创建 RunLoop，它只提供了两个自动获取的函数：<code>CFRunLoopGetMain()</code> 和 <code>CFRunLoopGetCurrent()</code>。 这两个函数内部的逻辑大概是下面这样:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="comment">/// 全局的Dictionary，key 是 pthread_t， value 是 CFRunLoopRef</span></div><div class="line"><span class="keyword">static</span> CFMutableDictionaryRef loopsDic;</div><div class="line"><span class="comment">/// 访问 loopsDic 时的锁</span></div><div class="line"><span class="keyword">static</span> CFSpinLock_t loopsLock;</div><div class="line"> </div><div class="line"><span class="comment">/// 获取一个 pthread 对应的 RunLoop。</span></div><div class="line">CFRunLoopRef _CFRunLoopGet(<span class="keyword">pthread_t</span> thread) &#123;</div><div class="line">    OSSpinLockLock(&amp;loopsLock);</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (!loopsDic) &#123;</div><div class="line">        <span class="comment">// 第一次进入时，初始化全局Dic，并先为主线程创建一个 RunLoop。</span></div><div class="line">        loopsDic = CFDictionaryCreateMutable();</div><div class="line">        CFRunLoopRef mainLoop = _CFRunLoopCreate();</div><div class="line">        CFDictionarySetValue(loopsDic, pthread_main_thread_np(), mainLoop);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">/// 直接从 Dictionary 里获取。</span></div><div class="line">    CFRunLoopRef loop = CFDictionaryGetValue(loopsDic, thread));</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (!loop) &#123;</div><div class="line">        <span class="comment">/// 取不到时，创建一个</span></div><div class="line">        loop = _CFRunLoopCreate();</div><div class="line">        CFDictionarySetValue(loopsDic, thread, loop);</div><div class="line">        <span class="comment">/// 注册一个回调，当线程销毁时，顺便也销毁其对应的 RunLoop。</span></div><div class="line">        _CFSetTSD(..., thread, loop, __CFFinalizeRunLoop);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    OSSpinLockUnLock(&amp;loopsLock);</div><div class="line">    <span class="keyword">return</span> loop;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function">CFRunLoopRef <span class="title">CFRunLoopGetMain</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> _CFRunLoopGet(pthread_main_thread_np());</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function">CFRunLoopRef <span class="title">CFRunLoopGetCurrent</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> _CFRunLoopGet(pthread_self());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从上述代码中可以看出，线程和 RunLoop 之间是一一对应的，其关系是保存在一个全局的 Dictionary 里。线程刚创建时并没有 RunLoop，如果你不主动获取，那它一直都不会有。RunLoop 的创建是发生在第一次获取时，RunLoop 的销毁是发生在线程结束时。你只能在一个线程的内部获取其 RunLoop（主线程除外）。</p>
<h3 id="RunLoop与其相关的几个类"><a href="#RunLoop与其相关的几个类" class="headerlink" title="RunLoop与其相关的几个类"></a>RunLoop与其相关的几个类</h3><p>在 CoreFoundation 里面关于 RunLoop 的有5个类:</p>
<blockquote>
<p>CFRunLoopRef            runloop结构体<br>CFRunLoopModeRef        运行模式，有多种，下面会讲</p>
<p>CFRunLoopSourceRef        各种事件源（source、timer、observer）<br>CFRunLoopTimerRef        基于事件的触发器</p>
</blockquote>
<p><strong>CFRunLoopRef：</strong>结构体定义如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">CFRunLoop</span> * <span class="title">CFRunLoopRef</span>;</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">CFRunLoop</span> &#123;</span></div><div class="line">    CFRuntimeBase _base;</div><div class="line">    <span class="keyword">pthread_mutex_t</span> _lock;			<span class="comment">/* locked for accessing mode list */</span></div><div class="line">    __CFPort _wakeUpPort;			<span class="comment">// used for CFRunLoopWakeUp </span></div><div class="line">    Boolean _unused;</div><div class="line">    <span class="keyword">volatile</span> _per_run_data *_perRunData;              <span class="comment">// reset for runs of the run loop</span></div><div class="line">    <span class="keyword">pthread_t</span> _pthread;</div><div class="line">    <span class="keyword">uint32_t</span> _winthread;</div><div class="line">    CFMutableSetRef _commonModes; 		<span class="comment">// 字符串，记录所有标记为common的mode</span></div><div class="line">    CFMutableSetRef _commonModeItems; 	<span class="comment">// 所有commonMode的item(source、timer、observer)</span></div><div class="line">    CFRunLoopModeRef _currentMode;</div><div class="line">    CFMutableSetRef _modes; 			<span class="comment">// CFRunLoopModeRef set</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">block_item</span> *_<span class="title">blocks_head</span>;</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">block_item</span> *_<span class="title">blocks_tail</span>;</span></div><div class="line">    CFTypeRef _counterpart;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>从上述代码可以看出，一个runloop 对应一个pthread 线程，包含多个mode，一个mode又包含了多个mode items事件。<code>_commonModes</code> Set 里面存储着被标记为common的mode，标记common意味着可以同时在多种模式下执行事件。例如：在tableViewCell 中添加一个Timer，当滑动tableView时Timer任然在执行回调，这时的Timer添加在RunLoop中是以<code>NSRunLoopCommonModes</code>mode运行的。</p>
<p><strong>CFRunLoopModeRef：</strong> 结构体定义大致如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">CFRunLoopMode</span> &#123;</span></div><div class="line">    CFStringRef _name;            <span class="comment">// Mode Name, 例如 @"kCFRunLoopDefaultMode"</span></div><div class="line">    CFMutableSetRef _sources0;    <span class="comment">// Set</span></div><div class="line">    CFMutableSetRef _sources1;    <span class="comment">// Set</span></div><div class="line">    CFMutableArrayRef _observers; <span class="comment">// Array</span></div><div class="line">    CFMutableArrayRef _timers;    <span class="comment">// Array</span></div><div class="line">    ...</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>一个 RunLoop 包含多个 Mode，每个 Mode 又包含若干个 Source/Timer/Observer。每次调用 RunLoop 的主函数时，只能指定其中一个 Mode，这个Mode被称作 CurrentMode。如果需要切换 Mode，只能退出 Loop，再重新指定一个 Mode 进入。这样做主要是为了分隔开不同组的 Source/Timer/Observer，让其互不影响。</p>
<p><strong>CFRunLoopSourceRef：</strong>结构体定义如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">CFRunLoopSource</span> &#123;</span></div><div class="line">	CFRuntimeBase _base;</div><div class="line">	<span class="keyword">uint32_t</span> _bits;</div><div class="line">	<span class="keyword">pthread_mutex_t</span> _lock;</div><div class="line">	CFIndex _order;            <span class="comment">/* immutable */</span></div><div class="line">	CFMutableBagRef _runLoops;</div><div class="line">	<span class="keyword">union</span> &#123;</div><div class="line">		CFRunLoopSourceContext version0;    <span class="comment">/* immutable, except invalidation */</span></div><div class="line">		CFRunLoopSourceContext1 version1;    <span class="comment">/* immutable, except invalidation */</span></div><div class="line">	&#125; _context;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p> 这里是事件产生的地方。Source有两个版本：Source0 和 Source1。</p>
<ul>
<li>Source0：非基于 Port 的事件，只包含了一个回调（函数指针），它并不能主动触发事件。使用时，你需要先调用 CFRunLoopSourceSignal(source)，将这个 Source 标记为待处理，然后手动调用 CFRunLoopWakeUp(runloop) 来唤醒 RunLoop，让其处理这个事件。一般处理点击、触摸等事件</li>
<li>Source1：是基于Port的，包含了一个 mach_port 和一个回调（函数指针），被用于通过内核和其他线程相互发送消息。这种 Source 能主动唤醒 RunLoop 的线程，其原理在下面会讲到。</li>
</ul>
<p><strong>CFRunLoopTimerRef</strong> ：结构体定义如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">CFRunLoopTimer</span> &#123;</span></div><div class="line">    CFRuntimeBase _base;</div><div class="line">    <span class="keyword">uint16_t</span> _bits;</div><div class="line">    <span class="keyword">pthread_mutex_t</span> _lock;</div><div class="line">    CFRunLoopRef _runLoop;</div><div class="line">    CFMutableSetRef _rlModes;</div><div class="line">    CFAbsoluteTime _nextFireDate;</div><div class="line">    CFTimeInterval _interval;        <span class="comment">/* immutable */</span></div><div class="line">    CFTimeInterval _tolerance;          <span class="comment">/* mutable */</span></div><div class="line">    <span class="keyword">uint64_t</span> _fireTSR;            <span class="comment">/* TSR units */</span></div><div class="line">    CFIndex _order;            <span class="comment">/* immutable */</span></div><div class="line">    CFRunLoopTimerCallBack _callout;    <span class="comment">/* immutable */</span></div><div class="line">    CFRunLoopTimerContext _context;    <span class="comment">/* immutable, except invalidation */</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>是基于时间的触发器，它和 NSTimer 是toll-free bridged 的，可以混用。其包含一个时间长度和一个回调（函数指针）。当其加入到 RunLoop 时，RunLoop会注册对应的时间点，当时间点到时，RunLoop会被唤醒以执行那个回调。</p>
<p><strong>CFRunLoopObserverRef</strong> ：结构体定义如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">CFRunLoopObserver</span> &#123;</span></div><div class="line">    CFRuntimeBase _base;</div><div class="line">    <span class="keyword">pthread_mutex_t</span> _lock;</div><div class="line">    CFRunLoopRef _runLoop;</div><div class="line">    CFIndex _rlCount;</div><div class="line">    CFOptionFlags _activities;        <span class="comment">/* immutable */</span></div><div class="line">    CFIndex _order;            <span class="comment">/* immutable */</span></div><div class="line">    CFRunLoopObserverCallBack _callout;    <span class="comment">/* immutable */</span></div><div class="line">    CFRunLoopObserverContext _context;    <span class="comment">/* immutable, except invalidation */</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>是观察者，每个 Observer 都包含了一个回调（函数指针），当 RunLoop 的状态发生变化时，观察者就能通过回调接受到这个变化。可以观测的时间点有以下几个：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">CF_OPTIONS</span><span class="params">(CFOptionFlags, CFRunLoopActivity)</span> </span>&#123;</div><div class="line">    kCFRunLoopEntry         = (<span class="number">1U</span>L &lt;&lt; <span class="number">0</span>), <span class="comment">// 即将进入Loop</span></div><div class="line">    kCFRunLoopBeforeTimers  = (<span class="number">1U</span>L &lt;&lt; <span class="number">1</span>), <span class="comment">// 即将处理 Timer</span></div><div class="line">    kCFRunLoopBeforeSources = (<span class="number">1U</span>L &lt;&lt; <span class="number">2</span>), <span class="comment">// 即将处理 Source</span></div><div class="line">    kCFRunLoopBeforeWaiting = (<span class="number">1U</span>L &lt;&lt; <span class="number">5</span>), <span class="comment">// 即将进入休眠</span></div><div class="line">    kCFRunLoopAfterWaiting  = (<span class="number">1U</span>L &lt;&lt; <span class="number">6</span>), <span class="comment">// 刚从休眠中唤醒</span></div><div class="line">    kCFRunLoopExit          = (<span class="number">1U</span>L &lt;&lt; <span class="number">7</span>), <span class="comment">// 即将退出Loop</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>上面的 Source/Timer/Observer 被统称为 <strong>mode item</strong>，一个 item 可以被同时加入多个 mode。但一个 item 被重复加入同一个 mode 时是不会有效果的。如果一个 mode 中一个 item 都没有，则 RunLoop 会直接退出，不进入循环。</p>
<h3 id="RunLoopMode"><a href="#RunLoopMode" class="headerlink" title="RunLoopMode"></a>RunLoopMode</h3><p>CFRunLoopMode 和 CFRunLoop 的结构大致如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">CFRunLoopMode</span> &#123;</span></div><div class="line">    CFStringRef _name;            <span class="comment">// Mode Name, 例如 @"kCFRunLoopDefaultMode"</span></div><div class="line">    CFMutableSetRef _sources0;    <span class="comment">// Set</span></div><div class="line">    CFMutableSetRef _sources1;    <span class="comment">// Set</span></div><div class="line">    CFMutableArrayRef _observers; <span class="comment">// Array</span></div><div class="line">    CFMutableArrayRef _timers;    <span class="comment">// Array</span></div><div class="line">    ...</div><div class="line">&#125;;</div><div class="line"> </div><div class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">CFRunLoop</span> &#123;</span></div><div class="line">    CFMutableSetRef _commonModes;     <span class="comment">// Set</span></div><div class="line">    CFMutableSetRef _commonModeItems; <span class="comment">// Set&lt;Source/Observer/Timer&gt;</span></div><div class="line">    CFRunLoopModeRef _currentMode;    <span class="comment">// Current Runloop Mode</span></div><div class="line">    CFMutableSetRef _modes;           <span class="comment">// Set</span></div><div class="line">    ...</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p><strong>这里有个概念叫 “CommonModes”：一个 Mode 可以将自己标记为”Common”属性（通过将其 ModeName（NSRunLoopCommonModes，通用/共用Mode） 添加到 RunLoop 的 “commonModes” 中）。每当 RunLoop 的内容发生变化时，RunLoop 都会自动将 _commonModeItems 里的 Source/Observer/Timer 同步到具有 “Common” 标记的所有Mode里。</strong></p>
<p><strong>应用场景举例：</strong></p>
<p>iOS中的主线程runloop有2个预设的Mode：kCFRunLoopDefaultMode（NSDefaultRunLoopMode） 和 UITrackingRunLoopMode（UITrackingRunLoopMode），第一个是默认的mode，也是App平时所处的状态，第二个是追踪ScrollView滑动时的状态。</p>
<p>例如当一个tableViewCell中添加一个运行在DefaultRunLoopMode下的Timer时，那么当滑动tableView的时候，RunLoop会将mode切换为TrackingRunLoopMode用于对scrollView页面滑动手势的跟踪，这时Timer就不会被回调执行。那么，如何让tableView在滑动的同时Timer任然在执行回调计时呢，一种方式是将Timer分别添加到这两个Mode中。</p>
<p>还有一种更简便的方式就是修改Timer的mode为：<strong>kCFRunLoopCommonModes (NSRunLoopCommonModes)</strong>，即将Timer添加到RunLoop的<code>_commonModeItems</code>中，这样Timer的定时事件会分别添加到kCFRunLoopDefaultMode（NSDefaultRunLoopMode） 和 UITrackingRunLoopMode（UITrackingRunLoopMode）中，这样不论页面是否在滑动，都不会影响Timer的计时回调。</p>
<p>CFRunLoop对外暴露的管理 Mode 接口只有下面2个:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 给runloop 添加mode</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">CFRunLoopAddCommonMode</span><span class="params">(CFRunLoopRef runloop, CFStringRef modeName)</span></span>;</div><div class="line"><span class="comment">// 获取RunLoop当前运行的mode</span></div><div class="line"><span class="function">SInt32 <span class="title">CFRunLoopRunInMode</span><span class="params">(CFStringRef modeName, ...)</span></span>;</div></pre></td></tr></table></figure>
<p>Mode 暴露的管理 mode item 的接口有下面几个：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 对runloop添加source事件源，并指定mode</span></div><div class="line">CFRunLoopAddSource(CFRunLoopRef rl, CFRunLoopSourceRef source, CFStringRef modeName);</div><div class="line"><span class="comment">// 对runloop添加observer观察，并指定观察mode</span></div><div class="line">CFRunLoopAddObserver(CFRunLoopRef rl, CFRunLoopObserverRef observer, CFStringRef modeName);</div><div class="line"><span class="comment">// 对runloop添加Timer定时源，并指定mode</span></div><div class="line">CFRunLoopAddTimer(CFRunLoopRef rl, CFRunLoopTimerRef timer, CFStringRef mode);</div><div class="line"><span class="comment">// 移除source源</span></div><div class="line">CFRunLoopRemoveSource(CFRunLoopRef rl, CFRunLoopSourceRef source, CFStringRef modeName);</div><div class="line"><span class="comment">// 移除观察者</span></div><div class="line">CFRunLoopRemoveObserver(CFRunLoopRef rl, CFRunLoopObserverRef observer, CFStringRef modeName);</div><div class="line"><span class="comment">// 移除定时器Timer</span></div><div class="line">CFRunLoopRemoveTimer(CFRunLoopRef rl, CFRunLoopTimerRef timer, CFStringRef mode);</div></pre></td></tr></table></figure>
<p>你只能通过 mode name 来操作内部的 mode，当你传入一个新的 mode name 但 RunLoop 内部没有对应 mode 时，RunLoop会自动帮你创建对应的 CFRunLoopModeRef。对于一个 RunLoop 来说，其内部的 mode 只能增加不能删除。</p>
<p>苹果公开提供的 Mode 有两个：kCFRunLoopDefaultMode (NSDefaultRunLoopMode) 和 UITrackingRunLoopMode，你可以用这两个 Mode Name 来操作其对应的 Mode。</p>
<p><strong>同时苹果还提供了一个操作 Common 标记的字符串：kCFRunLoopCommonModes (NSRunLoopCommonModes)，你可以用这个字符串来操作 Common Items，或标记一个 Mode 为 “Common”。使用时注意区分这个字符串和其他 mode name。</strong></p>
<h3 id="RunLoop的内部逻辑"><a href="#RunLoop的内部逻辑" class="headerlink" title="RunLoop的内部逻辑"></a>RunLoop的内部逻辑</h3><p>根据苹果在<a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html#//apple_ref/doc/uid/10000057i-CH16-SW23" target="_blank" rel="noopener">文档</a>里的说明，RunLoop 内部的逻辑大致如下：题图引用自ibireme大神的<a href="https://blog.ibireme.com/2015/05/18/runloop/" target="_blank" rel="noopener">《深入理解RunLoop》</a>博文。</p>
<p><img src="https://blog.ibireme.com/wp-content/uploads/2015/05/RunLoop_1.png" alt="runloopImg1"></p>
<p>其内部代码整理后如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="comment">/// 用DefaultMode启动</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">CFRunLoopRun</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</div><div class="line">    CFRunLoopRunSpecific(CFRunLoopGetCurrent(), kCFRunLoopDefaultMode, <span class="number">1.0e10</span>, <span class="literal">false</span>);</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="comment">/// 用指定的Mode启动，允许设置RunLoop超时时间</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">CFRunLoopRunInMode</span><span class="params">(CFStringRef modeName, CFTimeInterval seconds, Boolean stopAfterHandle)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> CFRunLoopRunSpecific(CFRunLoopGetCurrent(), modeName, seconds, returnAfterSourceHandled);</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="comment">/// RunLoop的实现</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">CFRunLoopRunSpecific</span><span class="params">(runloop, modeName, seconds, stopAfterHandle)</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="comment">/// 首先根据modeName找到对应mode</span></div><div class="line">    CFRunLoopModeRef currentMode = __CFRunLoopFindMode(runloop, modeName, <span class="literal">false</span>);</div><div class="line">    <span class="comment">/// 如果mode里没有source/timer/observer, 直接返回。</span></div><div class="line">    <span class="keyword">if</span> (__CFRunLoopModeIsEmpty(currentMode)) <span class="keyword">return</span>;</div><div class="line">    </div><div class="line">    <span class="comment">/// 1. 通知 Observers: RunLoop 即将进入 loop。</span></div><div class="line">    __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopEntry);</div><div class="line">    </div><div class="line">    <span class="comment">/// 内部函数，进入loop</span></div><div class="line">    __CFRunLoopRun(runloop, currentMode, seconds, returnAfterSourceHandled) &#123;</div><div class="line">        </div><div class="line">        Boolean sourceHandledThisLoop = NO;</div><div class="line">        <span class="keyword">int</span> retVal = <span class="number">0</span>;</div><div class="line">        <span class="keyword">do</span> &#123;</div><div class="line"> </div><div class="line">            <span class="comment">/// 2. 通知 Observers: RunLoop 即将触发 Timer 回调。</span></div><div class="line">            __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeTimers);</div><div class="line">            <span class="comment">/// 3. 通知 Observers: RunLoop 即将触发 Source0 (非port) 回调。</span></div><div class="line">            __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeSources);</div><div class="line">            <span class="comment">/// 执行被加入的block</span></div><div class="line">            __CFRunLoopDoBlocks(runloop, currentMode);</div><div class="line">            </div><div class="line">            <span class="comment">/// 4. RunLoop 触发 Source0 (非port) 回调。</span></div><div class="line">            sourceHandledThisLoop = __CFRunLoopDoSources0(runloop, currentMode, stopAfterHandle);</div><div class="line">            <span class="comment">/// 执行被加入的block</span></div><div class="line">            __CFRunLoopDoBlocks(runloop, currentMode);</div><div class="line"> </div><div class="line">            <span class="comment">/// 5. 如果有 Source1 (基于port) 处于 ready 状态，直接处理这个 Source1 然后跳转去处理消息。</span></div><div class="line">            <span class="keyword">if</span> (__Source0DidDispatchPortLastTime) &#123;</div><div class="line">                Boolean hasMsg = __CFRunLoopServiceMachPort(dispatchPort, &amp;msg)</div><div class="line">                <span class="keyword">if</span> (hasMsg) <span class="keyword">goto</span> handle_msg;</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            <span class="comment">/// 通知 Observers: RunLoop 的线程即将进入休眠(sleep)。</span></div><div class="line">            <span class="keyword">if</span> (!sourceHandledThisLoop) &#123;</div><div class="line">                __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeWaiting);</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            <span class="comment">/// 7. 调用 mach_msg 等待接受 mach_port 的消息。线程将进入休眠, 直到被下面某一个事件唤醒。</span></div><div class="line">            <span class="comment">/// • 一个基于 port 的Source 的事件。</span></div><div class="line">            <span class="comment">/// • 一个 Timer 到时间了</span></div><div class="line">            <span class="comment">/// • RunLoop 自身的超时时间到了</span></div><div class="line">            <span class="comment">/// • 被其他什么调用者手动唤醒</span></div><div class="line">            __CFRunLoopServiceMachPort(waitSet, &amp;msg, <span class="keyword">sizeof</span>(msg_buffer), &amp;livePort) &#123;</div><div class="line">                mach_msg(msg, MACH_RCV_MSG, port); <span class="comment">// thread wait for receive msg</span></div><div class="line">            &#125;</div><div class="line"> </div><div class="line">            <span class="comment">/// 8. 通知 Observers: RunLoop 的线程刚刚被唤醒了。</span></div><div class="line">            __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopAfterWaiting);</div><div class="line">            </div><div class="line">            <span class="comment">/// 收到消息，处理消息。</span></div><div class="line">            handle_msg:</div><div class="line"> </div><div class="line">            <span class="comment">/// 9.1 如果一个 Timer 到时间了，触发这个Timer的回调。</span></div><div class="line">            <span class="keyword">if</span> (msg_is_timer) &#123;</div><div class="line">                __CFRunLoopDoTimers(runloop, currentMode, mach_absolute_time())</div><div class="line">            &#125; </div><div class="line"> </div><div class="line">            <span class="comment">/// 9.2 如果有dispatch到main_queue的block，执行block。</span></div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (msg_is_dispatch) &#123;</div><div class="line">                __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(msg);</div><div class="line">            &#125; </div><div class="line"> </div><div class="line">            <span class="comment">/// 9.3 如果一个 Source1 (基于port) 发出事件了，处理这个事件</span></div><div class="line">            <span class="keyword">else</span> &#123;</div><div class="line">                CFRunLoopSourceRef source1 = __CFRunLoopModeFindSourceForMachPort(runloop, currentMode, livePort);</div><div class="line">                sourceHandledThisLoop = __CFRunLoopDoSource1(runloop, currentMode, source1, msg);</div><div class="line">                <span class="keyword">if</span> (sourceHandledThisLoop) &#123;</div><div class="line">                    mach_msg(reply, MACH_SEND_MSG, reply);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            <span class="comment">/// 执行加入到Loop的block</span></div><div class="line">            __CFRunLoopDoBlocks(runloop, currentMode);</div><div class="line">            </div><div class="line"> </div><div class="line">            <span class="keyword">if</span> (sourceHandledThisLoop &amp;&amp; stopAfterHandle) &#123;</div><div class="line">                <span class="comment">/// 进入loop时参数说处理完事件就返回。</span></div><div class="line">                retVal = kCFRunLoopRunHandledSource;</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (timeout) &#123;</div><div class="line">                <span class="comment">/// 超出传入参数标记的超时时间了</span></div><div class="line">                retVal = kCFRunLoopRunTimedOut;</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (__CFRunLoopIsStopped(runloop)) &#123;</div><div class="line">                <span class="comment">/// 被外部调用者强制停止了</span></div><div class="line">                retVal = kCFRunLoopRunStopped;</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (__CFRunLoopModeIsEmpty(runloop, currentMode)) &#123;</div><div class="line">                <span class="comment">/// source/timer/observer一个都没有了</span></div><div class="line">                retVal = kCFRunLoopRunFinished;</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            <span class="comment">/// 如果没超时，mode里没空，loop也没被停止，那继续loop。</span></div><div class="line">        &#125; <span class="keyword">while</span> (retVal == <span class="number">0</span>);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">/// 10. 通知 Observers: RunLoop 即将退出。</span></div><div class="line">    __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopExit);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到，实际上 RunLoop 就是这样一个函数，其内部是一个 do-while 循环。当你调用 CFRunLoopRun() 时，线程就会一直停留在这个循环里；直到超时或被手动停止，该函数才会返回。</p>
<h5 id="过程分析："><a href="#过程分析：" class="headerlink" title="过程分析："></a>过程分析：</h5><p>结合上面的图示和CFRunLoop 源码可以更清晰的看出来Runloop内部的核心工作原理。当进入Loop后，首先会通知Observer 将要处理Timer、Source0事件，然后处理Source0任务，如果有Source1(基于port)则会唤醒loop并处理相应的任务，如果没有Source1则会休眠，等待唤醒，一直循环执行2-9之间的任务，直到RunLoop被停止。</p>
<h5 id="难点注释：mach-port"><a href="#难点注释：mach-port" class="headerlink" title="难点注释：mach_port"></a>难点注释：mach_port</h5><p>RunLoop的核心是基于mach port 的，其进入休眠时调用的函数是mach_msg()。OS X / iOS 系统架构采用的XNU内核，其内环被称作Mach，作为XNU的微内核，仅提供了诸如处理器调度、IPC (进程间通信)等非常少量的基础服务。</p>
<p>和其他架构不同， Mach 的对象间不能直接调用，只能通过消息传递的方式实现对象间的通信。”消息”是 Mach 中最基础的概念，消息在两个端口 (port) 之间传递，这就是 Mach 的 IPC (进程间通信) 的核心。</p>
<p>在RunLoop的实现代码中，当loop进入休眠后，会调用__CFRunLoopServiceMachPort（）函数（从7中可看出），用来等待内核mach_msg() 事件，当收到一个基于port（可理解为进程中通信的一个端口，uint32_t类型） 的source1 事件时，loop会被立即唤醒并处理相应任务，下面代码说明了可能处理的任务类型：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line">.......		</div><div class="line">    </div><div class="line"><span class="comment">// 发送"从休眠中被唤醒的" 通知</span></div><div class="line">__CFRunLoopDoObservers(kCFRunLoopAfterWaiting);</div><div class="line"></div><div class="line"><span class="comment">// 处理因timer的唤醒</span></div><div class="line"><span class="keyword">if</span> (wakeUpPort == timerPort)</div><div class="line">    __CFRunLoopDoTimers();</div><div class="line"></div><div class="line"><span class="comment">// 处理异步方法唤醒,如dispatch_async</span></div><div class="line"><span class="keyword">else</span> <span class="keyword">if</span> (wakeUpPort == mainDispatchQueuePort)</div><div class="line">    __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__()</div><div class="line"></div><div class="line"><span class="comment">// UI刷新,动画显示</span></div><div class="line"><span class="keyword">else</span></div><div class="line">    __CFRunLoopDoSource1();</div><div class="line"></div><div class="line"><span class="comment">// 再次确保是否有同步的方法需要调用</span></div><div class="line">__CFRunLoopDoBlocks();</div><div class="line"></div><div class="line">.......</div></pre></td></tr></table></figure>
<h3 id="iOS中RunLoop实现的功能"><a href="#iOS中RunLoop实现的功能" class="headerlink" title="iOS中RunLoop实现的功能"></a>iOS中RunLoop实现的功能</h3><p>首先我们可以看一下 App 启动后 RunLoop 的状态：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><div class="line">CFRunLoop &#123;</div><div class="line">    current mode = kCFRunLoopDefaultMode</div><div class="line">    common modes = &#123;</div><div class="line">        UITrackingRunLoopMode</div><div class="line">        kCFRunLoopDefaultMode</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    common mode items = &#123;</div><div class="line"> </div><div class="line">        <span class="comment">// source0 (manual)</span></div><div class="line">        CFRunLoopSource &#123;order =<span class="number">-1</span>, &#123;</div><div class="line">            callout = _UIApplicationHandleEventQueue&#125;&#125;</div><div class="line">        CFRunLoopSource &#123;order =<span class="number">-1</span>, &#123;</div><div class="line">            callout = PurpleEventSignalCallback &#125;&#125;</div><div class="line">        CFRunLoopSource &#123;order = <span class="number">0</span>, &#123;</div><div class="line">            callout = FBSSerialQueueRunLoopSourceHandler&#125;&#125;</div><div class="line"> </div><div class="line">        <span class="comment">// source1 (mach port)</span></div><div class="line">        CFRunLoopSource &#123;order = <span class="number">0</span>,  &#123;port = <span class="number">17923</span>&#125;&#125;</div><div class="line">        CFRunLoopSource &#123;order = <span class="number">0</span>,  &#123;port = <span class="number">12039</span>&#125;&#125;</div><div class="line">        CFRunLoopSource &#123;order = <span class="number">0</span>,  &#123;port = <span class="number">16647</span>&#125;&#125;</div><div class="line">        CFRunLoopSource &#123;order =<span class="number">-1</span>, &#123;</div><div class="line">            callout = PurpleEventCallback&#125;&#125;</div><div class="line">        CFRunLoopSource &#123;order = <span class="number">0</span>, &#123;port = <span class="number">2407</span>,</div><div class="line">            callout = _ZL20notify_port_callbackP12__CFMachPortPvlS1_&#125;&#125;</div><div class="line">        CFRunLoopSource &#123;order = <span class="number">0</span>, &#123;port = <span class="number">1</span>c03,</div><div class="line">            callout = __IOHIDEventSystemClientAvailabilityCallback&#125;&#125;</div><div class="line">        CFRunLoopSource &#123;order = <span class="number">0</span>, &#123;port = <span class="number">1b</span>03,</div><div class="line">            callout = __IOHIDEventSystemClientQueueCallback&#125;&#125;</div><div class="line">        CFRunLoopSource &#123;order = <span class="number">1</span>, &#123;port = <span class="number">1903</span>,</div><div class="line">            callout = __IOMIGMachPortPortCallback&#125;&#125;</div><div class="line"> </div><div class="line">        <span class="comment">// Ovserver</span></div><div class="line">        CFRunLoopObserver &#123;order = <span class="number">-2147483647</span>, activities = <span class="number">0x1</span>, <span class="comment">// Entry</span></div><div class="line">            callout = _wrapRunLoopWithAutoreleasePoolHandler&#125;</div><div class="line">        CFRunLoopObserver &#123;order = <span class="number">0</span>, activities = <span class="number">0x20</span>,          <span class="comment">// BeforeWaiting</span></div><div class="line">            callout = _UIGestureRecognizerUpdateObserver&#125;</div><div class="line">        CFRunLoopObserver &#123;order = <span class="number">1999000</span>, activities = <span class="number">0xa0</span>,    <span class="comment">// BeforeWaiting | Exit</span></div><div class="line">            callout = _afterCACommitHandler&#125;</div><div class="line">        CFRunLoopObserver &#123;order = <span class="number">2000000</span>, activities = <span class="number">0xa0</span>,    <span class="comment">// BeforeWaiting | Exit</span></div><div class="line">            callout = _ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv&#125;</div><div class="line">        CFRunLoopObserver &#123;order = <span class="number">2147483647</span>, activities = <span class="number">0xa0</span>, <span class="comment">// BeforeWaiting | Exit</span></div><div class="line">            callout = _wrapRunLoopWithAutoreleasePoolHandler&#125;</div><div class="line"> </div><div class="line">        <span class="comment">// Timer</span></div><div class="line">        CFRunLoopTimer &#123;firing = No, interval = <span class="number">3.1536e+09</span>, tolerance = <span class="number">0</span>,</div><div class="line">            next fire date = <span class="number">453098071</span> (<span class="number">-4421.76019</span> @ <span class="number">96223387169499</span>),</div><div class="line">            callout = _ZN2CAL14timer_callbackEP16__CFRunLoopTimerPv (QuartzCore.framework)&#125;</div><div class="line">    &#125;,</div><div class="line"> </div><div class="line">    modes ＝ &#123;</div><div class="line">        CFRunLoopMode  &#123;</div><div class="line">            sources0 =  &#123; <span class="comment">/* same as 'common mode items' */</span> &#125;,</div><div class="line">            sources1 =  &#123; <span class="comment">/* same as 'common mode items' */</span> &#125;,</div><div class="line">            observers = &#123; <span class="comment">/* same as 'common mode items' */</span> &#125;,</div><div class="line">            timers =    &#123; <span class="comment">/* same as 'common mode items' */</span> &#125;,</div><div class="line">        &#125;,</div><div class="line"> </div><div class="line">        CFRunLoopMode  &#123;</div><div class="line">            sources0 =  &#123; <span class="comment">/* same as 'common mode items' */</span> &#125;,</div><div class="line">            sources1 =  &#123; <span class="comment">/* same as 'common mode items' */</span> &#125;,</div><div class="line">            observers = &#123; <span class="comment">/* same as 'common mode items' */</span> &#125;,</div><div class="line">            timers =    &#123; <span class="comment">/* same as 'common mode items' */</span> &#125;,</div><div class="line">        &#125;,</div><div class="line"> </div><div class="line">        CFRunLoopMode  &#123;</div><div class="line">            sources0 = &#123;</div><div class="line">                CFRunLoopSource &#123;order = <span class="number">0</span>, &#123;</div><div class="line">                    callout = FBSSerialQueueRunLoopSourceHandler&#125;&#125;</div><div class="line">            &#125;,</div><div class="line">            sources1 = (null),</div><div class="line">            observers = &#123;</div><div class="line">                CFRunLoopObserver &gt;&#123;activities = <span class="number">0xa0</span>, order = <span class="number">2000000</span>,</div><div class="line">                    callout = _ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv&#125;</div><div class="line">            )&#125;,</div><div class="line">            timers = (null),</div><div class="line">        &#125;,</div><div class="line"> </div><div class="line">        CFRunLoopMode  &#123;</div><div class="line">            sources0 = &#123;</div><div class="line">                CFRunLoopSource &#123;order = <span class="number">-1</span>, &#123;</div><div class="line">                    callout = PurpleEventSignalCallback&#125;&#125;</div><div class="line">            &#125;,</div><div class="line">            sources1 = &#123;</div><div class="line">                CFRunLoopSource &#123;order = <span class="number">-1</span>, &#123;</div><div class="line">                    callout = PurpleEventCallback&#125;&#125;</div><div class="line">            &#125;,</div><div class="line">            observers = (null),</div><div class="line">            timers = (null),</div><div class="line">        &#125;,</div><div class="line">        </div><div class="line">        CFRunLoopMode  &#123;</div><div class="line">            sources0 = (null),</div><div class="line">            sources1 = (null),</div><div class="line">            observers = (null),</div><div class="line">            timers = (null),</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到，系统默认注册了5个Mode:</p>
<ol>
<li>kCFRunLoopDefaultMode: App的默认 Mode，通常主线程是在这个 Mode 下运行的。</li>
<li>UITrackingRunLoopMode: 界面跟踪 Mode，用于 ScrollView 追踪触摸滑动，保证界面滑动时不受其他 Mode 影响。</li>
<li>UIInitializationRunLoopMode: 在刚启动 App 时第进入的第一个 Mode，启动完成后就不再使用</li>
<li>GSEventReceiveRunLoopMode: 接受系统事件的内部 Mode，通常用不到。</li>
<li>kCFRunLoopCommonModes: 这是一个占位的 Mode，没有实际作用。</li>
</ol>
<p>下面是RunnLoop在iOS开发中的相关应用</p>
<h3 id="AutoreleasePool"><a href="#AutoreleasePool" class="headerlink" title="AutoreleasePool"></a>AutoreleasePool</h3><p>App启动后，苹果在主线程 RunLoop 里注册了两个 Observer，其回调都是 _wrapRunLoopWithAutoreleasePoolHandler()。</p>
<p>第一个 Observer 监视的事件是 Entry(即将进入Loop)，其回调内会调用 _objc_autoreleasePoolPush() 创建自动释放池。其 order 是-2147483647，优先级最高，保证创建释放池发生在其他所有回调之前。</p>
<p>第二个 Observer 监视了两个事件： BeforeWaiting(准备进入休眠) 时调用_objc_autoreleasePoolPop() 和 _objc_autoreleasePoolPush() 释放旧的池并创建新池；Exit(即将退出Loop) 时调用 _objc_autoreleasePoolPop() 来释放自动释放池。这个 Observer 的 order 是 2147483647，优先级最低，保证其释放池子发生在其他所有回调之后。</p>
<p>在主线程执行的代码，通常是写在诸如事件回调、Timer回调内的。这些回调会被 RunLoop 创建好的 AutoreleasePool 环绕着，所以不会出现内存泄漏，开发者也不必显示创建 Pool 了。</p>
<h3 id="事件响应"><a href="#事件响应" class="headerlink" title="事件响应"></a>事件响应</h3><p>苹果注册了一个 Source1 (基于 mach port 的) 用来接收系统事件，其回调函数为 __IOHIDEventSystemClientQueueCallback()。</p>
<p>当一个硬件事件(触摸/锁屏/摇晃等)发生后，首先由 IOKit.framework 生成一个 IOHIDEvent 事件并由 SpringBoard 接收。这个过程的详细情况可以参考<a href="http://iphonedevwiki.net/index.php/IOHIDFamily" target="_blank" rel="noopener">这里</a>。SpringBoard 只接收按键(锁屏/静音等)，触摸，加速，接近传感器等几种 Event，随后用 mach port 转发给需要的App进程。随后苹果注册的那个 Source1 就会触发回调，并调用 _UIApplicationHandleEventQueue() 进行应用内部的分发。</p>
<p>_UIApplicationHandleEventQueue() 会把 IOHIDEvent 处理并包装成 UIEvent 进行处理或分发，其中包括识别 UIGesture/处理屏幕旋转/发送给 UIWindow 等。通常事件比如 UIButton 点击、touchesBegin/Move/End/Cancel 事件都是在这个回调中完成的。</p>
<h3 id="手势识别"><a href="#手势识别" class="headerlink" title="手势识别"></a>手势识别</h3><p>当上面的 _UIApplicationHandleEventQueue() 识别了一个手势时，其首先会调用 Cancel 将当前的 touchesBegin/Move/End 系列回调打断。随后系统将对应的 UIGestureRecognizer 标记为待处理。</p>
<p>苹果注册了一个 Observer 监测 BeforeWaiting (Loop即将进入休眠) 事件，这个Observer的回调函数是 _UIGestureRecognizerUpdateObserver()，其内部会获取所有刚被标记为待处理的 GestureRecognizer，并执行GestureRecognizer的回调。</p>
<p>当有 UIGestureRecognizer 的变化(创建/销毁/状态改变)时，这个回调都会进行相应处理。</p>
<h3 id="界面更新"><a href="#界面更新" class="headerlink" title="界面更新"></a>界面更新</h3><p>当在操作 UI 时，比如改变了 Frame、更新了 UIView/CALayer 的层次时，或者手动调用了 UIView/CALayer 的 setNeedsLayout/setNeedsDisplay方法后，这个 UIView/CALayer 就被标记为待处理，并被提交到一个全局的容器去。</p>
<p>苹果注册了一个 Observer 监听 BeforeWaiting(即将进入休眠) 和 Exit (即将退出Loop) 事件，回调去执行一个很长的函数：<br>_ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv()。这个函数里会遍历所有待处理的 UIView/CAlayer 以执行实际的绘制和调整，并更新 UI 界面。</p>
<p>这个函数内部的调用栈大概是这样的：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><div class="line">_ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv()</div><div class="line">    QuartzCore:CA::Transaction::observer_callback:</div><div class="line">        CA::Transaction::commit();</div><div class="line">            CA::Context::commit_transaction();</div><div class="line">                CA::Layer::layout_and_display_if_needed();</div><div class="line">                    CA::Layer::layout_if_needed();</div><div class="line">                        [<span class="built_in">CALayer</span> layoutSublayers];</div><div class="line">                            [<span class="built_in">UIView</span> layoutSubviews];</div><div class="line">                    CA::Layer::display_if_needed();</div><div class="line">                        [<span class="built_in">CALayer</span> display];</div><div class="line">                            [<span class="built_in">UIView</span> drawRect];</div></pre></td></tr></table></figure>
<h3 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h3><p>NSTimer 其实就是 CFRunLoopTimerRef，他们之间是 toll-free bridged 的。一个 NSTimer 注册到 RunLoop 后，RunLoop 会为其重复的时间点注册好事件。例如 10:00, 10:10, 10:20 这几个时间点。RunLoop为了节省资源，并不会在非常准确的时间点回调这个Timer。Timer 有个属性叫做 Tolerance (宽容度)，标示了当时间点到后，容许有多少最大误差。</p>
<p>如果某个时间点被错过了，例如执行了一个很长的任务，则那个时间点的回调也会跳过去，不会延后执行。就比如等公交，如果 10:10 时我忙着玩手机错过了那个点的公交，那我只能等 10:20 这一趟了。</p>
<p>CADisplayLink 是一个和屏幕刷新率一致的定时器（但实际实现原理更复杂，和 NSTimer 并不一样，其内部实际是操作了一个 Source）。如果在两次屏幕刷新之间执行了一个长任务，那其中就会有一帧被跳过去（和 NSTimer 相似），造成界面卡顿的感觉。在快速滑动TableView时，即使一帧的卡顿也会让用户有所察觉。Facebook 开源的 AsyncDisplayLink 就是为了解决界面卡顿的问题，其内部也用到了 RunLoop，这个稍后我会再单独写一页博客来分析。</p>
<h3 id="PerformSelecter"><a href="#PerformSelecter" class="headerlink" title="PerformSelecter"></a>PerformSelecter</h3><p>当调用 NSObject 的 performSelecter:afterDelay: 后，实际上其内部会创建一个 Timer 并添加到当前线程的 RunLoop 中。所以如果当前线程没有 RunLoop，则这个方法会失效。</p>
<p>当调用 performSelector:onThread: 时，实际上其会创建一个 Timer 加到对应的线程去，同样的，如果对应线程没有 RunLoop 该方法也会失效。</p>
<h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>本文秉着学习RunLoop的应用及内部实现原理，阅读了大量前辈优秀的博文、以及查阅苹果开源代码进行整理学习，其中大部分参阅了ibireme大神的<a href="https://blog.ibireme.com/2015/05/18/runloop/" target="_blank" rel="noopener">《深入理解RunLoop》</a>一文，并有部分内容及图片的引用，感谢ibireme对于RunLoop文章的分享。</p>
<h3 id="参考-引用"><a href="#参考-引用" class="headerlink" title="参考/引用"></a>参考/引用</h3><blockquote>
<p><a href="https://honglu.me/2017/03/30/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3RunLoop/" target="_blank" rel="noopener">深入理解runloop</a></p>
<p><a href="http://www.dreamingwish.com/article/ios-multithread-program-runloop-the.html" target="_blank" rel="noopener">iOS多线程编程指南(三)RunLoop</a></p>
</blockquote>


                <hr>

                

                <ul class="pager">
                    
                        <li class="previous">
                            <a href="/2018/10/21/Method-Swizzling/" data-toggle="tooltip" data-placement="top" title="Method Swizzling">&larr; Previous Post</a>
                        </li>
                    
                    
                        <li class="next">
                            <a href="/2018/08/28/深入剖析Autorelease-Pool-自动释放池/" data-toggle="tooltip" data-placement="top" title="深入剖析Autorelease Pool (自动释放池)">Next Post &rarr;</a>
                        </li>
                    
                </ul>

                

                

            </div>
    <!-- Side Catalog Container -->
        
            <div class="
                col-lg-2 col-lg-offset-0
                visible-lg-block
                sidebar-container
                catalog-container">
                <div class="side-catalog">
                    <hr class="hidden-sm hidden-xs">
                    <h5>
                        <a class="catalog-toggle" href="#">CATALOG</a>
                    </h5>
                    <ul class="catalog-body"></ul>
                </div>
            </div>
        

    <!-- Sidebar Container -->

            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                sidebar-container">

                <!-- Featured Tags -->
                
                <section>
                    <!-- no hr -->
                    <h5><a href="/tags/">FEATURED TAGS</a></h5>
                    <div class="tags">
                       
                          <a class="tag" href="/tags/#iOS" title="iOS">iOS</a>
                        
                    </div>
                </section>
                

                <!-- Friends Blog -->
                
                <hr>
                <h5>FRIENDS</h5>
                <ul class="list-inline">

                    
                        <li><a href="http://huangxuan.me" target="_blank">Hux Blog</a></li>
                    
                        <li><a href="https://unsplash.com/" target="_blank">Unsplash</a></li>
                    
                </ul>
                
            </div>

        </div>
    </div>
</article>







<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>
<!-- anchor-js, Doc:http://bryanbraun.github.io/anchorjs/ -->
<script>
    async("https://cdn.bootcss.com/anchor-js/1.1.1/anchor.min.js",function(){
        anchors.options = {
          visible: 'always',
          placement: 'right',
          icon: '#'
        };
        anchors.add().remove('.intro-header h1').remove('.subheading').remove('.sidebar-container h5');
    })
</script>
<style>
    /* place left on bigger screen */
    @media all and (min-width: 800px) {
        .anchorjs-link{
            position: absolute;
            left: -0.75em;
            font-size: 1.1em;
            margin-top : -0.1em;
        }
    }
</style>



    <!-- Footer -->
    <!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="list-inline text-center">
                
                
                    <li>
                        <a target="_blank" href="https://twitter.com/jerrywangjing">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-twitter fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                
                
                    <li>
                        <a target="_blank" href="https://www.zhihu.com/people/jing-wang-68-66">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa  fa-stack-1x fa-inverse">知</i>
                            </span>
                        </a>
                    </li>
                

                
                    <li>
                        <a target="_blank" href="http://weibo.com/JerryWang">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-weibo fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                

                

                
                    <li>
                        <a target="_blank"  href="https://github.com/jerrywangjing">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                

                

                </ul>
                <p class="copyright text-muted">
                    Copyright &copy; Jerry&#39;s Blog 2019 
                    <br>
                    Theme by <a href="http://huangxuan.me">Hux</a> 
                    <span style="display: inline-block; margin: 0 5px;">
                        <i class="fa fa-heart"></i>
                    </span> 
                    Ported by <a href="http://blog.kaijun.rocks">Kaijun</a> | 
                    <iframe
                        style="margin-left: 2px; margin-bottom:-5px;"
                        frameborder="0" scrolling="0" width="91px" height="20px"
                        src="https://ghbtns.com/github-btn.html?user=kaijun&repo=hexo-theme-huxblog&type=star&count=true" >
                    </iframe>
                </p>
            </div>
        </div>
    </div>
</footer>

<!-- jQuery -->
<script src="/js/jquery.min.js"></script>

<!-- Bootstrap Core JavaScript -->
<script src="/js/bootstrap.min.js"></script>

<!-- Custom Theme JavaScript -->
<script src="/js/hux-blog.min.js"></script>


<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>

<!-- 
     Because of the native support for backtick-style fenced code blocks 
     right within the Markdown is landed in Github Pages, 
     From V1.6, There is no need for Highlight.js, 
     so Huxblog drops it officially.

     - https://github.com/blog/2100-github-pages-now-faster-and-simpler-with-jekyll-3-0  
     - https://help.github.com/articles/creating-and-highlighting-code-blocks/    
-->
<!--
    <script>
        async("http://cdn.bootcss.com/highlight.js/8.6/highlight.min.js", function(){
            hljs.initHighlightingOnLoad();
        })
    </script>
    <link href="http://cdn.bootcss.com/highlight.js/8.6/styles/github.min.css" rel="stylesheet">
-->


<!-- jquery.tagcloud.js -->
<script>
    // only load tagcloud.js in tag.html
    if($('#tag_cloud').length !== 0){
        async("https://jerrywangjing.github.io/js/jquery.tagcloud.js",function(){
            $.fn.tagcloud.defaults = {
                //size: {start: 1, end: 1, unit: 'em'},
                color: {start: '#bbbbee', end: '#0085a1'},
            };
            $('#tag_cloud a').tagcloud();
        })
    }
</script>

<!--fastClick.js -->
<script>
    async("https://cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js", function(){
        var $nav = document.querySelector("nav");
        if($nav) FastClick.attach($nav);
    })
</script>


<!-- Google Analytics -->


<script>
    // dynamic User by Hux
    var _gaId = 'UA-136960405-1';
    var _gaDomain = 'auto';

    // Originial
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', _gaId, _gaDomain);
    ga('send', 'pageview');
</script>




<!-- Baidu Tongji -->


<!-- Side Catalog -->

<script type="text/javascript">
    function generateCatalog (selector) {
        var P = $('div.post-container'),a,n,t,l,i,c;
        a = P.find('h1,h2,h3,h4,h5,h6');
        a.each(function () {
            n = $(this).prop('tagName').toLowerCase();
            i = "#"+$(this).prop('id');
            t = $(this).text();
            c = $('<a href="'+i+'" rel="nofollow">'+t+'</a>');
            l = $('<li class="'+n+'_nav"></li>').append(c);
            $(selector).append(l);
        });
        return true;    
    }

    generateCatalog(".catalog-body");

    // toggle side catalog
    $(".catalog-toggle").click((function(e){
        e.preventDefault();
        $('.side-catalog').toggleClass("fold")
    }))

    /*
     * Doc: https://github.com/davist11/jQuery-One-Page-Nav
     * Fork by Hux to support padding
     */
    async("/js/jquery.nav.js", function () {
        $('.catalog-body').onePageNav({
            currentClass: "active",
            changeHash: !1,
            easing: "swing",
            filter: "",
            scrollSpeed: 700,
            scrollOffset: 0,
            scrollThreshold: .2,
            begin: null,
            end: null,
            scrollChange: null,
            padding: 80
        });
    });
</script>





<!-- Image to hack wechat -->
<img src="https://jerrywangjing.github.io/img/icon_wechat.png" width="0" height="0" />
<!-- Migrate from head to bottom, no longer block render and still work -->

</body>

</html>
