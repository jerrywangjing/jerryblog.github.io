<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[自建IPA分发平台]]></title>
    <url>%2F2019%2F07%2F31%2F%E8%87%AA%E5%BB%BAIPA%E5%88%86%E5%8F%91%E5%B9%B3%E5%8F%B0%2F</url>
    <content type="text"><![CDATA[前言目前iOS App的内侧分发渠道很多，包括：蒲公英、fir.im等等三方分发平台，用户注册账号后，可以直接上传Archive后的ipa文件即可通过生成的应用下载页来下载安装。但是，为了满足个性化以及品牌宣传等需求，我们需要自建H5下载页，并配置好相关数据也可以制定自定义的分发下载渠道。 配置步骤首先我们需要配置一个plist文件，包含2种尺寸的icon图标、app基本信息、和ipa文件的下载地址等，下面我们就以一个例子，介绍下具体的实现步骤： 1. Plist 文件# manifest-demo.plist 文件....&lt;array&gt; &lt;dict&gt; &lt;key&gt;kind&lt;/key&gt; &lt;string&gt;software-package&lt;/string&gt; &lt;key&gt;url&lt;/key&gt; &lt;string&gt;https://com.download.ipa&lt;/string&gt; &lt;!-- 这里填写ipa文件的下载地址 --&gt; &lt;/dict&gt; &lt;dict&gt; &lt;key&gt;kind&lt;/key&gt; &lt;string&gt;display-image&lt;/string&gt; &lt;key&gt;url&lt;/key&gt; &lt;string&gt;https://com.icon.57x57.png&lt;/string&gt; &lt;!-- 57x57 像素的icon图片 --&gt; &lt;/dict&gt; &lt;dict&gt; &lt;key&gt;kind&lt;/key&gt; &lt;string&gt;full-size-image&lt;/string&gt; &lt;key&gt;url&lt;/key&gt; &lt;string&gt;https://com.icon.512x512.png&lt;/string&gt; &lt;!-- 512x512 像素的icon图片 --&gt; &lt;/dict&gt; &lt;/array&gt; &lt;key&gt;metadata&lt;/key&gt; &lt;dict&gt; &lt;key&gt;bundle-identifier&lt;/key&gt; &lt;string&gt;com.app.xxx&lt;/string&gt; &lt;!-- 包名 --&gt; &lt;key&gt;bundle-version&lt;/key&gt; &lt;string&gt;1.0.0&lt;/string&gt; &lt;!-- 版本号 --&gt; &lt;key&gt;kind&lt;/key&gt; &lt;string&gt;software&lt;/string&gt; &lt;key&gt;title&lt;/key&gt; &lt;string&gt;appName&lt;/string&gt; &lt;!-- 应用名称 --&gt; &lt;key&gt;subtitle&lt;/key&gt; &lt;string&gt;subName&lt;/string&gt; &lt;!-- 副标题 --&gt; &lt;/dict&gt;.... 上面是一个plist配置文件的demo，可以直接在上面修改相关信息，也可以在Archive 打包的时候在Xcode 的提示框中勾选同时生成该plist文件。一般都采取直接修改现成的plist文件即可。demo文件可以点击这里下载 2. 下载链接接下来，我们需要将上面配置好的plist文件移交给后台开发人员，进行服务器端配置。然后，前端需要将点击下载链接按照如下格式配置： itms-services://?action=download-manifest&amp;url=https://app.download.xxx.com/install-manifest.plist 其中，最主要的是修改”url= ‘’ 为刚才服务器端配置的plist文件下载地址，例如：https://app.download.xxx.com/install-manifest.plist 然后，在h5页面中将下载按钮的响应链接（例如：标签）配置为上面的地址。例如： &lt;a href="itms-services://?action=download-manifest&amp;url=https://app.download.xxx.com/install-manifest.plist"&gt;立即下载&lt;/a&gt; 3. 测试基本的配置就这么多，现在我们可以在实际项目中进行测试了，当点击下载按钮的时候回弹出一个提示框：”是否下载xxx应用?”，这里注意前提是需要先给这个ipa包进行企业签名才能进行公测分发。点击下载后，回到桌面即可看到应用已经在安装了。 结语整个配置流程也很简单，从配置plist文件，到配置下载链接，最重要的还是要和后台配合。有此需求的小伙伴，赶快动手亲自尝试一下吧！]]></content>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ReactiveCocoa 使用指南]]></title>
    <url>%2F2019%2F06%2F17%2FReactiveCocoa-%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97%2F</url>
    <content type="text"><![CDATA[简介ReactiveCocoa是由GitHub开源的一款函数响应式编程框架（FRP），打破了Objective-C一贯的命令式编程的风格，结合函数式编程和响应式编程思想，将iOS开发中的各种不同事件抽象成一个数据流（RACSignal），这也被称做信号，并且内部制定了统一接口，并提供了对数据流进行连接、过滤和组合的API接口。 RactiveCocoa 中使用使用到的编程风格： 函数式编程（Functional Programming）：使用高阶函数，例如：函数用其他函数作为参数。 响应式编程（Reactive Programming）：关注于数据流和变化传播 ReactiveCocoa编程框架的强大之处在于，能将原本繁琐的target-action、delegate、KVO、callback等iOS开发中常见的开发模式，使用函数式编程范式将一个个操作串联到一起，并实现了view和Model之间的双向绑定，从而对iOS中实现MVVM开发架构提供了简便而强大的支持。 框架类图 下图引用自博客《ReactiveCocoa v2.5 源码解析之架构总览》— 雷纯峰的博客 从上面的类图中，我们可以看出，ReactiveCocoa 主要由以下四大核心组件构成： 信号源：RACStream及其子类； 订阅者：RACSubscriber的实现类及其子类； 调度器：RACScheduler及其子类； 清洁工：RACDisposable及其子类； 其中，信号源又是最核心的部分，其他组件都是围绕它运作的。通过信号，将iOS开发中的所有异步事件封装为一个统一的block回调，大大简化了对异步事件的逻辑处理，从而使整个逻辑代码看起来很连贯、自然，一气呵成。 下面我们通过代码示例来说明，在RAC中是如何实现的： // 代理方法[[self rac_signalForSelector:@selector(webViewDidStartLoad:) fromProtocol:@protocol(UIWebViewDelegate)] subscribeNext:^(id x) &#123; // 实现 webViewDidStartLoad: 代理方法 &#125;];// target-action[[self.avatarButton rac_signalForControlEvents:UIControlEventTouchUpInside] subscribeNext:^(UIButton *avatarButton) &#123; // avatarButton 被点击了 &#125;];// 通知[[[NSNotificationCenter defaultCenter] rac_addObserverForName:kReachabilityChangedNotification object:nil] subscribeNext:^(NSNotification *notification) &#123; // 收到 kReachabilityChangedNotification 通知 &#125;];// KVO[RACObserve(self, username) subscribeNext:^(NSString *username) &#123; // 用户名发生了变化&#125;]; 然而，ReactiveCocoa的强大之处不仅仅是这些，重要的是它还可以将这些信号进行任意地组合、链接、转换等操作，例如将登陆页面中的账号和密码数据的信号通过一个规则进行合并，同时产生一个新的信号： [[[RACSignal combineLatest:@[ RACObserve(self, username), RACObserve(self, password) ] reduce:^(NSString *username, NSString *password) &#123; return @(username.length &gt; 0 &amp;&amp; password.length &gt; 0); &#125;] distinctUntilChanged] subscribeNext:^(NSNumber *valid) &#123; if (valid.boolValue) &#123; // 用户名和密码合法，登录按钮可用 &#125; else &#123; // 用户名或密码不合法，登录按钮不可用 &#125; &#125;]; RAC常用API手册常见类RACSiganl 信号类。 RACEmptySignal ：空信号，用来实现 RACSignal 的 +empty 方法； RACReturnSignal ：一元信号，用来实现 RACSignal 的 +return: 方法； RACDynamicSignal ：动态信号，使用一个 block - 来实现订阅行为，我们在使用 RACSignal 的 +createSignal: 方法时创建的就是该类的实例； RACErrorSignal ：错误信号，用来实现 RACSignal 的 +error: 方法； RACChannelTerminal ：通道终端，代表 RACChannel 的一个终端，用来实现双向绑定。 RACSubscriber 订阅者RACDisposable 用于取消订阅或者清理资源，当信号发送完成或者发送错误的时候，就会自动触发它。 RACSerialDisposable ：作为 disposable 的容器使用，可以包含一个 disposable 对象，并且允许将这个 disposable 对象通过原子操作交换出来； RACKVOTrampoline ：代表一次 KVO 观察，并且可以用来停止观察； RACCompoundDisposable ：它可以包含多个 disposable 对象，并且支持手动添加和移除 disposable 对象 RACScopedDisposable ：当它被 dealloc 的时候调用本身的 -dispose 方法。 RACSubject 信号提供者，自己可以充当信号，又能发送信号。订阅后发送 RACGroupedSignal ：分组信号，用来实现 RACSignal 的分组功能； RACBehaviorSubject ：重演最后值的信号，当被订阅时，会向订阅者发送它最后接收到的值； RACReplaySubject ：重演信号，保存发送过的值，当被订阅时，会向订阅者重新发送这些值。可以先发送后订阅 RACTuple 元组类,类似NSArray,用来包装值.RACSequence RAC中的集合类RACCommand RAC中用于处理事件的类，可以把事件如何处理,事件中的数据如何传递，包装到这个类中，他可以很方便的监控事件的执行过程。RACMulticastConnection 用于当一个信号，被多次订阅时，为了保证创建信号时，避免多次调用创建信号中的block，造成副作用，可以使用这个类处理。RACScheduler RAC中的队列，用GCD封装的。 RACImmediateScheduler ：立即执行调度的任务，这是唯一一个支持同步执行的调度器； RACQueueScheduler ：一个抽象的队列调度器，在一个 GCD 串行列队中异步调度所有任务； RACTargetQueueScheduler ：继承自 RACQueueScheduler ，在一个以一个任意的 GCD 队列为 target 的串行队列中异步调度所有任务； RACSubscriptionScheduler ：一个只用来调度订阅的调度器。 常见用法 rac_signalForSelector : 代替代理 rac_valuesAndChangesForKeyPath: KVO rac_signalForControlEvents:监听事件 rac_addObserverForName 代替通知 rac_textSignal：监听文本框文字改变 rac_liftSelector:withSignalsFromArray:Signals:当传入的Signals(信号数组)，每一个signal都至少sendNext过一次，就会去触发第一个selector参数的方法。 常见宏 RAC(TARGET, [KEYPATH, [NIL_VALUE]])：用于给某个对象的某个属性绑定 RACObserve(self, name) ：监听某个对象的某个属性,返回的是信号。 @weakify(Obj)和@strongify(Obj) RACTuplePack ：把数据包装成RACTuple（元组类） RACTupleUnpack：把RACTuple（元组类）解包成对应的数据 RACChannelTo 用于双向绑定的一个终端 常用操作方法 flattenMap map 用于把源信号内容映射成新的内容。 concat 组合 按一定顺序拼接信号，当多个信号发出的时候，有顺序的接收信号 then 用于连接两个信号，当第一个信号完成，才会连接then返回的信号。 merge 把多个信号合并为一个信号，任何一个信号有新值的时候就会调用 zipWith 把两个信号压缩成一个信号，只有当两个信号同时发出信号内容时，并且把两个信号的内容合并成一个元组，才会触发压缩流的next事件。 combineLatest:将多个信号合并起来，并且拿到各个信号的最新的值,必须每个合并的signal至少都有过一次sendNext，才会触发合并的信号。 reduce聚合:用于信号发出的内容是元组，把信号发出元组的值聚合成一个值 filter:过滤信号，使用它可以获取满足条件的信号. ignore:忽略完某些值的信号. distinctUntilChanged:当上一次的值和当前的值有明显的变化就会发出信号，否则会被忽略掉。 take:从开始一共取N次的信号 takeLast:取最后N次的信号,前提条件，订阅者必须调用完成，因为只有完成，就知道总共有多少信号. takeUntil:(RACSignal *):获取信号直到某个信号执行完成 skip:(NSUInteger):跳过几个信号,不接受。 switchToLatest:用于signalOfSignals（信号的信号），有时候信号也会发出信号，会在signalOfSignals中，获取signalOfSignals发送的最新信号。 doNext: 执行Next之前，会先执行这个Block doCompleted: 执行sendCompleted之前，会先执行这个Block timeout：超时，可以让一个信号在一定的时间后，自动报错。 interval 定时：每隔一段时间发出信号 delay 延迟发送next。 retry重试 ：只要失败，就会重新执行创建信号中的block,直到成功. replay重放：当一个信号被多次订阅,反复播放内容 throttle节流:当某个信号发送比较频繁时，可以使用节流，在某一段时间不发送信号内容，过了一段时间获取信号的最新内容发出。 UI - Category（常用汇总）rac_prepareForReuseSignal： 需要复用时用 相关UI: MKAnnotationView、UICollectionReusableView、UITableViewCell、UITableViewHeaderFooterView rac_buttonClickedSignal：点击事件触发信号 相关UI：UIActionSheet、UIAlertView rac_command：button类、刷新类相关命令替换 相关UI：UIBarButtonItem、UIButton、UIRefreshControl rac_signalForControlEvents: control event 触发 相关UI：UIControl rac_gestureSignal UIGestureRecognizer 事件处理信号 相关UI：UIGestureRecognizer rac_imageSelectedSignal 选择图片的信号 相关UI：UIImagePickerController rac_textSignal 相关UI：UITextField、UITextView 可实现双向绑定的相关API rac_channelForControlEvents: key: nilValue: 相关UI：UIControl类 rac_newDateChannelWithNilValue: 相关UI：UIDatePicker rac_newSelectedSegmentIndexChannelWithNilValue: 相关UI：UISegmentedControl rac_newValueChannelWithNilValue: 相关UI：UISlider、UIStepper rac_newOnChannel 相关UI：UISwitch rac_newTextChannel 相关UI：UITextField Foundation - Category （常用汇总）NSData rac_readContentsOfURL: options: scheduler: 比oc多出线程设置 NSDictionary rac_sequence rac_keySequence key 集合 rac_valueSequence value 集合 NSArray rac_sequence 信号集合 NSFileHandle rac_readInBackground 后台线程读取 NSInvocation rac_setArgument: atIndex: 设置参数 rac_argumentAtIndex 取某个参数 rac_returnValue 所关联方法的返回值 NSNotificationCenter rac_addObserverForName: object:注册通知 NSObject rac_willDeallocSignal 对象销毁时发动的信号 rac_description debug用 rac_observeKeyPath: options: observer: block:监听某个事件 rac_liftSelector: withSignals: 全部信号都next在执行 rac_signalForSelector: 代替某个方法 rac_signalForSelector:(SEL)selector fromProtocol:代替代理 NSString rac_keyPathComponents 获取一个路径所有的部分 rac_keyPathByDeletingLastKeyPathComponent 删除路径最后一部分 rac_keyPathByDeletingFirstKeyPathComponent 删除路径第一部分 rac_readContentsOfURL: usedEncoding: scheduler: 比之OC多线程调用 rac_sequence NSURLConnection rac_sendAsynchronousRequest 发起异步请求 NSUserDefaults rac_channelTerminalForKey 用于双向绑定，此乃一 NSEnumerator rac_sequence NSIndexSet rac_sequence NSOrderedSet rac_sequence NSSet rac_sequence 总结本文简单介绍了ReactiveCocoa函数响应式库，并列举了在实际开发中几个常见的用法，真实感受到了ReactiveCocoa库的强大和精妙之处。对iOS开发提供了一条新思路，为实现MVVM架构提供了视图与模型的绑定功能，同时也提升了iOS应用的开发效率。 最后，如果你对响应式编程感兴趣，鉴于强大的ReactiveCocoa库，赶紧接入到自己的项目中体验吧！ 参考/引用ReactiveCocoa v2.5 源码解析之架构总览 iOS ReactiveCocoa 最全常用API整理]]></content>
      <tags>
        <tag>ReactiveCocoa</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LLVM架构与Clang]]></title>
    <url>%2F2019%2F05%2F19%2FLLVM%E6%9E%B6%E6%9E%84%E4%B8%8EClang%2F</url>
    <content type="text"><![CDATA[LLVM简介LLVM是一个模块化的、可重用的编译器和工具链技术的集合。最开始是由克里斯·拉特纳（Chris Lattner）在伊利诺伊大学主导开发的一个研究项目，目的是提供一个现代的、基于SSA编译策略的，能够支持任意编程语言和动态编译的编译器和工具链的集合。 后来，克里斯及其他的团队被苹果雇佣了，为实现苹果系统中的各种用途而开发LLVM系统。 克里斯·拉特纳也是Swift之父，在苹果任职期间主导研发了Swift语言，编译部分也采用了LLVM工具链技术。 LLVM名称最初的由来是低级虚拟机首字母的缩写（Low Level Virtual Machine），后来由于这个解释不能准确的代表当前LLVM编译系统的强大和特别之处，LLVM系统是由众多子系统组成的包括LLVM内核、Clang编译前端、LLDB调试器、libc++标准库等等，所以官方也放弃了这个解释，而LLVM是作为整个系统的全称，这里可以参考LLVM官方网站。 传统编译器架构传统的静态编译器最流行的就是金典的三段式设计，其主要组件是前端（Frontend）、优化器（Optimiser）、和后端（Backend）。如下图所示： 前端（Fontend）： 主要对源代码进行词法分析、语法分析、语义分析并生成具有层级关系的抽象语语法树（AST），最后生成中间代码（IR） 优化器（Optimizer）：优化器负责执行各种各样的转换，以尝试改进代码的运行时间，例如消除冗余代码，这个过程通常是与前后端无关的。 后端（Backend）：主要是根据目标指令集生成机器代码，还可以根据所支持的体系结构特点，来生成适应该架构的优质代码。编译器后端常见的部分包括指令选择、寄存器分配和指令调度。 这个模型同样适用于解释器和JIT编译器。Java虚拟机（JVM - Java Virtual Machine）也是这个模型的实现，它使用Java字节码作为前端和优化器之间的接口。 LLVM三段式架构LLVM的不同之处在于，可以作为多种前端编译器的优化器，并且可以针对多种CPU架构生成对应的机器代码。其优势就是优化器的功能可重用，适用于多种编程语言和多种CPU架构平台。如下图所示： 这种架构设计的优势： 可重用：由于前后端是分离的，当需要移植一个新语言源时，只需要实现一个新的前端，而现有的优化器和后端可以直接重用。 模块化：不同于其他编译器（如：GCC）的整体式设计，LLVM将各个阶段的编译技术模块化，尤其是语言无关的通用优化器，可支持多种语言输入，可输出多种架构的机器代码。 丰富的开发者资源：这种设计意味着它支持不止一种源语言和目标平台（如：x86、ARM、MIPS），会吸引更多的开发人员参与到该项目中，就会有更多高质量的代码产生，这自然会对编译器带来更多的增强和改进。 有利于分工：实现前端所需的技能与优化器、后端所需的技能不同，将它们分开可以使“前端人员”更容易地增强和维护他们的编译器部分。”后端人员“可以专注于中间代码的优化和目标平台机器代码的生成。 LLVM编译过程分析： 词法分析： 将源代码中的所有字符切分成记号(Token)的序列。包括了词法分析器、记号序列化生成器和扫描器，不过扫描器常常作为词法分析器的第一阶段。 语法分析： 分析符合一定语法规则的一串符号，它通常会生成一个抽象语法树（AST - Abstract Syntax tree），用于表示记号之间的语法关系。 语义分析： 通过语法分析的解析后，这个过程将从源代码中收集必要的语义信息，通常包括类型检查、在使用之前确保声明了变量等等。 中间代码(IR)生成：代码在这个阶段会转换为中间表示式(IR)，这是一种中立的语言，与源语言(前端)和机器(后端)无关。 优化中间表达式。 中间代码常常会有冗余和死代码的情况出现，而优化器可以处理这些问题以获得更优异的性能。 生成目标代码： 最后后端会生成在目标机器上运行的机器码，我们也将其称之为目标代码。 从上述分析可以看出在LLVM架构下的编译器是如何一步一步将我们写源代码编译成机器可执行的代码的。通常，狭义的LLVM仅包括优化器和编译后端，也就是只负责IR的优化和目标代码的生成。然而，广义上的LLVM则是指所有的三个阶段、完整的编译工具链，以及一整套的SDK编译器开发技术体系，我们通常称之为：LLVM集合。 下面我们将引用一张图来表示完整的LLVM工具链集合的六大执行单元： ClangClang是LLVM编译工具集中的一个重要成员，由C++编写，是C、C++、Objective-C/C++ 的编译前端。 Clang的开发目标是提供一个可以替代GCC的前端编译器。与GCC相比，Clang是一个重新设计的编译器前端，具有一系列优点，例如模块化，代码简单易懂，占用内存小以及容易扩展和重用等。由于 Clang 在设计上的优异性，使得 Clang 非常适合用于设计源代码级别的分析和转化工具。Clang 也已经被应用到一些重要的开发领域，如 Static Analysis 是一个基于 Clang 的静态代码分析工具。 由于 GNU 编译器套装 (GCC) 系统庞大，而且 Apple 大量使用的 Objective-C 在 GCC 中优先级较低，同时 GCC 作为一个纯粹的编译系统，与 IDE 配合并不优秀，Apple 决定从零开始写 C family 的前端，也就是基于 LLVM 的 Clang 了。Clang 由 Apple 公司开发，源代码授权使用 BSD 的开源授权。 Clang 的特性相比于 GCC，Clang 具有如下优点： 编译速度快：在特定平台上，Clang 的编译速度显著的快过 GCC。 占用内存小：Clang 生成的 AST 所占用的内存是 GCC 的五分之一左右。 模块化设计：Clang 采用基于库的模块化设计，易于 IDE 集成及其他用途的重用。 诊断信息可读性强：在编译过程中，Clang 创建并保留了大量详细的元数据 (metadata)，有利于调试和错误报告，例如Xcode中对错误精确的标红提示，以及给出快捷修复建议等。 设计清晰简单：容易理解，易于扩展增强，与代码基础古老的 GCC 相比，学习曲线平缓。 当前 Clang 还处在不断完善过程中，相比于 GCC, Clang 在以下方面还需要加强： 支持更多语言：GCC 除了支持 C/C++/Objective-C, 还支持 Fortran/Pascal/Java/Ada/Go 和其他语言。Clang 目前支持的语言有 C/C++/Objective-C/Objective-C++。 加强对 C++ 的支持：Clang 对 C++ 的支持依然落后于 GCC，Clang 还需要加强对 C++ 提供全方位支持。 支持更多平台：GCC 流行的时间比较长，已经被广泛使用，对各种平台的支持也很完备。Clang 目前支持的平台有 Linux/Windows/Mac OS。 Clang的应用Clang作为编译前端，对源代码进行词法分析和语法分析，并将分析结果转换为抽象语法树（AST），最后生成IR中间代码提交给LLVM做下一步的优化。下面我们将从应用的角度讲一下，Clang是如何进行这些分析的。 首先，我们在终端创建一个main.m 文件，示例代码如下： // main.mint main()&#123; int a; int b = 10; a = b; return a;&#125; 然后，Clang会对代码进行词法分析，将代码切分成Token，可通过如下命令来查看所有的Token： clang -fmodules -E -Xclang -dump-tokens main.m 输入的Token序列打印如下： int 'int' [StartOfLine] Loc=&lt;main.m:2:1&gt;identifier 'main' [LeadingSpace] Loc=&lt;main.m:2:5&gt;l_paren '(' Loc=&lt;main.m:2:9&gt;r_paren ')' Loc=&lt;main.m:2:10&gt;l_brace '&#123;' Loc=&lt;main.m:2:11&gt;int 'int' [StartOfLine] [LeadingSpace] Loc=&lt;main.m:3:5&gt;identifier 'a' [LeadingSpace] Loc=&lt;main.m:3:9&gt;semi ';' Loc=&lt;main.m:3:10&gt;int 'int' [StartOfLine] [LeadingSpace] Loc=&lt;main.m:4:5&gt;identifier 'b' [LeadingSpace] Loc=&lt;main.m:4:9&gt;equal '=' [LeadingSpace] Loc=&lt;main.m:4:11&gt;numeric_constant '10' [LeadingSpace] Loc=&lt;main.m:4:13&gt;semi ';' Loc=&lt;main.m:4:15&gt;identifier 'a' [StartOfLine] [LeadingSpace] Loc=&lt;main.m:6:5&gt;equal '=' [LeadingSpace] Loc=&lt;main.m:6:7&gt;identifier 'b' [LeadingSpace] Loc=&lt;main.m:6:9&gt;semi ';' Loc=&lt;main.m:6:10&gt;return 'return' [StartOfLine] [LeadingSpace] Loc=&lt;main.m:8:5&gt;identifier 'a' [LeadingSpace] Loc=&lt;main.m:8:12&gt;semi ';' Loc=&lt;main.m:8:13&gt;r_brace '&#125;' [StartOfLine] Loc=&lt;main.m:9:1&gt;eof '' Loc=&lt;main.m:9:2&gt; 这个命令的作用是，显示每个 Token 的类型、值，以及位置。包括：关键字（比如：if、else、for…）、标识符（变量名）、字面量（值、数字、字符串）、特殊字符（加减乘除符号等）。 接下来，会进行语法分析，将输出的Token先按照语法组合成语义，生成节点，然后将这些节点按照层级关系构成抽象语法树（AST）。 在终端中执行如下命令即可看到main.m 文件源码的语法树： clang -fmodules -fsyntax-only -Xclang -ast-dump main.m 输出的AST代码如下所示： TranslationUnitDecl 0x7fbae500c0e8 &lt;&lt;invalid sloc&gt;&gt; &lt;invalid sloc&gt;|-TypedefDecl 0x7fbae500c660 &lt;&lt;invalid sloc&gt;&gt; &lt;invalid sloc&gt; implicit __int128_t '__int128'| `-BuiltinType 0x7fbae500c380 '__int128'|-TypedefDecl 0x7fbae500c6d0 &lt;&lt;invalid sloc&gt;&gt; &lt;invalid sloc&gt; implicit __uint128_t 'unsigned __int128'| `-BuiltinType 0x7fbae500c3a0 'unsigned __int128'|-TypedefDecl 0x7fbae500c770 &lt;&lt;invalid sloc&gt;&gt; &lt;invalid sloc&gt; implicit SEL 'SEL *'| `-PointerType 0x7fbae500c730 'SEL *'| `-BuiltinType 0x7fbae500c5c0 'SEL'|-TypedefDecl 0x7fbae500c858 &lt;&lt;invalid sloc&gt;&gt; &lt;invalid sloc&gt; implicit id 'id'| `-ObjCObjectPointerType 0x7fbae500c800 'id'| `-ObjCObjectType 0x7fbae500c7d0 'id'|-TypedefDecl 0x7fbae500c938 &lt;&lt;invalid sloc&gt;&gt; &lt;invalid sloc&gt; implicit Class 'Class'| `-ObjCObjectPointerType 0x7fbae500c8e0 'Class'| `-ObjCObjectType 0x7fbae500c8b0 'Class'|-ObjCInterfaceDecl 0x7fbae500c990 &lt;&lt;invalid sloc&gt;&gt; &lt;invalid sloc&gt; implicit Protocol|-TypedefDecl 0x7fbae500ccf8 &lt;&lt;invalid sloc&gt;&gt; &lt;invalid sloc&gt; implicit __NSConstantString 'struct __NSConstantString_tag'| `-RecordType 0x7fbae500cb00 'struct __NSConstantString_tag'| `-Record 0x7fbae500ca60 '__NSConstantString_tag'|-TypedefDecl 0x7fbae500cd90 &lt;&lt;invalid sloc&gt;&gt; &lt;invalid sloc&gt; implicit __builtin_ms_va_list 'char *'| `-PointerType 0x7fbae500cd50 'char *'| `-BuiltinType 0x7fbae500c180 'char'|-TypedefDecl 0x7fbae5043688 &lt;&lt;invalid sloc&gt;&gt; &lt;invalid sloc&gt; implicit __builtin_va_list 'struct __va_list_tag [1]'| `-ConstantArrayType 0x7fbae5043630 'struct __va_list_tag [1]' 1| `-RecordType 0x7fbae50434a0 'struct __va_list_tag'| `-Record 0x7fbae5043400 '__va_list_tag'`-FunctionDecl 0x7fbae5043730 &lt;main.m:2:1, line:9:1&gt; line:2:5 main 'int ()' `-CompoundStmt 0x7fbae5043a80 &lt;col:11, line:9:1&gt; |-DeclStmt 0x7fbae50438a0 &lt;line:3:5, col:10&gt; | `-VarDecl 0x7fbae5043840 &lt;col:5, col:9&gt; col:9 used a 'int' |-DeclStmt 0x7fbae5043950 &lt;line:4:5, col:15&gt; | `-VarDecl 0x7fbae50438d0 &lt;col:5, col:13&gt; col:9 used b 'int' cinit | `-IntegerLiteral 0x7fbae5043930 &lt;col:13&gt; 'int' 10 |-BinaryOperator 0x7fbae5043a00 &lt;line:6:5, col:9&gt; 'int' '=' | |-DeclRefExpr 0x7fbae5043968 &lt;col:5&gt; 'int' lvalue Var 0x7fbae5043840 'a' 'int' | `-ImplicitCastExpr 0x7fbae50439e8 &lt;col:9&gt; 'int' &lt;LValueToRValue&gt; | `-DeclRefExpr 0x7fbae50439a8 &lt;col:9&gt; 'int' lvalue Var 0x7fbae50438d0 'b' 'int' `-ReturnStmt 0x7fbae5043a68 &lt;line:8:5, col:12&gt; `-ImplicitCastExpr 0x7fbae5043a50 &lt;col:12&gt; 'int' &lt;LValueToRValue&gt; `-DeclRefExpr 0x7fbae5043a28 &lt;col:12&gt; 'int' lvalue Var 0x7fbae5043840 'a' 'int' 其中TranslationUnitDecl是根节点，表示一个编译单元；Decl表示一个声明；Expr表示的是表达式；Literal表示字面量，是一个特殊的Expr；Stmt表示语句。 Optimiser通过上述Clang的介绍，以及Clang是如何将main.m文件中的源代码一步步转换为AST的，最后Clang会将AST 转换为中间代码IR，交由优化器（Optimiser）来做代码优化。 从上图可以看出，在LLVM IR优化阶段，优化器被设计为由若干个Pass组成的集合，每个优化模块(Pass)都能读入IR，完成一些任务后，输出优化后的IR。 常见优化模块的例子是内联优化，它会将函数体替换为调用点(call sites)，还可以将表达式重新组合(expression reassociation)、移动循环不变代码(loop-invariant code motion)等等。根据优化级别的不同，可以调用不同的优化模块：例如，Clang编译器使用-O0（无优化状态）参数进行编译时不调用pass，在使用-O3时将会调用67个pass来进行IR的优化（从LLVM 2.8开始）。 由于优化器的模块化设计，Pass也可以进行自主开发，实现对LLVM 优化器的改进和增强。 总结本文讲解了LLVM编译器工具集的历史和由来，以及作为现代应用最广泛的编译器之一，介绍了其优良的架构设计，可重用的模块化构建思想。同时，也介绍了Clang编译前端的特性已及编译过程的举例分析。 通过对LLVM编译工具集的学习，深刻的感受到 了它的强大之处，先进的设计理念，想必能在以后的编程中提升对代码优化、底层思维逻辑的理解能力。 希望和我一样对LLVM编译器感兴趣的同学，能学习到对自己有用的知识，提高对编程的底层认知能力。 参考/引用 http://llvm.org/ https://www.kancloud.cn/yelbee111/annhub/991863 http://kuanghy.github.io/2015/08/20/llvm-abstruct]]></content>
      <tags>
        <tag>LLVM</tag>
        <tag>Clang</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS代码混淆之编译优化(三)]]></title>
    <url>%2F2019%2F03%2F10%2FiOS%E4%BB%A3%E7%A0%81%E6%B7%B7%E6%B7%86%E4%B9%8B%E7%BC%96%E8%AF%91%E4%BC%98%E5%8C%96(%E4%B8%89)%2F</url>
    <content type="text"><![CDATA[这是iOS代码混淆系列文章的最后一篇，前两篇可以点击下方链接查看 iOS代码混淆之方法名替换 iOS代码混淆之资源替换 前言前2篇文章已近讲了对于函数名的混淆，对项目中关键信息、资源文件的修改等相关混淆手段。但是，仅仅做到这几点就能万事大吉吗，黑客仍然可以通过分析代码逻辑或伪装代码来寻找程序漏洞，那么还有其他更坚固可靠的混淆方式呢，接下来就介绍下编译器级别的加固混淆方案。 iOS编译原理iOS 开发中 Objective-C 和 Swift 都用的是 Clang / LLVM 来编译的。Clang是作为编译前端，LLVM做为编译后端，共同完成了iOS项目代码的编译阶段。 Clang(编译前端)Clang 是 LLVM 的子项目，是 C，C++ 和 Objective-C 编译器，目的是提供惊人的快速编译，比 GCC 快3倍，其中的 clang static analyzer 主要是进行语法分析，语义分析和生成中间代码，当然这个过程会对代码进行检查，出错的和需要警告的会标注出来。 LLVM(编译后端)LLVM是一个模块化和可重用的编译器和工具链技术的集合，LLVM 核心库提供一个优化器，对流行的 CPU 做代码生成支持。LLVM 比较有特色的一点是它能提供一种代码编写良好的中间代码IR，这意味着它可以作为多种语言的后端，这样就能够提供语言无关的优化同时还能够方便的针对多种 CPU架构生成可执行代码。 HikariHikari 是一个基于 Obfuscator-LLVM 的改进，增加了一些额外的自定义构建通道，更简单易用，结合使用文档，可以快速体验编译级别的代码加固效果。 OLLVM 是瑞士西北应用科技大学安全实验室于2010年6月份发起的一个项目，该项目旨在提供一套开源的针对 LLVM 的代码混淆工具，以增加对逆向工程的难度。目前，OLLVM已经支持LLVM8.0版本。 安装 在这里下载最新release版的pkg文件双击安装 安装完成后，重启Xcode就可以在Xcode-&gt; Toolchains -&gt; Hikari 中看到已经有了编译器选项。 使用然后在 Build Settings -&gt; Other C Flags 中加入混淆标记 -mllvm -enable-bcfobf 启用伪控制流 -mllvm -enable-cffobf 启用控制流平坦化-mllvm -enable-splitobf 启用基本块分割 -mllvm -enable-subobf 启用指令替换 -mllvm -enable-acdobf 启用反class-dump -mllvm -enable-indibran 启用基于寄存器的相对跳转，配合其他加固可以彻底破坏IDA/Hopper的伪代码(俗称F5) -mllvm -enable-strcry 启用字符串加密 -mllvm -enable-funcwra 启用函数封装-mllvm -enable-allobf 依次性启用上述所有标记 修改Xcode 相关配置，得到混淆效果。 选择Xcode -&gt; Toolchains -&gt; Hikari 将混淆工具和项目关联 将所有与要运行的 target 相关的 target（包括pod进来的库），在BuildSetting中修改Enable Index-While-Building 的值改为 NO。 修该BuildSetting 中的Optimization Level 的值为 None[-O0] 重新编译项目即可。 可能遇到的问题 编译过程中报错，内容如下： Undefined symbols for architecture arm64: &quot;___isOSVersionAtLeast&quot;, referenced from: -[MyLayoutPos posNumVal] in MyLayoutPos.o -[MyLayoutViewSizeClass myLayoutTopPadding] in MyLayoutSizeClass.o -[MyLayoutViewSizeClass myLayoutBottomPadding] in MyLayoutSizeClass.o -[MyLayoutViewSizeClass myLayoutLeadingPadding] in MyLayoutSizeClass.o -[MyLayoutViewSizeClass myLayoutTrailingPadding] in MyLayoutSizeClass.o _HikariFunctionWrapper.7182 in MyLayoutSizeClass.o _HikariFunctionWrapper.7188 in MyLayoutSizeClass.o ...ld: symbol(s) not found for architecture arm64clang-7: error: linker command failed with exit code 1 (use -v to see invocation) &quot;___isOSVersionAtLeast&quot;符号在arm64架构下找不到，根据以往的经验，出现这种错误的时候一般都是没有导入相关动态库(.Framework)，或静态库(.a)等造成的。庆幸的是已经有人在GitHub上提交了issues并给出了解决方案： 作者的回答：You probably need to explicitly link to clang-rt, available in your LLVM Toolchain directorySorry I mean clang-rt, at Hikari.xctoolchain/usr/lib/clang/10.0.0/lib/darwin/libclang_rt.ios.a (or macOS suffix) 意思是说：可能是缺少某个编译器库造成的，需要手动将这个库添加到Xcode的Linked Frameworks andLibraries动态链接库目录中。并说明了此库所在的目录Hikari.xctoolchain/usr/lib/clang/10.0.0/lib/darwin/libclang_rt.ios.a，意思是在Hikari编译器的子目录中找到文件libclang_rt.ios.a，并将他引入到Xcode项目中即可。查找路径顺序如下： 打开Show in Finder 定位到Hikari的安装目录，然后按照此路径usr/lib/clang/10.0.0/lib/darwin/libclang_rt.ios.a找到libclang_rt.ios.a文件，添加到Xcode的链接库中即可。 使用Hikari编译后，Archive 打包后，需要上传App Store 时可能会出现 “App Store” 按钮消失的问题，Archives页面右下角会出现一个提示字符： “App Store distribution requires an Xcode Default Toolchain” 意思是：App Store 发布版需要使用Xcode 默认的Toolchain (编译工具) 如下图所示： 出现这个问题是因为，我们使用了Hikari编译器 Archive的包，所以需要想办法去除这个警告即可。在Hikari的wiki文档中，我们发现作者在AppStore Guideline 安装指南中已经说明了解决方案： Alternatively, you could use Hikari’s toolchain to build normally then remove DefaultToolchainOverrideInfo from the IPA’s Info.plist 只需要在Arichive 包中的Info.plist 中找到这个值”DefaultToolchainOverrideInfo” 删除即可。可以看出此字段正是标记是否使用默认Toolchain的关键。 操作步骤为下面图示顺序，注意：记得删除字段后，一定要重启Xcode才能生效的。 删除上面红色框所示的字段即可，完了后要重启Xcode才会生效。 总结这是iOS代码混淆系列文章的最后一篇，着重讲解了iOS编译原理相关知识，编译前端Clang和编译后端LLVM在整个编译期间各自所做的工作。后面重点讲述了如何使用开源工具Hikari 进行编译混淆、加固，在实践过程中，对遇到的坑也讲了解决方案。 希望看了这几篇文章的小伙伴，能对iOS代码混淆有个初步的学习和了解，最好能结合自身条件加以实践，想必会理解的更深刻。]]></content>
      <tags>
        <tag>iOS</tag>
        <tag>代码混淆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS代码混淆之资源替换(二)]]></title>
    <url>%2F2019%2F03%2F05%2FiOS%E4%BB%A3%E7%A0%81%E6%B7%B7%E6%B7%86%E4%B9%8B%E8%B5%84%E6%BA%90%E6%9B%BF%E6%8D%A2(%E4%BA%8C)%2F</url>
    <content type="text"><![CDATA[这是iOS代码混淆系列文章的第二篇，其他两篇可以点击下方链接查看 iOS代码混淆之方法名替换 iOS代码混淆之编译优化 为什么要替换项目资源在某些公司项目开发当中 ，有时候需要通过技术手段，多次上架同一款产品。这些功能类似，且界面不同的产品也称作马甲包。为了达到将同一个包，经过较少的改动，快速更改为另一个类似的产品时，在代码混淆的基础之上还需要修改项目名称、静态资源等来达到目的。 需替换的资源及注意事项 工程内部：工程名称、类名前缀、BundleId、icon、启动图、静态资源等 产品界面：整体UI布局配色、产品功能逻辑、Tabbar顺序等 打包机器：更换打包电脑、使用WIFI网络、使用Application Uploader 上传不同二进制包 工具介绍及实践KLGenerateSpamCode是在GitHub上开源的一个可快速修改项目名称、文件前缀、生成垃圾代码等功能的集成工具，可方便的实现上述部分资源替换的功能。具体功能如下： 修改工程名 修改类名前缀 扫描工程中的代码，生成同等数量的 Category 文件，文件中及是同等方法数量的垃圾代码。 修改 xxx.xcassets 文件夹中的 png 资源文件名。 删除代码中的所有注释和空行。 由于在使用此工具之前，需要先配置修改参数，通过这些参数程序可以自动的修改项目中所需的内容，下面是从使用的角度对各项参数的解释： # 1. 项目名地址，注意：不是项目文件夹地址，是项目名那个目录/Users/jerry/Desktop/testProject0/century# 2. 修改项目名称，注意：放到最后修改,因为其他的修改需要依赖这个目录来查找-modifyProjectName century&gt;actualbyte# 3. 忽略文件夹，对添加的文件夹内的文件不执行修改。注意：多个文件夹之间用逗号隔开-ignoreDirNames ThirdPartLib,Tools,Category,Utils,MacrosDefine,Main,Resource,Support Files# 4. 修改类名前缀。没有前缀的会加上前缀，有前缀的会修改。注意：修改后是否重名-modifyClassNamePrefix /Users/jerry/Desktop/testProject0/century.xcodeproj CG&gt;WB# 5. 生成垃圾代码，注意：生成后的垃圾代码，需要拖入到工程目录中，如有报错可以自己修改或删除-spamCodeOut /Users/jerry/Desktop/testProject0/SpamCode WBLog# 6. 修改 xxx.xcassets 文件夹中的 png 资源文件名，必须指定(#1)的地址为xcassets所在的目录，才能生效。注意：此修改不会影响代码中图片的引用名称，只是对资源实体名和json配置文件中的修改。-handleXcassets# 7. 删除空行和注释 ，在项目根目录下运行，无效果可以单独运行一次。-deleteComments 上述的参数需要在下载的KLGenerateSpamCode工具目录中配置，如下图： ​ 参数配置好之后，Run 运行项目即可实现修改。另外，如果包含pod，需要到原项目文件夹下中执行pod update更新。 静态资源的修改静态资源包括项目的icon、启动图、和.xcassets 文件中的图标资源。其中为了更改UI页面元素，icon和启动图需要重新做，并替换进去，而xcassets 资源图片，可以通过修改其hash值达到修改资源的目的，具体可以使用MAC 下的一个终端工具实现。 ImageMagick：是一款创建、编辑、合成，转换图像的命令行工具，可对 png 图片做轻量压缩，既不损失图片质量，又可改变图片文件 hash 值，正是我们想要的工具。 如果电脑中没有安装的话，需要使用Homebrew来安装执行命令如下： brew install imagemagick 安装完成后，就可以执行ImageMagick的命令，来压缩工程目录下所有 png 文件： find . -iname "*.png" -exec echo &#123;&#125; \; -exec convert &#123;&#125; &#123;&#125; \; 总结本篇介绍了，如何通过修改工程名称、类前缀、资源hash值等方式，达到修改二进制包的目的，为上架苹果App Store 做准备。有兴趣的小伙伴可以亲自尝试一下，想必可以给您带来一些帮助。]]></content>
      <tags>
        <tag>iOS</tag>
        <tag>代码混淆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS代码混淆之方法名替换(一)]]></title>
    <url>%2F2019%2F03%2F02%2FiOS%E4%BB%A3%E7%A0%81%E6%B7%B7%E6%B7%86%E4%B9%8B%E6%96%B9%E6%B3%95%E5%90%8D%E6%9B%BF%E6%8D%A2(%E4%B8%80)%2F</url>
    <content type="text"><![CDATA[这是iOS代码混淆系列文章的第一篇，后两篇可以点击下方链接查看 iOS代码混淆之资源替换 iOS代码混淆之编译优化 前言在iOS开发中，某些项目为了保护代码安全，不被黑客攻破，通常需要在上架之前对源代码进行加密混淆，下面就介绍一种简单可行的Objective-C代码混淆方案。 混淆思路由于现在的逆向技术越来越高超，各种破解方案层出不穷，其中就可以使用class-dump命令行工具轻易的dump出demo.app文件中的所有头文件，代码立马回暴露在黑客面前，对项目产生了很多不利因素。因此将代码关键方法进行混淆保护迫在眉睫。 现有的一种混淆方案就是通过对指定class name 方法名进行MD5加密（显示乱码），然后通过脚本代码将加密的方法名生成到指定的头文件中，然后再使用宏替换的方式将混淆过的方法名在代码预编译阶段进行替换，使方法名即便在class-dump后也只会显示加密后的乱码显示，造成代码不易读，从而实现一定程度上的混淆保护。 混淆方式通过宏定义（#define）的方法名映射，进行字符串替换。这样做的好处在于可以将映射类别规整到一个头文件中，并#import 进项目的prefixHeader.h 预编译头文件中，方便在项目编译时进行全局替换。当不需要混淆的时候，则不导入该头文件即可。 混淆脚本下面的shell脚本引自的是“念茜-安全攻防”系列文章，实现思路是将敏感的方法名集中写入func.plist文件中，并逐一#define成随机字符串，最后写入一个.h头文件中。脚本代码如下： #!/usr/bin/env bashTABLENAME=symbolsSYMBOL_DB_FILE="symbols"STRING_SYMBOL_FILE="func.list"HEAD_FILE="$PROJECT_DIR/$PROJECT_NAME/codeObfuscation.h"export LC_CTYPE=C#维护数据库方便日后作排重createTable()&#123; echo "create table $TABLENAME(src text, des text);" | sqlite3 $SYMBOL_DB_FILE&#125;insertValue()&#123; echo "insert into $TABLENAME values('$1' ,'$2');" | sqlite3 $SYMBOL_DB_FILE&#125;query()&#123; echo "select * from $TABLENAME where src='$1';" | sqlite3 $SYMBOL_DB_FILE&#125;ramdomString()&#123; openssl rand -base64 64 | tr -cd 'a-zA-Z' |head -c 16&#125;rm -f $SYMBOL_DB_FILErm -f $HEAD_FILEcreateTabletouch $HEAD_FILEecho '#ifndef Demo_codeObfuscation_h#define Demo_codeObfuscation_h' &gt;&gt; $HEAD_FILEecho "//confuse string at `date`" &gt;&gt; $HEAD_FILEcat "$STRING_SYMBOL_FILE" | while read -ra line; do if [[ ! -z "$line" ]]; then ramdom=`ramdomString` echo $line $ramdom insertValue $line $ramdom echo "#define $line $ramdom" &gt;&gt; $HEAD_FILE fidoneecho "#endif" &gt;&gt; $HEAD_FILEsqlite3 $SYMBOL_DB_FILE .dump 配置步骤 创建混淆脚本文件confuse.sh，拷贝上述脚本代码到文件中保存，然后把该脚本文件放到项目根目录。例如：yourProject_path/目录下。 创建配置方法名称的列表文件，名为：func.list，此文件用于将需要混淆的方法名称写入进去，当项目编译时Build，会执行脚本遍历此文件中的方法名执行混淆操作，填写示例： -(void)sample; // 无参数方法-(void)seg1:(NSString *)string seg2:(NSUInteger)num; // 有参数方法// func.list 文件中这样写即可sampleseg1seg2 然后将创建好的func.list文件同样拷贝到项目根目录，也可以将confuse.sh 和func.list文件都添加进项目目录中，方便日后查看与维护，Xcode 左上角点击File --&gt; Add Files to &quot;xxx&quot;添加即可。 配置Build Phases脚本 // 脚本代码$PROJECT_DIR/confuse.sh 操作步骤如下图： 在PrefixHeader.h头文件中添加如下代码，意思是只有在Release模式下，才导入混淆头文件 // 混淆定义宏头文件，当在debug模式下，会执行脚本生成替换字符串，在release模式下导入宏文件执行替换#if (DEBUG != 1)#import "codeObfuscation.h"#endif 执行编译，可观察编译日志，查看custom shell 是否正确执行，如下图： 如果编译成功，会在项目根目录生成一个头文件codeObfuscation.h，此文件中正是包含了宏替换的关键内容，将此文件添加到项目中，会在release模式下进行替换。 可能会遇到的问题 第一次编译成功之前，即脚本代码执行之前是不会有codeObfuscation.h文件的，所以可能在PrefixHeader.h 文件中报错：Error_找不到该文件。解决方法：暂时注释掉即可。 在执行脚本时，编译日志处出现如下报错： 上图表示在执行脚本代码时，未能找到func.list 文件或其他文件，这时需要查看脚本代码中该文件的配置路径是否正确。解决方法：在confuse.sh文件中排查各项配置路径，并改正。 在执行脚本时，如遇到如下报错： confuse.sh: Permission denied 说明confuse.sh脚本文件没有可执行权限，需要在终端iTerm2 中给confuse.sh文件添加执行权限，如下操作即可： chmod a+x confuse.sh 使用class-dump 来测试class-dump是一个命令行工具，它利用Objective-C语言的runtime的特性，将存储在mach-O文件中的@interface和@protocol信息提取出来，并生成对应的.h文件。 它将xx.app格式的iOS项目文件进行分析，并通过命令生成该app源代码中的所有头文件列表，其中就包含了方法名称，可以清晰的查看dump出来的方法名是否已经被混淆。 安装 class-dump首先需要去这里：http://stevenygard.com/projects/class-dump/，下载class-dump-3.5.dmg压缩包，解压后将文件夹中的class-dump可执行文件拷贝到/usr/local/bin目录下。 具体操作步骤： 解压class-dump文件，如下图所示： 打开终端，输入如下命令，即可打开/usr/local/bin目录文件夹，然后将class-dump文件拷贝到此目录下。 open /usr/local/bin 给class-dump文件更改权限，终端输入如下命令： sudo chmod 777 /usr/local/bin/class-dump 在终端输入class-dump 查看是否安装成功，如显示命令的介绍和版本信息，就说明已经安装成功。 class-dump使用方法dump命令如下： class-dump -H /Users/xxx/Desktop/century.app -o /Users/jerry/Desktop/centuryHeaders 其中，-H 是生成头文件的命令，-o 是指定的头文件保存目录，/Users/xxx/Desktop/century.app 则是App文件的路径。 将在centuryHeaders文件夹中看到所有dump出的头文件。如下示例： Tips：如何从打包出来的xxx.ipa 文件中提取xxx.app 文件 先将xxx.ipa 文件后缀名修改为xxx.zip ， 然后解压xxx.zip 文件，会得到一个名为Payload的文件夹，文件夹中就放置的咱们需要的xxx.app文件，导出即可。 注意： 不是所有的xxx.app 文件都可以轻易的dump出头文件列表，只有未加密的，自己开发暂未上架App store 的app可以导出，App store 上架的三方应用由于被苹果加过密（加壳），不能直接dump，需要先进行砸壳（Dumpdecrypted工具）后，才能dump出需要的头文件。 后记至此，iOS开发中的Objective-C 代码混淆方案和class-dump技术的使用，都已经讲述清楚了，希望读者能体会到其中的安全攻防思路，在之后的开发中能多注意代码的安全防范。 注意：这种替换方法名的混淆方案会让App Store 审核被拒，2.3.1 - Performance We discovered that your app contains obfuscated code…，因此，不建议在App Store 上架的项目中使用。 参考资料： https://blog.csdn.net/yiyaaixuexi/article/details/29201699 https://www.jianshu.com/p/1e3fe0a8c048]]></content>
      <tags>
        <tag>iOS</tag>
        <tag>代码混淆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS页面卡顿及性能优化]]></title>
    <url>%2F2019%2F02%2F02%2FiOS%E9%A1%B5%E9%9D%A2%E5%8D%A1%E9%A1%BF%E5%8F%8A%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[卡顿产生的原因在屏幕成像的过程中，CPU和GPU的职责及CPU：负责对象的创建和销毁、对象属性的调整、布局计算、文本的计算和排版、图片的格式转换和解码、图像的绘制（Core Graphics）。 GPU：负责变换、合成、纹理的渲染。 CPU 把计算好的数据给 GPU，GPU 来渲染，渲染后的数据放在帧缓存（缓冲区，有两块缓冲区，前帧缓存和后帧缓存，协调使用，效率高）中。然后，视频控制器从缓冲区获取渲染后的数据显示在屏幕上。 图像显示原理 引用YY大神对于图像显示原理的分析 一帧（或一页）数据就是：一个垂直同步信号（VSync ）和一个水平同步信号（HSync）的组合。先发送一个垂直同步信号（VSync ），代表即将显示一页，再发送一个水平同步信号（HSync）就显示一帧。如果当下一次VSync信号到来之前，CPU和GPU还没有计算完成，就会产生卡顿。 在 VSync 信号到来后，系统图形服务会通过 CADisplayLink 等机制通知 App，App 主线程开始在 CPU 中计算显示内容，比如视图的创建、布局计算、图片解码、文本绘制等。随后 CPU 会将计算好的内容提交到 GPU 去，由 GPU 进行变换、合成、渲染。随后 GPU 会把渲染结果提交到帧缓冲区去，等待下一次 VSync 信号到来时显示到屏幕上。由于垂直同步的机制，如果在一个 VSync 时间内，CPU 或者 GPU 没有完成内容提交，则那一帧就会被丢弃，等待下一次机会再显示，而这时显示屏会保留之前的内容不变。这就是界面卡顿的原因。 从上面的图中可以看到，CPU 和 GPU 不论哪个阻碍了显示流程，都会造成掉帧现象。所以开发时，也需要分别对 CPU 和 GPU 压力进行评估和优化。 卡顿的优化从上述结论中可以得出，造成卡顿的原因是由CPU和GPU造成的，所有优化的时候也要从这两个方面来着手。那么解决卡顿的主要思路就是尽可能减少CPU、GPU资源消耗，按照60FPS的刷新帧率，每隔16ms就会有一次VSync信号。 CPU优化 对象创建：尽量用轻量级的对象，比如用不到事件处理的地方，可以考虑使用 CALayer 取代 UIView 。尽量推迟对象创建时间，并把对象的创建分到多个任务中去。如果对象可以复用，可以将对象放入缓存池中复用，这样cpu消耗会很小。 对象调整：不要频繁地调整 UIView 的布局相关属性， 比如 frame、bounds、center、transform等属性，尽量避免调整视图层次、添加和移除视图。 布局计算：尽量在后台提前计算好布局、并且对布局进行缓存，会提高很多性能。因为对这些属性调整会非常消耗资源，需一次性调整好，不要多次、频繁的计算修改这些属性。 Autolayout：对于复杂视图Autolayout 会比直接设置 frame 消耗更多的 CPU 资源。设置frame可以用一些工具（比如常用的:left/right/top/bottom/width/height 快捷属性），或使用ComponentKit、AsyncDisplayKit 等框架。 文本处理：文本的宽高计算会占用一部分资源，可以参数UILabel内部实现，用：[NSAttributedString boundingRectWithSize:options:context:]来计算文本宽高，用[NSAttributedString drawWithRect:options:context:]来绘制文本。为了不占用主线程资源，尽量放到后台处理。 图片处理：图片在创建为UIImage时不会立即解码，在设置到UIImageView中，CALayer被提交到GPU中时才会去解码并且会发生在主线程。为了绕开这个机制，会在后台先把图片绘制到CGBitmapContext 中，然后从 Bitmap 直接创建图片。目前常见的网络图片库都自带这个功能。图片的绘制过程也可以放到子线程进行，比如常见的[UIView drawRect:]，原理如下： - (void)display &#123; dispatch_async(backgroundQueue, ^&#123; CGContextRef ctx = CGBitmapContextCreate(...); // draw in context... CGImageRef img = CGBitmapContextCreateImage(ctx); CFRelease(ctx); dispatch_async(mainQueue, ^&#123; layer.contents = img; &#125;); &#125;);&#125; 图片的 size 最好刚好跟 UIImageView 的 size 保持一致。 控制子线程的最大并发数量。 GPU优化 纹理渲染：GPU 能处理的最大纹理尺寸是 4096x4096，一旦超过这个尺寸，就会占用 CPU 资源进行预处理，这对CPU和GPU都会带来额外的资源消耗。 所以纹理尽量不要超过这个尺寸。 视图混合：GPU会将多个视图混合在一起，如果视图结构复杂会消耗过多GPU资源。所以，应该尽量减少视图数量和层次，尽量避免短时间内大量图片的显示，尽可能将多张图片合成一张进行显示。并在不透明的视图里标明 opaque 属性以避免无用的 Alpha 通道合成。 图形生成：设置CALayer 的border、圆角、阴影、遮罩（mask）通常都会触发离屏渲染，而离屏渲染通常是发生在GPU中。在开发中尽量减少这个属性的使用，可以尝试开启CALayer.shouldRasterize的属性，会把原本离屏渲染操作转嫁到CPU上。对应只需要圆角的某些场合，可以用一张已经绘制好的圆角图片覆盖到原本视图上面来模拟相同的视觉效果。也可以把需要显示的图形在后台线程绘制为图片。 卡顿检测 主线程卡顿监控。通过子线程监测主线程的 runLoop，判断两个状态区域之间的耗时是否达到一定阈值。具体原理和实现，这篇文章介绍得比较详细。 FPS监控。要保持流畅的UI交互，App 刷新率应该当努力保持在 60fps。监控实现原理比较简单，通过记录两次刷新时间间隔，就可以计算出当前的 FPS。 做性能优化的时候，不要过早的优化。根据业务需求，对流畅度要求高的地方优先进行优化，走修改代码- &gt; Profile（测量）-&gt; 修改代码的流程来逐步优化。 参考资料 iOS 保持界面流畅的技巧 iOS性能优化_讲的比较全面 微信读书 iOS 性能优化总结]]></content>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS数据埋点方案]]></title>
    <url>%2F2019%2F01%2F30%2FiOS%E6%95%B0%E6%8D%AE%E5%9F%8B%E7%82%B9%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[代码埋点代码埋点是一种常规且直观的方案，需要开发人员在需要埋点的页面或点击事件的响应方法中注入埋点统计相关方法进行数据统计上报。也可以接入三方统计分析SDK来实现，比如友盟UMCAnalytics统计分析库。实现方式如下代码所示： // 通过在HomeViewController 中的“页面已显示”和“页面已消失”两个回调中注入统计代码实现埋点@implementation HomeViewController//...other methods- (void)viewDidAppear:(BOOL)animated&#123; [super viewWillAppear:animated]; [WUserStatistics sendEventToServer:@"PAGE_EVENT_HOME_ENTER"];&#125; - (void)viewDidDisappear:(BOOL)animated&#123; [super viewDidDisappear:animated]; [WUserStatistics sendEventToServer:@"PAGE_EVENT_HOME_LEAVE"];&#125;@end 这种埋点方式虽然实现起来简单，但是有很多缺点造成无法在实际项目中使用，如果需要埋点的页面很多，会增大工作量，代码侵入性太强，且不易于后期维护。 无埋点(无痕埋点)通过Runtime的Method Swizzling 特性使用 AOP面向切面编程的思想 hook住系统关键方法，注入埋点代理实现统计上报功能。这种方式对项目没有侵入性，可以对某个控件进行全局埋点，使用更灵活。 比如我们要对某个页面的打开次数做统计，那么可以对UIViewController添加分类UIViewController+userStastistics来对控制器的viewWillAppear:方法进行hook，注入次数统计代码，代码示例如下： // UIViewController 的分类@implementation UIViewController (userStastistics)+ (void)load &#123; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; SEL originalSelector = @selector(viewWillAppear:); SEL swizzledSelector = @selector(swiz_viewWillAppear:); // 使用hook工具(内部使用Method swizzing技术实现)交换两个方法的实现(IMP) [HookUtility swizzlingInClass:[self class] originalSelector:originalSelector swizzledSelector:swizzledSelector]; &#125;);&#125;#pragma mark - Method Swizzling- (void)swiz_viewWillAppear:(BOOL)animated&#123; // 注意：此行代码的调用实质上执行的是viewWillAppear: 的原生实现 [self swiz_viewWillAppear:animated]; // 添加埋点统计代码，用于记录页面打开次数 Add your custom Analytics code.&#125;@end 上述代码就可以实现无侵入性的数据埋点，但是这种方法会对所有UIViewController及其子类的viewWillAppear:方法进行hook代码注入，也就是说所有页面都会被统计进去，为了实现部分页面的统计，可以进行过滤，或使用白名单。 事件唯一ID的确定在对事件进行上报的时候，需要对事件进行标记，我们可以创建一个plist配置表对每个事件定义一个唯一标识符、事件id、相关参数等信息，然后在埋点响应方法中通过获取事件发生的类名或方法名来确定事件，并上传到统计服务器。 AOP编程Aspect Oriented Programming （AOP）是面向切面编程，利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。实现方式如下图所示： AOP的主要功能是：日志记录、性能统计、安全控制、事务处理、异常处理等。 主要的意图是：将日志记录，性能统计，安全控制，事务处理，异常处理等代码从业务逻辑代码中划分出来，通过对这些行为的分离，我们希望可以将它们独立到非指导业务逻辑的方法中，进而改 变这些行为的时候不影响业务逻辑的代码。 可以通过预编译方式和运行期动态代理实现在不修改源代码的情况下给程序动态统一添加功能的一种技术。AOP是横向切入系统，提取各个模块可能都要重复操作的部分（如：权限检查，日志记录等等），是OOP的一个有效补充。 在iOS开发中，Aspects三方库就是基于AOP的思想来实现的，内部使用了ObjC动态特性Method swizzling Hook住原生方法注入block中的自定义代码。通过使用这个库，可以简单高效的实现无埋点数据统计。 无埋点采集下面我们将介绍几种常用的UI控件的事件采集方式，分别可以这样实现： UIViewController主要是收集页面的生命周期，采用hook UIViewController的viewWillAppear：方法，将埋点代码插入到被替换的xxx_viewWillAppear:方法中，实现采集。 [HookUtility swizzlingInClass:[self class] originalSelector:@selector(viewWillAppear:)swizzledSelector:@selector(xxx_viewWillAppear:)]; UIControl针对UIControl，HubbleData采用的是hook UIControl的sendAction:to:forEvent:方法。由官方文档可知，在UIControl执行对应的action时都会首先调用sendAction:to:forEvent:方法，HubbleData的实现如下： [DASwizzler swizzleSendActionSelector:@selector(sendAction:to:forEvent:) onClass:[UIControl class] withBlock:executeBlock]; 考虑到UIControl的子类较多，所以HubbleData选取了其中使用较多的几种进行了特殊的分析：主要是UITextField、UIButton和UISwitch，其余的暂时未做特殊分析。具体的埋点的采集设计为：无论是哪种UIControl，EventID均采用的是第三部分介绍的唯一标识字符串的SHA256编码值，但是相关采集properties有所差别。 UITextFieldUITextField是UIControl的一个子类，由于UITextField涉及到用户的隐私比较多，比如用户名、密码、聊天文本等，所以HubbleData不会对此类的UITextField进行埋点的采集。 HubbleData主要采集的是UISearchBar中的UITextField，即UISearchBarTextField，并获取搜索的文本内容，这对于一些电商类的App来说，能够较好的分析用户感兴趣的商品等，这是作为HubbleData SDK无埋点的一个需求。 hook住sendAction:to:forEvent:后，如果对UISearchBarTextField的所有actions都进行hook的话，那么_searchFieldBeginEditing、_searchFieldEndEditing等所有的action发生的时候都会进行数据的采集，会采集到很多无用的信息，导致采集的数据混乱。HubbleData SDK只有当_searchFieldEndEditing action发生时才会进行埋点，收集的properties为： (1) type 为UIControl采集的事件类型，这里设置为searchBarEvent；(2) page 为当前页面的名称，用于前端显示用；(3) searchText 为_searchFieldEndEditing发生时采集到搜索框的搜索文字（此字段不为空）； 这样就能对搜索框进行无埋点采集，并能收集搜索的文本内容。此方法只是在_searchFieldEndEditing发生时采集数据，有可能该action执行时并未尽兴真正的搜索操作，可能会与业务数据库的数据有出入，但是也能够较为准确的分析用户感兴趣的搜索内容。 UIButtonUIButton是最常见的一种UIControl，由于UIButton在使用过程中会有多种状态，所有在记录的时候需要上报更详细的参数，可以添加titleColor、imageName、frame等属性来做具体区分。 UISwitch类似于UIButton，只不过这里要采集switchState，即当前的开关状态，具体的采集属性为： (1) type 为UIControl采集的事件类型，这里设置为switchEvent；(2) page 为当前页面的名称，用于前端显示用；(3) switchState 为switch的开关状态； UITableView和UICollectionView针对UITableView和UICollectionView，HubbleData采用的是先hook UITableView和UICoolectionView的setDelegate:方法，然后找到对应的delegate，然后再hook delegate类中的tableView:didSelectRowAtIndexPath:方法和UICollectionView的collectionView:didSelectItemAtIndexPath:方法。这里以UITableView为例： //先hook setDelegate:方法[DASwizzler swizzleSelector:@selector(setDelegate:) onClass:[UITableView class] withBlock:executeSetDelegateBlock];//再hook delegate的tableView:didSelectRowAtIndexPath:方法void (^executeSetDelegateBlock)(id, SEL, id) = ^(id view, SEL command, id&lt;UITableViewDelegate&gt; delegate) &#123; if ([delegate respondsToSelector:@selector(tableView:didSelectRowAtIndexPath:)]) &#123; [DASwizzler swizzleSelector:@selector(tableView:didSelectRowAtIndexPath:) onClass:[delegate class] withBlock:executeBlock]; &#125; &#125;;// "executeBlock" block 中插入埋点代码 EventID按照上述介绍的方法获取，只不过这里要注意的是，获取的并不是UITableView的唯一标识字符串而是对应的点击的cell的唯一标识字符串。采集的properties为： (1) type 为UITableView采集的事件类型，这里设置为tableViewSelectEvent；(2) page 为当前页面的名称，用于前端显示用；(3) section 为点击的cell所在的section；(4) row 为点击的cell所在的row； UIGestureRecognizer在iOS开发中，经常会使用一些手势来处理一些点击的操作，所以也有必要对UIGestureRecognizer进行hook。HubbleData 并不是直接针对UIGestureRecognizer这个类进行hook，而是hook UIView类的addGestureRecognizer:方法，实现如下： // hook addGestureRecognizer： 方法[DASwizzler swizzleSelector:@selector(addGestureRecognizer:) onClass:[UIView class] withBlock:executeBlock];// 执行block 判断手势类型，并插入响应埋点代码void (^executeBlock)(id, SEL, id) = ^(id target, SEL command, id arg) &#123; if ([arg isKindOfClass:[UITapGestureRecognizer class]] || [arg isKindOfClass:[UILongPressGestureRecognizer class]]) &#123; [arg addTarget:self action:@selector(da_autoEventAction:)]; //在本类下添加一个action的实现 ........... &#125;&#125;; 通过hook addGestureRecognizer:方法，可以得到该UIView所添加的UIGestureRecognizer，这里只对UITapGestureRecognizer和UILongPressGestureRecognizer进行处理，其他的手势暂未做处理。得到相应的UIGestureRecognizer，添加一个action，当该手势执行的时候，同样会执行该action，在action中执行埋点的操作。 这里获取的是UIGestureRecognizer所在的UIView的唯一标识标识字符串编码作为EventID,采集的属性为： (1) type 为UIGestureRecognizer采集的事件类型，这里设置为gestureTapEvent；(2) page 为当前页面的名称，用于前端显示用； 参考资料 iOS数据埋点统计方案–陈满 iOS动态性可复用而且高度解耦的用户统计埋点实现 网易HubbleData无埋点SDK在iOS端的设计与实现]]></content>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[App常见崩溃分析]]></title>
    <url>%2F2019%2F01%2F16%2FApp%E5%B8%B8%E8%A7%81%E5%B4%A9%E6%BA%83%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[前言在iOS开发调试过程中，我们会遇到很多崩溃问题，比如数组越界、容器中插入nil、或调用不存在的方法时都会出现崩溃现象。那么，为了能更好的应对并避免这些常见崩溃问题的发生，就是我们亟待需要解决的问题。下面我们将分析iOS开发中常见的几个崩溃，并结合示例给出这类问题的解决方案。 NSInvalidArgumentException从字面上来看，是无效的参数异常，但是触发这个异常的场景还有很多，最常见的就是在NSArray，NSDictionary容器中插入nil时发生，例如下面代码所示： // 示例代码NSString *password = nil;NSDictionary *dict = @&#123; @"userName": @"bruce", @"password": password &#125;;NSLog(@"dict is : %@", dict);// 崩溃日志***Terminating app due to uncaught exception 'NSInvalidArgumentException',reason:'*** -[NSPlaceholderDictionary initWithObjects:forKeys:count]: attemp to insert nil object from objects[1]' 这种崩溃原因，从控制台输出的异常信息就可以直观的看出来，是给NSDictionary 插入了nil对象造成的崩溃。在日常开发中，如果对方法入参没有做判空处理，或是后台返回的json数据中包含nil时就会造成此异常。那么如何防止这种崩溃的发生呢？ 解决方案一对指定的方法入参进行判空处理，对后台返回的数据转model的时候，增加null空值判断，或是封装为NSNull对象进行存储。 解决方案二代码改动量少，无侵入性的方案，就是利用Runtime 动态特性，swizzle Method 方式hook住NSArray、NSDictionary 等方法的插入对象时的系统原生方法，然后注入对空对象nil 的检查并封装为NSNull 的ObjC对象，这样就可以避免程序的直接崩溃。实例代码如下： // 下列方法为Method swizzling 交换后的方法实现+ (instancetype)gl_dictionaryWithObjects:(const id [])objects forKeys:(const id&lt;NSCopying&gt; [])keys count:(NSUInteger)cnt &#123; id safeObjects[cnt]; id safeKeys[cnt]; NSUInteger j = 0; for (NSUInteger i = 0; i &lt; cnt; i++) &#123; id key = keys[i]; id obj = objects[i]; if (!key) &#123; continue; &#125; if (!obj) &#123; obj = [NSNull null]; &#125; safeKeys[j] = key; safeObjects[j] = obj; j++; &#125; return [self gl_dictionaryWithObjects:safeObjects forKeys:safeKeys count:j];&#125; unrecognized selector sent to instance xxx 异常这种异常很常见，意思是给一个对象发送了一个自己没有的消息，也就是说调用了一个不属于自己的方法。由于Objc有一个消息转发机制，当在该对象的类方法列表中找不到，所调用的方法时，_objc_msgForward就会触发消息转发，如果在转发过程中任然没有得到方法的实现，那么就会抛出unrecognized selector 异常，可参考这篇文章了解消息转发。 NSRangeException当代码中试图去访问对象的范围内不存在的索引的时候，根据堆栈信息可以追溯到这个异常，比如： [__NSArrayM objectAtIndex:]: index 11 beyond bounds [0 .. 10] 大多数情况下引起这个问题的原因是数组和字符串，比如： NSArray *arr = @[@1, @2, @3, @4];NSNumber *num = [arr objectAtIndex:9]; // 抛出异常NSString *mainString = @”myString”;NSString *subString = [mainString substringToIndex:24]; // 抛出异常 避免这种异常很简单，及时确保索引在对象的范围内，比如： NSNumber *obj = nil; NSArray *arr = @[@1, @2, @3, @4];if([arr count] &gt; 9) &#123; obj = [arr objectAtIndex:9];&#125;NSString *subString = nil; NSString *mainString = @”myString”;if([mainString length] &gt; 24) &#123; subString = [mainString substringToIndex:24];&#125; EXC_BAD_ACCESS在访问一个已经释放的对象或向它发送消息时，EXC_BAD_ACCESS就会出现。造成EXC_BAD_ACCESS最常见的原因是，在初始化方法中初始化变量时用错了所有权修饰符，这会导致对象过早地被释放。举个例子，在viewDidLoad方法中为UIViewController创建了一个包含元素的NSArray，却将该数组的所有权修饰符设成了assign而不是strong。现在在viewWillAppear中，若要访问已经释放掉的对象时，就会得到名为EXC_BAD_ACCESS的崩溃。 这个崩溃发生时，查看崩溃日志，却往往得不到有用的栈信息。还好，有一个方法用来解决这个问题：NSZombieEnabled。 这是一个环境变量，用来调试与内存相关的问题，跟踪对象的释放过程。启用了NSZombieEnabled的话，它会用一个僵尸实现来去你的默认的dealloc实现，也就是在引用计数降到0时，该僵尸实现会将该对象转换成僵尸对象。僵尸对象的作用是在你向它发送消息时，它会显示一段日志并自动跳入调试器。 所以，当在应用中启用NSZombie而不是让应用直接崩溃时，一个错误的内存访问就会变成一条无法识别的消息发送给僵尸对象。僵尸对象会显示接收到的消息，然后跳入调试器，这样你就可以查看到底哪时出了问题。 可以在Xcode的scheme页面中设置NSZombieEnabled环境变量。点击Product—&gt;Edit Scheme打开该页面，然后勾选Enable Zombie Objects复选框，如图所示： 僵尸在ARC出现以前作用很大。但自从有了ARC，如果你在对象的所有权方面比较注意，那么通常不会碰到内存相关的崩溃。 SIGSEGV 异常段错误信息（SIGSEGV）是操作系统产生的一个更严重的问题。当硬件出现错误、访问不可读的内存地址或向受保护的内存地址写入数据时，就会发生这个错误。 硬件错误这一情况并不常见。当要读取保存在RAM中的数据，而该位置的RAM硬件有问题时，你会收到SIGSEGV。SIGSEGV更多是出现在后两种情况。默认情况下，代码页不允许进行写操作，而数据而不允许进行执行操作。当应用中的某个指针指向代码页并试图修改指向位置的值时，你会收到SIGSEGV。当要读取一个指针的值，而它被初始化成指向无效内存地址的垃圾值时，你也会收到SIGSEGV。 SIGSEGV错误调试起来更困难，而导致SIGSEGV的最常见原因是不正确的类型转换。要避免过度使用指针或尝试手动修改指针来读取私有数据结构。如果你那样做了，而在修改指针时没有注意内存对齐和填充问题，就会收到SIGSEGV。 举个常见的例子，在使用代理的时候： // 代理应该是用weak修饰的self.delegate = myView;// myView从UINavigationController中Pop之后就会被销毁，而self.delegate仍然起作用，成了野指针// 将会抛出异常[self.delegate doSomething]; 避免这种异常可以在调用之前检查一下代理是否为空，是否能够响应所给的Selector if(self.delegate != nil) &#123; if([self.delegate respondsToSelector:@selector(doSomething)]) &#123; [self.delegate doSomething]; &#125;&#125; SIGABRTSIGABRT代表SIGNAL ABORT（中止信号）。当操作系统发现不安全的情况时，它能够对这种情况进行更多的控制；必要的话，它能要求进程进行清理工作。在调试造成此信号的底层错误时，并没有什么妙招。Cocos2d或UIKit等框架通常会在特定的前提条件没有满足或一些糟糕的情况出现时调用C函数abort（由它来发送此信号）。当SIGABRT出现时，控制台通常会输出大量的信息，说明具体哪里出错了。由于它是可控制的崩溃，所以可以在LLDB控制台上键入bt命令打印出回溯信息。 SIGBUS总线错误信号（SIGBUG）代表无效内存访问，即访问的内存是一个无效的内存地址。也就是说，那个地址指向的位置根本不是物理内存地址（它可能是某个硬件芯片的地址）。SIGSEGV和SIGBUS都羽毛球EXC_BAD_ACCESS的子类型。 SIGTRAPSIGTRAP代表陷阱信号。它并不是一个真正的崩溃信号。它会在处理器执行trap指令发送。LLDB调试器通常会处理此信号，并在指定的断点处停止运行。如果你收到了原因不明的SIGTRAP，先清除上次的输出，然后重新进行构建通常能解决这个问题。 SIGILLSIGILL代表signal illegal instruction(非法指令信号)。当在处理器上执行非法指令时，它就会发生。执行非法指令是指，将函数指针会给另外一个函数时，该函数指针由于某种原因是坏的，指向了一段已经释放的内存或是一个数据段。有时你收到的是EXC_BADINSTRUCTION而不是SIGILL，虽然它们是一回事，不过EXC*等同于此信号不依赖体系结构。 参考资料 iOS中的崩溃类型 iOS 崩溃Crash解析]]></content>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[App启动分析与优化策略]]></title>
    <url>%2F2019%2F01%2F08%2FApp%E5%90%AF%E5%8A%A8%E5%88%86%E6%9E%90%E4%B8%8E%E4%BC%98%E5%8C%96%E7%AD%96%E7%95%A5%2F</url>
    <content type="text"><![CDATA[启动过程分析 解析Info.plist 加载相关信息，例如闪屏 沙箱建立、权限检查 Mach-O加载 Mach-O 文件：我们写的程序想要跑起来，肯定它的可执行文件格式要被操作系统所理解。比如ELF是Linux下的可执行文件格式，那么对于OS X / iOS来说，Mach-O 是其可执行文件格式。 Mach-O格式主要包括以下几种文件类型： Executable：应用的主要二进制 Dylib：动态链接库 Bundle：不能被链接，只能在运行时使用dlopen加载 Image：包含Executable、Dylib和Bundle Framework：包含Dylib、资源文件和头文件的文件夹 如果是胖二进制文件，寻找合适当前CPU类别的部分 加载所有依赖的Mach-O文件（递归调用Mach-O加载的方法） 定位内部、外部指针引用，例如字符串、函数等 执行声明为__attribute__((constructor))的C函数 加载类扩展（Category）中的方法 C++静态对象加载、调用ObjC的 +load 函数 程序执行 调用main() 调用UIApplicationMain() 调用applicationWillFinishLaunching 测量App的启动时间iOS App的启动有两种方式：冷启动和热启动，下面对这两种启动方式进行简单介绍。 冷启动：App第一次启动或者是被上滑Kill掉之后，再次从点击App应用图标到App完全启动显示主页面为止的过程成为冷启动。 热启动：当用户从当前App按下HOME键退出后，系统并不会立即kill掉App的进程，还会继续后台执行一段时间(至于什么时候会被kill，完全取决于系统内存等资源的使用情况，理想情况下可以保持后台运行15min)。然后当用户再次点击App图标时，会很快加载到上次停留的页面，几乎不需要进行资源载入，这种情况下的启动成为热启动。 下面我们对于App启动时间的测量只讨论在冷启动情形下。根据苹果官方介绍，iOS应用的启动分为两个阶段:pre-main和main，所以App启动的总时间为：Total Time = pre-main Time + main Time。 Pre-main 阶段Pre-mian 阶段即main()函数被调用之前的加载时间，包括dylib动态库的加载、Mach-O文件加载、Rebase/Bining、Objective-C Runtime 加载等。该过程如下图所示： main 阶段main 阶段指的是从调用main()函数开始，调用UIApplicationMain()创建UIApplication,AppDelegate，直到回调App代理方法applicationDidBecomeActive:为止，其中包括application:didFinishLaunchingWithOptions方法中创建keyWindow、三方sdk和其他初始化项所消耗的时间，也包含RootViewController 的 ChildViewController的view完全显示出来所花费的时间。该过程如下图所示： pre-main 阶段时间测量那么对于pre-main 和 main 启动阶段的耗时如何测量呢？苹果已为我们提供了一个简单易用的测试方法：在Xcode中选中项目的Scheme→ Edit Scheme...→，然后选择Run→Arguments→Environment Variables中添加Name = DYLD_PRINT_STATISTICSvalue，Value = 1 的环境变量。如下图所示： 然后重新运行项目，注意控制台下面的打印输出，格式为： Total pre-main time: 655.68 milliseconds (100.0%) dylib loading time: 205.67 milliseconds (31.3%) rebase/binding time: 320.95 milliseconds (48.9%) ObjC setup time: 63.07 milliseconds (9.6%) initializer time: 65.85 milliseconds (10.0%) slowest intializers : libSystem.B.dylib : 3.43 milliseconds (0.5%) libMainThreadChecker.dylib : 15.59 milliseconds (2.3%) century : 76.56 milliseconds (11.6%) // 内容解读Total pre-main time: 表示pre-main阶段总的时间消耗为655.68毫秒dylib loading time: 动态库加载时间rebase/binding time: 重定位指针指向/指向镜像外部内容 所需时间ObjC setup time: ObjC初始化时间initializer time: 其他初始化时间的总和slowest intializers : 最慢的三个初始化分别是libSystem.B.dylib、libMainThreadChecker.dylib、century(项目名称) main 阶段时间测量由于main阶段涉及到大量的自定义代码，app主体页面的初始化、前期配置、三方库初始化等大量逻辑代理，iOS系统没有直接的测量方式，所以只能通过打点的方式计算启动开始到启动结束的时间差即可。例如下面示例代码： // main.m 文件#import &lt;UIKit/UIKit.h&gt;#import "AppDelegate.h"extern CFAbsoluteTime StartTime;int main(int argc, char * argv[]) &#123; // 记录开始时间 StartTime = CFAbsoluteTimeGetCurrent(); @autoreleasepool &#123; return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class])); &#125;&#125;// AppDelegate.m 文件CFAbsoluteTime StartTime;- (void)applicationDidBecomeActive:(UIApplication *)application &#123; dispatch_async(dispatch_get_main_queue(), ^&#123; NSUInteger milliseconds = (NSUInteger)((CFAbsoluteTimeGetCurrent() - StartTime) * 1000); NSLog(@"Loading done in %lu ms", milliseconds); &#125;);&#125; 影响启动性能的因素接下来我们讨论在App启动的pre-main阶段和mian阶段，影响启动性能的多种因素。 Pre-main 阶段 动态库加载越多，启动越慢。 ObjC类越多，启动越慢 C的constructor函数越多，启动越慢 C++静态对象越多，启动越慢 ObjC的+load方法使用越多，启动越慢 我们尽量不要写__attribute__((constructor))的C函数，也尽量不要用到C++的静态对象；至于ObjC的+load方法，似乎大家已经习惯不用它了。任何情况下，能用dispatch_once()来完成的，就尽量不要用到以上的方法。 main 阶段 执行main()函数的耗时 执行application:didFinishLaunchingWithOptions的耗时 rootViewController及其childViewController的加载、view及其subviews的加载 一般的App的主体UI架构是，UITabbarViewController 作为 keyWindow的根控制器，然后包含多个ChildViewController作为每个tab的根控制器。然而在didFinishLaunchingWithOptions代理方法中各控制器的初始化顺序是怎样的呢？ 答案是： -[MQQTabBarController viewDidLoad] -[MQQTab1ViewController viewDidLoad] -[AppDelegate application:didFinishLaunchingWithOptions:] -[MQQTab2ViewController viewDidLoad] （点击了第二个tab之后加载） -[MQQTab3ViewController viewDidLoad] （点击了第三个tab之后加载） 从上面的加载过程可以看出，在main()方法之后的启动中，只要是对页面的渲染，要减少这个阶段的耗时需要在viewDidLoad方法中做优化，减少不必要的逻辑，视图尽量使用懒加载，使用异步方式加载网络数据。 启动时间优化苹果建议在400ms内完成pre-main 阶段的启动，App整体的启动时间不能超过20s，否则系统会被kill掉进程。 由于每个App的体量和类型不一样，对应启动过程中配置的逻辑处理复杂程度也是皆不相同，所有没有一个标准的时间来衡量启动时间是否达到最优。但是可以从用户体验上下功夫预加载占位视图，数据缓存等都可以营造出加载速度提升的感觉。 下面从实践的角度分析可优化的部分： pre-main 阶段优化 移除不需要的动态库framework 移除不需要的类、未使用的变量、方法等 对应项目中大量的文件，可以使用工具快速扫描整个项目找出未使用的类、变量、或方法。这里推荐一个开源工具 Fui 能准确的完成此任务，不足之处在于它处理不了动态库或静态库中提供的类，和C++ 的类模板。 Fui使用方法： 在终端中cd到项目根目录，然后执行fui find，就可以得到一个列表，可根据这个列表在Xcode中手动检查并删除无用代码。 合并功能类似的类和扩展（Category） +load方法中做的事情可以使用dispatch_once()来代替，因为main()方法被调用之前就会加载+load方法，会影响pre-main阶段启动事件。 压缩资源图片（对要求不高的图片可做压缩处理） main 阶段优化 优化application: didFinishLaunchingWithOptions:内部逻辑 各种业务请求配置更新，多个配置更新可合并为单个请求，部分业务的配置延后更新。 对于新版本引导、广告闪屏逻辑，需要重构逻辑清晰 数据迁移，对太旧的无用的逻辑可以删除，不需要立即处理的数据，改为后台加载 优化rootViewController加载：在启动过程中只加载tabbarVc，主Vc即可，而且主Vc中的ViewDidLoad方法中也只加载需要立即显示出来的view，其他视图均使用懒加载，数据进行异步加载。 参考资料 iOS App 启动性能优化–腾讯Bugly iOS启动优化—凌云的博客 [优化 App 的启动时间]]]></content>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[反射的概念及应用]]></title>
    <url>%2F2018%2F12%2F23%2F%E5%8F%8D%E5%B0%84%E7%9A%84%E6%A6%82%E5%BF%B5%E5%8F%8A%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[前言反射是指程序在运行时可以访问、检测、修改它本身状态或行为的一种能力。通常动态语言如ObjC具有这种特性。下面将介绍反射的特性以及在iOS中的应用举例。 使用反射可以做什么 反射的应用场景 在运行时可以判断一个对象是否属于某个类、是否遵守某个协议、是否响应某个方法 在运行时可以构造任意一个类、生成一个对象、得到一个方法 在运行时动态调用一个方法 ObjC中的反射由于ObjC的动态特性，下面方法可以在运行时根据字符串参数反射得到类、方法selector、协议方法等 // SEL和字符串转换FOUNDATION_EXPORT NSString *NSStringFromSelector(SEL aSelector);FOUNDATION_EXPORT SEL NSSelectorFromString(NSString *aSelectorName);// Class和字符串转换FOUNDATION_EXPORT NSString *NSStringFromClass(Class aClass);FOUNDATION_EXPORT Class __nullable NSClassFromString(NSString *aClassName);// Protocol和字符串转换FOUNDATION_EXPORT NSString *NSStringFromProtocol(Protocol *proto) NS_AVAILABLE(10_5, 2_0);FOUNDATION_EXPORT Protocol * __nullable NSProtocolFromString(NSString *namestr) NS_AVAILABLE(10_5, 2_0); 通过这些方法，我们可以在运行时选择创建那个实例，并动态选择调用哪个方法。这些操作甚至可以由服务器传回来的参数来控制，我们可以将服务器传回来的类名和方法名，实例为我们的对象。 // 反射的一种应用// 假设从服务器获取JSON串，通过这个JSON串获取需要创建的类为ViewController，并且调用这个类的getDataList方法。Class class = NSClassFromString(@"ViewController");ViewController *vc = [[class alloc] init];SEL selector = NSSelectorFromString(@"getDataList");[vc performSelector:selector]; ObjC中的常用判断方法在NSObject类中为我们提供了一些基础方法，用来做一些判断操作，这些方法都是发生在运行时动态判断的。 // 当前对象是否这个类或其子类的实例- (BOOL)isKindOfClass:(Class)aClass;// 当前对象是否是这个类的实例- (BOOL)isMemberOfClass:(Class)aClass;// 当前对象是否遵守这个协议- (BOOL)conformsToProtocol:(Protocol *)aProtocol;// 当前对象是否实现这个方法- (BOOL)respondsToSelector:(SEL)aSelector; 反射的应用场景 需求：根据后台返回的参数，来动态跳转页面，并传参数 这个需求可以通过反射机制来实现，通过服务端下发的json对象动态的在运行时创建类，调用指定方法，并跳转之前页面，例如下例： // 假设和后台约定格式如下：NSDictionary *dict = @&#123; // 类名 @"className" : @"UserListViewController", // 数据参数 @"propertys" : @&#123; @"name": @"liuxiaozhuang", @"age": @3 &#125;, // 调用方法名 @"method" : @"refreshUserInformation" &#125;; 下面通过反射机制简单实现了控制器跳转的方法，在实际使用中再根据业务需求进行修改即可 // 简单封装的页面跳转方法，只是做演示，代码都是没问题的，使用时可以根据业务需求进行修改。- (void)remoteNotificationDictionary:(NSDictionary *)dict &#123; // 根据字典字段反射出我们想要的类，并初始化控制器 Class class = NSClassFromString(dict[@"className"]); UIViewController *vc = [[class alloc] init]; // 获取参数列表，使用枚举的方式，对控制器属性进行KVC赋值 NSDictionary *parameter = dict[@"propertys"]; [parameter enumerateKeysAndObjectsUsingBlock:^(id _Nonnull key, id _Nonnull obj, BOOL * _Nonnull stop) &#123; // 在属性赋值时，做容错处理，防止因为后台数据导致的异常 if ([vc respondsToSelector:NSSelectorFromString(key)]) &#123; [vc setValue:obj forKey:key]; &#125; &#125;]; [self.navigationController pushViewController:vc animated:YES]; // 从字典中获取方法名，并调用对应的方法 SEL selector = NSSelectorFromString(dict[@"method"]); [vc performSelector:selector];&#125; 参考资料 iOS反射机制]]></content>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AppDelegate如何瘦身？]]></title>
    <url>%2F2018%2F12%2F16%2FAppDelegate%E5%A6%82%E4%BD%95%E7%98%A6%E8%BA%AB%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[前言AppDelegate瘦身指的就是对AppDelegate类进行解耦和拆分。AppDelegate 作为整个应用程序的代理对象，处理应用程序的生命周期、根视图控制器初始化、应用级URL跳转、推送通知接收、网络配置、及其他第三方SDK初始化等工作。 为了让AppDelegate内部代码简洁，逻辑清晰，则需要对其进行整理拆分。下面有几种瘦身方式： 模块化管理通过一个模块化管理类，将AppDelegate中的职责拆分至各个模块中去处理，简化了AppDelegate内部代码。 FRDModuleManager就是一个模块化管理工具，通过在UIApplicationDelegate各代理方法中留下钩子，当代理回调时，会将任务分发到各自模块中。实现原理如下图所示： 优点： 简单，只需要几行代码就可以解决。 被添加的每个模块都可以“享受”AppDelegate的各个生命周期。 缺点： 每个模块都要初始化并分配内存，当FRDModuleManager里注册了大量模块时，会创建大量对象并影响App启动速度。 缺少模块初始化优先级，当有三个模块A,B,C时，正好C依赖于B，B依赖于A，如果在配置文件中配置A，B，C的顺序又是打乱时，初始化会出问题。 AppDelegate+Service 分类通过对AppDelegate 添加相应的分类来处理不同的初始化需求，在AppDelegate中调用处理方法，也可以控制调用顺序。 比如：AppDelegate+AppService 处理RootViewController的初始化，网络及三方sdk的初始化等任务，AppDelegate+RemotePush来处理远程推送相关的逻辑。 // 初始化window[self initWindow];// 初始化app服务[self initService];// 启动app[kCGAppManager appStart]; 使用分类的优势是没有侵入性，易于维护，结构清晰。缺点是无法直接对分类添加属性，降低了使用灵活性，不过也可以通过RunTime添加关联属性的方式来解决，但是一般情况下不推荐使用。 URL路由分发从App架构层面对AppDelegate进行解耦瘦身，可以使用全局路由来实现页面跳转、通知、逻辑处理等任务。通过注册url，然后调用对应的url和参数实现页面跳转。 JLRoutes是一个优秀的URL解析库，可以很方便的处理不同URL Scheme以及解析它们的参数，并通过回调block来处理URL对应的操作。 // 注册路由[routes addRoute:@"/user/view/:userID" handler:^BOOL(NSDictionary *parameters) &#123; NSString *userID = parameters[@"userID"]; // defined in the route by specifying ":userID" // present UI for viewing user with ID 'userID' return YES; // return YES to say we have handled the route &#125;];// 执行路由[JLRoutes routeURL:@"/user/view?userID=123"]; 但是由于JLRoutes的内部实现中对应查找URL使用了遍历的方式，时间效率比较低。GitHub上的另一种库MGJRouter解决了这个问题，使用了匹配查找的方式调高了库的运行效率，可参看使用。 参考资料 AppDelegate瘦身指南]]></content>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VPS下搭建ownCloud云盘]]></title>
    <url>%2F2018%2F11%2F03%2FVPS%E4%B8%8B%E6%90%AD%E5%BB%BAownCloud%E4%BA%91%E7%9B%98%2F</url>
    <content type="text"><![CDATA[前言鉴于各大网络云盘的各种限制，收费制度和用户体验并不好，利用VPS来搭建一个私有云盘就会变得越来越受欢迎，目前主流的开源软件ownCloud，NexCloud等都可以实现，下面我们就选ownCloud来搭建，vps选择的搬瓦工。 准备 一台VPS服务器，开启root权限 LAMP环境。ownCloud需要Web服务器，数据库和PHP才能正常工作。 设置LAMP（Linux，Apache，MySQL和PHP）服务器满足所有这些要求 安装ownCloud ，并配置相关参数。 设置LAMP环境“LAMP”是一组开放源代码软件，通常安装在一起以使服务器能够托管动态网站和网络应用。这个词其实是代表linux下的操作系统，Apache Web服务器的缩写。 站点数据存储在MySQL数据库（使用MariaDB），以及动态内容用PHP处理。 接下来，我们将在CentOS 7 VPS上安装一个LAMP。 CentOS将满足我们的第一个需求：一个Linux操作系统。 安装Apache 在终端输入命令安装： sudo yum install httpd 安装完成后，启动该服务 sudo systemctl start httpd.service 踩坑：如果无法启动报错，可能是没有设置防火墙对http/https的访问权限，输入下面命令开启 sudo firewall-cmd --permanent --zone=public --add-service=http sudo firewall-cmd --permanent --zone=public --add-service=httpssudo firewall-cmd --reload// 注意：如果提示 firewall 没有启动，则使用命令开启：// 注意：如果开启防火墙后，ssh 无法访问远程vps，可以在vps服务商提供的web页面中的root shell 控制台来设置上述命令。启动： systemctl start firewalld关闭： systemctl stop firewalld查看状态： systemctl status firewalld 开机禁用 ： systemctl disable firewalld开机启用 ： systemctl enable firewalld 再次使用命令来尝试开启httpd 服务。如果开启后(即没有报错信息)，下面设置开机默认启动： sudo systemctl enable httpd.service 输入http://你的服务器地址/测试是否安装成功，如果能访问就说明安装没问题，如下截图： 到这里就Apache 服务就安装完成了。 安装MySQL（MariaDB） 现在我们已经开始运行Web服务器，现在是安装MariaDB的时候了，这是一个MySQL插件替换。 启动数据库以后会提示输入数据库密码。由于我们是首次安装，直接enter即可，同时会提示你设置密码，输入你想要设置的数据库密码即可。 // 1. 安装数据库sudo yum install mariadb-server mariadb// 2. 启动数据库sudo systemctl enable mariadb.service// 3. 设置数据库，默认启动sudo systemctl enable mariadb.service 安装PHP PHP是我们的设置的组件，它将处理代码以显示动态内容。它可以运行脚本，连接到我们的MySQL数据库以获取信息，并将处理的内容传递到我们的Web服务器以显示。 注意此处CentOS 7默认PHP为5.4版本，ownCloud需要的PHP版本为5.6以上。所以此处我们安装PHP5.6版本。 执行下面命令升级php仓库 rpm -Uvh https://mirror.webtatic.com/yum/el7/epel-release.rpmrpm -Uvh https://mirror.webtatic.com/yum/el7/webtatic-release.rpm 执行安装 yum install -y php56w php56w-opcache php56w-xml php56w-mcrypt php56w-gd php56w-devel php56w-mysql php56w-intl php56w-mbstring php56w-openssl php56w-Tokenizer php56w-posix php56w-pcntl 这里要特别注意，可能会报错php56w-commen 和php5.4-commen发生文件冲突，导致安装不成功。因为centOS 7 系统默认会安装php5.4，如果直接执行安装高版本的话就会报错，通过踩坑经验最简单直接的方法就是删除掉原有的php5.4，在安装php56w或更高的版本： 删除旧版本php的方法命令： yum remove php-common 再次执行上面的安装命令，如果安装成功，执行下面命令重启httpd服务 sudo systemctl restart httpd.service 还可以通过执行命令php -v查看php的安装版本 为了测试PHP是否正确配置，可以创建一个php脚本来查看。在web根目录/var/www/html/创建一个info.php 文件，然后使用vim打开这个文件插入下面这句话保持退出： &lt;?php phpinfo(); ?&gt; 然后访问 http://你的服务器地址/info.php 如果没有问题页面会展示PHP的一些基本信息。 最后不忘删除我们的测试页面 sudo rm /var/www/html/info.php 到这里整个LAMP服务就都安装完成了。 安装ownCloudownCloud服务器软件包不存在于CentOS的默认存储库中。然而，ownCloud为发行版维护了一个专用的存储库。 首先，导入与他们释放钥匙rpm命令。 关键的授权包管理器yum信任库。 sudo rpm --import https://download.owncloud.org/download/repositories/stable/CentOS_7/repodata/repomd.xml.key 接下来，使用curl命令下载ownCloud库文件： sudo curl -L https://download.owncloud.org/download/repositories/stable/CentOS_7/ce:stable.repo -o /etc/yum.repos.d/ownCloud.repo 添加新文件后，用clean命令使yum知道所做的更改： sudo yum clean expire-cache// 如果提示类似下列命令，说明执行成功了OutputLoaded plugins: fastestmirrorCleaning repos: base ce_stable extras updates6 metadata files removed 最后，使用进行ownCloud安装yum实用程序和install命令： sudo yum install owncloud// 当提示Is this ok [y/d/N]:消息类型Y然后按ENTER键授权安装 配置数据库 mysql -u root -p// 可能会提示要输入密码，如果没有直接enter即可 为ownCloud 创建表，注意：每个MySQL的语句必须以分号;结束 CREATE DATABASE owncloud; 接下来，创建一个单独的MySQL用户帐户，与新创建的数据库进行交互。从管理和安全的角度来看，这样做不仅有利于数据安全更有利于我们日后的管理工作。与数据库的命名一样，选择您喜欢的用户名。我们选择owncloud GRANT ALL ON owncloud.* to 'owncloud'@'localhost' IDENTIFIED BY '此处填写你想要设置的密码'; 执行flush-privileges操作以确保MySQL应用权限分配 FLUSH PRIVILEGES; 数据库已经完成配置，执行命令exit退出。 配置ownCloud打开https://你的服务器地址/owncloud进入web管理页面 此时页面会提示你创建管理员账号，输入你想要的管理员账号和密码。在下方的数据库选项中选择MySQL／MariaDB，并且填入相应的账号和密码。此处填入的账号和密码即之前我们设置数据库时设置的账号和密码 点击Finish setup 完成安装。然后重新进入ownCloud web页面就可以进入到网盘。 到这里整个安装流程就都完成，可以开心的上传自己的文件啦。]]></content>
      <tags>
        <tag>ownCloud</tag>
        <tag>vps</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Method Swizzling]]></title>
    <url>%2F2018%2F10%2F21%2FMethod-Swizzling%2F</url>
    <content type="text"><![CDATA[前言Method swizzling 用于改变Foundation 框架中一个已存在的方法（selector）的实现。常用于对系统方法实现的替换，可实现插入自定义代码逻辑，代码hook等功能。 实现原理这项技术使得在运行时通过改变 selector 在类的消息分发列表中的映射从而改变方法的掉用成为可能。 例如：我们想要在一款 iOS app 中追踪每一个视图控制器被用户呈现了几次： 这可以通过在每个视图控制器的 viewDidAppear: 方法中添加追踪代码来实现，但这样会大量重复的样板代码。继承是另一种可行的方式，但是这要求所有被继承的视图控制器如 UIViewController, UITableViewController, UINavigationController 都在 viewDidAppear：实现追踪代码，这同样会造成很多重复代码。 幸运的是，这里有另外一种可行的方式：从 category 实现 method swizzling 。 实现方式#import &lt;objc/runtime.h&gt;@implementation UIViewController (Tracking)+ (void)load &#123; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; // dispatch_once() 保证代码只执行一次 Class class = [self class]; SEL originalSelector = @selector(viewWillAppear:); SEL swizzledSelector = @selector(xxx_viewWillAppear:); Method originalMethod = class_getInstanceMethod(class, originalSelector); Method swizzledMethod = class_getInstanceMethod(class, swizzledSelector); // When swizzling a class method, use the following: // Class class = object_getClass((id)self); // ... // Method originalMethod = class_getClassMethod(class, originalSelector); // Method swizzledMethod = class_getClassMethod(class, swizzledSelector); // 检查系统方法是否已经被交换 BOOL didAddMethod = class_addMethod(class, originalSelector, method_getImplementation(swizzledMethod), method_getTypeEncoding(swizzledMethod)); if (didAddMethod) &#123; class_replaceMethod(class, swizzledSelector, method_getImplementation(originalMethod), method_getTypeEncoding(originalMethod)); &#125; else &#123; method_exchangeImplementations(originalMethod, swizzledMethod); &#125; &#125;);&#125;#pragma mark - Method Swizzling// Discuss： 下面自定义方法不会造成递归调用，因为在交换了方法的实现后，xxx_viewWillAppear:方法的实现已经被替换为了 UIViewController -viewWillAppear：的原生实现，所以这里并不是在递归调用。- (void)xxx_viewWillAppear:(BOOL)animated &#123; [self xxx_viewWillAppear:animated]; NSLog(@"viewWillAppear: %@", self);&#125; 相关概念解释：+load vs +initializeswizzling 应该只在 +load 中完成。 在 Objective-C 的运行时中，每个类有两个方法都会自动调用。+load 是在一个类被初始装载时调用，+initialize 是在应用第一次调用该类的类方法或实例方法前调用的。两个方法都是可选的，并且只有在方法被实现的情况下才会被调用。 dispatch_onceswizzling 应该只在 dispatch_once 中完成。 由于 swizzling 改变了全局的状态，所以我们需要确保每个预防措施在运行时都是可用的。原子操作就是这样一个用于确保代码只会被执行一次的预防措施，就算是在不同的线程中也能确保代码只执行一次。Grand Central Dispatch 的 dispatch_once 满足了所需要的需求，并且应该被当做使用 swizzling 的初始化单例方法的标准。 Selectors, Methods, &amp; Implementations在 Objective-C 的运行时中，selectors, methods, implementations 指代了不同概念，然而我们通常会说在消息发送过程中，这三个概念是可以相互转换的。 下面是苹果 Objective-C Runtime Reference中的描述： Selector（typedef struct objc_selector *SEL）:在运行时 Selectors 用来代表一个方法的名字。Selector 是一个在运行时被注册（或映射）的C类型字符串。Selector由编译器产生并且在当类被加载进内存时由运行时自动进行名字和实现的映射。 Method（typedef struct objc_method *Method）:方法是一个不透明的用来代表一个方法的定义的类型。 Implementation（typedef id (*IMP)(id, SEL,...)）:这个数据类型指向一个方法的实现的最开始的地方。该方法为当前CPU架构使用标准的C方法调用来实现。该方法的第一个参数指向调用方法的自身（即内存中类的实例对象，若是调用类方法，该指针则是指向元类对象 metaclass ）。第二个参数是这个方法的名字 selector，该方法的真正参数紧随其后。 理解 selector, method, implementation 这三个概念之间关系的最好方式是：在运行时，类（Class）维护了一个消息分发列表来解决消息的正确发送。每一个消息列表的入口是一个方法（Method），这个方法映射了一对键值对，其中键值是这个方法的名字 selector（SEL），值是指向这个方法实现的函数指针 implementation（IMP）。 Method swizzling 修改了类的消息分发列表使得已经存在的 selector 映射了另一个实现 implementation，同时重命名了原生方法的实现为一个新的 selector。 注意事项：很多人认为交换方法实现会带来无法预料的结果。然而采取了以下预防措施后, method swizzling 会变得很可靠： 在交换方法实现后记得要调用原生方法的实现（除非你非常确定可以不用调用原生方法的实现）：APIs 提供了输入输出的规则，而在输入输出中间的方法实现就是一个看不见的黑盒。交换了方法实现并且一些回调方法不会调用原生方法的实现这可能会造成底层实现的崩溃。 避免冲突：为分类的方法加前缀，一定要确保调用了原生方法的所有地方不会因为你交换了方法的实现而出现意想不到的结果。 理解实现原理：只是简单的拷贝粘贴交换方法实现的代码而不去理解实现原理不仅会让 App 很脆弱，并且浪费了学习 Objective-C 运行时的机会。阅读 Objective-C Runtime Reference 并且浏览 能够让你更好理解实现原理。 持续的预防：不管你对你理解 swlzzling 框架，UIKit 或者其他内嵌框架有多自信，一定要记住所有东西在下一个发行版本都可能变得不再好使。做好准备，在使用这个黑魔法中走得更远，不要让程序反而出现不可思议的行为。 参考资料 NSHipster_Method-swizzling 关联对象associated objects]]></content>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RunLoop的实现原理及应用]]></title>
    <url>%2F2018%2F09%2F07%2FRunLoop%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[什么是RunLoop?为了保证线程能随时处理事件且不会退出，我们需要一个run loop 运行循环来一直保持能持续接收并处理各种事件，确保执行线程不被销毁。实现思路类似于如下代码： // Event loopfunction loop() &#123; initialize(); do &#123; var message = get_next_message(); process_message(message); &#125; while (message != quit);&#125; 当创建一个线程后，开启一个loop() 使用do-while 循环来不断的接收并处理事件，直到线程退出。实现这种模型的关键点在于：如何管理事件/消息，如何让线程在没有处理消息时休眠以避免资源占用，在有消息到来时立即唤醒。 所以，RunLoop 实际上就是一个对象，这个对象管理了其需要处理的事件和消息，并提供了一个入口函数来执行上面 Event Loop 的逻辑。线程执行了这个函数后，就会一直处于这个函数内部 “接受消息-&gt;等待-&gt;处理” 的循环中，直到这个循环结束（比如传入 quit 的消息），函数返回。 OSX/iOS 系统中，提供了这两个对象：NSRunLoop 和 CFRunLoopRef，来实现线程的运行循环。 CFRunLoopRef 是在 CoreFoundation 框架内的，它提供了纯 C 函数的 API，所有这些 API 都是线程安全的。NSRunLoop 是基于 CFRunLoopRef 的封装，提供了面向对象的 API，但是这些 API 不是线程安全的。 CFRunLoopRef 的代码是开源的，你可以在这里下载到整个 CoreFoundation 的源码来查看。 RunLoop与线程的关系在iOS中有两个线程对象pthread_t和NSThread，苹果文档中有说明NSThread只是pthread_t的封装，但是在Foundation框架中并没有发现这两个对象之间的转换接口，但是可以肯定的是pthread_t和NSThread是一一对应的，而且CFRunLoopRef 是基于pthread 来管理的，可以说是线程的管理器。 苹果不允许直接创建 RunLoop，它只提供了两个自动获取的函数：CFRunLoopGetMain() 和 CFRunLoopGetCurrent()。 这两个函数内部的逻辑大概是下面这样: /// 全局的Dictionary，key 是 pthread_t， value 是 CFRunLoopRefstatic CFMutableDictionaryRef loopsDic;/// 访问 loopsDic 时的锁static CFSpinLock_t loopsLock; /// 获取一个 pthread 对应的 RunLoop。CFRunLoopRef _CFRunLoopGet(pthread_t thread) &#123; OSSpinLockLock(&amp;loopsLock); if (!loopsDic) &#123; // 第一次进入时，初始化全局Dic，并先为主线程创建一个 RunLoop。 loopsDic = CFDictionaryCreateMutable(); CFRunLoopRef mainLoop = _CFRunLoopCreate(); CFDictionarySetValue(loopsDic, pthread_main_thread_np(), mainLoop); &#125; /// 直接从 Dictionary 里获取。 CFRunLoopRef loop = CFDictionaryGetValue(loopsDic, thread)); if (!loop) &#123; /// 取不到时，创建一个 loop = _CFRunLoopCreate(); CFDictionarySetValue(loopsDic, thread, loop); /// 注册一个回调，当线程销毁时，顺便也销毁其对应的 RunLoop。 _CFSetTSD(..., thread, loop, __CFFinalizeRunLoop); &#125; OSSpinLockUnLock(&amp;loopsLock); return loop;&#125; CFRunLoopRef CFRunLoopGetMain() &#123; return _CFRunLoopGet(pthread_main_thread_np());&#125; CFRunLoopRef CFRunLoopGetCurrent() &#123; return _CFRunLoopGet(pthread_self());&#125; 从上述代码中可以看出，线程和 RunLoop 之间是一一对应的，其关系是保存在一个全局的 Dictionary 里。线程刚创建时并没有 RunLoop，如果你不主动获取，那它一直都不会有。RunLoop 的创建是发生在第一次获取时，RunLoop 的销毁是发生在线程结束时。你只能在一个线程的内部获取其 RunLoop（主线程除外）。 RunLoop与其相关的几个类在 CoreFoundation 里面关于 RunLoop 的有5个类: CFRunLoopRef runloop结构体CFRunLoopModeRef 运行模式，有多种，下面会讲 CFRunLoopSourceRef 各种事件源（source、timer、observer）CFRunLoopTimerRef 基于事件的触发器 CFRunLoopRef：结构体定义如下： typedef struct __CFRunLoop * CFRunLoopRef;struct __CFRunLoop &#123; CFRuntimeBase _base; pthread_mutex_t _lock; /* locked for accessing mode list */ __CFPort _wakeUpPort; // used for CFRunLoopWakeUp Boolean _unused; volatile _per_run_data *_perRunData; // reset for runs of the run loop pthread_t _pthread; uint32_t _winthread; CFMutableSetRef _commonModes; // 字符串，记录所有标记为common的mode CFMutableSetRef _commonModeItems; // 所有commonMode的item(source、timer、observer) CFRunLoopModeRef _currentMode; CFMutableSetRef _modes; // CFRunLoopModeRef set struct _block_item *_blocks_head; struct _block_item *_blocks_tail; CFTypeRef _counterpart;&#125;; 从上述代码可以看出，一个runloop 对应一个pthread 线程，包含多个mode，一个mode又包含了多个mode items事件。_commonModes Set 里面存储着被标记为common的mode，标记common意味着可以同时在多种模式下执行事件。例如：在tableViewCell 中添加一个Timer，当滑动tableView时Timer任然在执行回调，这时的Timer添加在RunLoop中是以NSRunLoopCommonModesmode运行的。 CFRunLoopModeRef： 结构体定义大致如下： struct __CFRunLoopMode &#123; CFStringRef _name; // Mode Name, 例如 @"kCFRunLoopDefaultMode" CFMutableSetRef _sources0; // Set CFMutableSetRef _sources1; // Set CFMutableArrayRef _observers; // Array CFMutableArrayRef _timers; // Array ...&#125;; 一个 RunLoop 包含多个 Mode，每个 Mode 又包含若干个 Source/Timer/Observer。每次调用 RunLoop 的主函数时，只能指定其中一个 Mode，这个Mode被称作 CurrentMode。如果需要切换 Mode，只能退出 Loop，再重新指定一个 Mode 进入。这样做主要是为了分隔开不同组的 Source/Timer/Observer，让其互不影响。 CFRunLoopSourceRef：结构体定义如下： struct __CFRunLoopSource &#123; CFRuntimeBase _base; uint32_t _bits; pthread_mutex_t _lock; CFIndex _order; /* immutable */ CFMutableBagRef _runLoops; union &#123; CFRunLoopSourceContext version0; /* immutable, except invalidation */ CFRunLoopSourceContext1 version1; /* immutable, except invalidation */ &#125; _context;&#125;; 这里是事件产生的地方。Source有两个版本：Source0 和 Source1。 Source0：非基于 Port 的事件，只包含了一个回调（函数指针），它并不能主动触发事件。使用时，你需要先调用 CFRunLoopSourceSignal(source)，将这个 Source 标记为待处理，然后手动调用 CFRunLoopWakeUp(runloop) 来唤醒 RunLoop，让其处理这个事件。一般处理点击、触摸等事件 Source1：是基于Port的，包含了一个 mach_port 和一个回调（函数指针），被用于通过内核和其他线程相互发送消息。这种 Source 能主动唤醒 RunLoop 的线程，其原理在下面会讲到。 CFRunLoopTimerRef ：结构体定义如下： struct __CFRunLoopTimer &#123; CFRuntimeBase _base; uint16_t _bits; pthread_mutex_t _lock; CFRunLoopRef _runLoop; CFMutableSetRef _rlModes; CFAbsoluteTime _nextFireDate; CFTimeInterval _interval; /* immutable */ CFTimeInterval _tolerance; /* mutable */ uint64_t _fireTSR; /* TSR units */ CFIndex _order; /* immutable */ CFRunLoopTimerCallBack _callout; /* immutable */ CFRunLoopTimerContext _context; /* immutable, except invalidation */&#125;; 是基于时间的触发器，它和 NSTimer 是toll-free bridged 的，可以混用。其包含一个时间长度和一个回调（函数指针）。当其加入到 RunLoop 时，RunLoop会注册对应的时间点，当时间点到时，RunLoop会被唤醒以执行那个回调。 CFRunLoopObserverRef ：结构体定义如下： struct __CFRunLoopObserver &#123; CFRuntimeBase _base; pthread_mutex_t _lock; CFRunLoopRef _runLoop; CFIndex _rlCount; CFOptionFlags _activities; /* immutable */ CFIndex _order; /* immutable */ CFRunLoopObserverCallBack _callout; /* immutable */ CFRunLoopObserverContext _context; /* immutable, except invalidation */&#125;; 是观察者，每个 Observer 都包含了一个回调（函数指针），当 RunLoop 的状态发生变化时，观察者就能通过回调接受到这个变化。可以观测的时间点有以下几个： typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) &#123; kCFRunLoopEntry = (1UL &lt;&lt; 0), // 即将进入Loop kCFRunLoopBeforeTimers = (1UL &lt;&lt; 1), // 即将处理 Timer kCFRunLoopBeforeSources = (1UL &lt;&lt; 2), // 即将处理 Source kCFRunLoopBeforeWaiting = (1UL &lt;&lt; 5), // 即将进入休眠 kCFRunLoopAfterWaiting = (1UL &lt;&lt; 6), // 刚从休眠中唤醒 kCFRunLoopExit = (1UL &lt;&lt; 7), // 即将退出Loop&#125;; 上面的 Source/Timer/Observer 被统称为 mode item，一个 item 可以被同时加入多个 mode。但一个 item 被重复加入同一个 mode 时是不会有效果的。如果一个 mode 中一个 item 都没有，则 RunLoop 会直接退出，不进入循环。 RunLoopModeCFRunLoopMode 和 CFRunLoop 的结构大致如下： struct __CFRunLoopMode &#123; CFStringRef _name; // Mode Name, 例如 @"kCFRunLoopDefaultMode" CFMutableSetRef _sources0; // Set CFMutableSetRef _sources1; // Set CFMutableArrayRef _observers; // Array CFMutableArrayRef _timers; // Array ...&#125;; struct __CFRunLoop &#123; CFMutableSetRef _commonModes; // Set CFMutableSetRef _commonModeItems; // Set&lt;Source/Observer/Timer&gt; CFRunLoopModeRef _currentMode; // Current Runloop Mode CFMutableSetRef _modes; // Set ...&#125;; 这里有个概念叫 “CommonModes”：一个 Mode 可以将自己标记为”Common”属性（通过将其 ModeName（NSRunLoopCommonModes，通用/共用Mode） 添加到 RunLoop 的 “commonModes” 中）。每当 RunLoop 的内容发生变化时，RunLoop 都会自动将 _commonModeItems 里的 Source/Observer/Timer 同步到具有 “Common” 标记的所有Mode里。 应用场景举例： iOS中的主线程runloop有2个预设的Mode：kCFRunLoopDefaultMode（NSDefaultRunLoopMode） 和 UITrackingRunLoopMode（UITrackingRunLoopMode），第一个是默认的mode，也是App平时所处的状态，第二个是追踪ScrollView滑动时的状态。 例如当一个tableViewCell中添加一个运行在DefaultRunLoopMode下的Timer时，那么当滑动tableView的时候，RunLoop会将mode切换为TrackingRunLoopMode用于对scrollView页面滑动手势的跟踪，这时Timer就不会被回调执行。那么，如何让tableView在滑动的同时Timer任然在执行回调计时呢，一种方式是将Timer分别添加到这两个Mode中。 还有一种更简便的方式就是修改Timer的mode为：kCFRunLoopCommonModes (NSRunLoopCommonModes)，即将Timer添加到RunLoop的_commonModeItems中，这样Timer的定时事件会分别添加到kCFRunLoopDefaultMode（NSDefaultRunLoopMode） 和 UITrackingRunLoopMode（UITrackingRunLoopMode）中，这样不论页面是否在滑动，都不会影响Timer的计时回调。 CFRunLoop对外暴露的管理 Mode 接口只有下面2个: // 给runloop 添加modevoid CFRunLoopAddCommonMode(CFRunLoopRef runloop, CFStringRef modeName);// 获取RunLoop当前运行的modeSInt32 CFRunLoopRunInMode(CFStringRef modeName, ...); Mode 暴露的管理 mode item 的接口有下面几个： // 对runloop添加source事件源，并指定modeCFRunLoopAddSource(CFRunLoopRef rl, CFRunLoopSourceRef source, CFStringRef modeName);// 对runloop添加observer观察，并指定观察modeCFRunLoopAddObserver(CFRunLoopRef rl, CFRunLoopObserverRef observer, CFStringRef modeName);// 对runloop添加Timer定时源，并指定modeCFRunLoopAddTimer(CFRunLoopRef rl, CFRunLoopTimerRef timer, CFStringRef mode);// 移除source源CFRunLoopRemoveSource(CFRunLoopRef rl, CFRunLoopSourceRef source, CFStringRef modeName);// 移除观察者CFRunLoopRemoveObserver(CFRunLoopRef rl, CFRunLoopObserverRef observer, CFStringRef modeName);// 移除定时器TimerCFRunLoopRemoveTimer(CFRunLoopRef rl, CFRunLoopTimerRef timer, CFStringRef mode); 你只能通过 mode name 来操作内部的 mode，当你传入一个新的 mode name 但 RunLoop 内部没有对应 mode 时，RunLoop会自动帮你创建对应的 CFRunLoopModeRef。对于一个 RunLoop 来说，其内部的 mode 只能增加不能删除。 苹果公开提供的 Mode 有两个：kCFRunLoopDefaultMode (NSDefaultRunLoopMode) 和 UITrackingRunLoopMode，你可以用这两个 Mode Name 来操作其对应的 Mode。 同时苹果还提供了一个操作 Common 标记的字符串：kCFRunLoopCommonModes (NSRunLoopCommonModes)，你可以用这个字符串来操作 Common Items，或标记一个 Mode 为 “Common”。使用时注意区分这个字符串和其他 mode name。 RunLoop的内部逻辑根据苹果在文档里的说明，RunLoop 内部的逻辑大致如下：题图引用自ibireme大神的《深入理解RunLoop》博文。 其内部代码整理后如下： /// 用DefaultMode启动void CFRunLoopRun(void) &#123; CFRunLoopRunSpecific(CFRunLoopGetCurrent(), kCFRunLoopDefaultMode, 1.0e10, false);&#125; /// 用指定的Mode启动，允许设置RunLoop超时时间int CFRunLoopRunInMode(CFStringRef modeName, CFTimeInterval seconds, Boolean stopAfterHandle) &#123; return CFRunLoopRunSpecific(CFRunLoopGetCurrent(), modeName, seconds, returnAfterSourceHandled);&#125; /// RunLoop的实现int CFRunLoopRunSpecific(runloop, modeName, seconds, stopAfterHandle) &#123; /// 首先根据modeName找到对应mode CFRunLoopModeRef currentMode = __CFRunLoopFindMode(runloop, modeName, false); /// 如果mode里没有source/timer/observer, 直接返回。 if (__CFRunLoopModeIsEmpty(currentMode)) return; /// 1. 通知 Observers: RunLoop 即将进入 loop。 __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopEntry); /// 内部函数，进入loop __CFRunLoopRun(runloop, currentMode, seconds, returnAfterSourceHandled) &#123; Boolean sourceHandledThisLoop = NO; int retVal = 0; do &#123; /// 2. 通知 Observers: RunLoop 即将触发 Timer 回调。 __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeTimers); /// 3. 通知 Observers: RunLoop 即将触发 Source0 (非port) 回调。 __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeSources); /// 执行被加入的block __CFRunLoopDoBlocks(runloop, currentMode); /// 4. RunLoop 触发 Source0 (非port) 回调。 sourceHandledThisLoop = __CFRunLoopDoSources0(runloop, currentMode, stopAfterHandle); /// 执行被加入的block __CFRunLoopDoBlocks(runloop, currentMode); /// 5. 如果有 Source1 (基于port) 处于 ready 状态，直接处理这个 Source1 然后跳转去处理消息。 if (__Source0DidDispatchPortLastTime) &#123; Boolean hasMsg = __CFRunLoopServiceMachPort(dispatchPort, &amp;msg) if (hasMsg) goto handle_msg; &#125; /// 通知 Observers: RunLoop 的线程即将进入休眠(sleep)。 if (!sourceHandledThisLoop) &#123; __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeWaiting); &#125; /// 7. 调用 mach_msg 等待接受 mach_port 的消息。线程将进入休眠, 直到被下面某一个事件唤醒。 /// • 一个基于 port 的Source 的事件。 /// • 一个 Timer 到时间了 /// • RunLoop 自身的超时时间到了 /// • 被其他什么调用者手动唤醒 __CFRunLoopServiceMachPort(waitSet, &amp;msg, sizeof(msg_buffer), &amp;livePort) &#123; mach_msg(msg, MACH_RCV_MSG, port); // thread wait for receive msg &#125; /// 8. 通知 Observers: RunLoop 的线程刚刚被唤醒了。 __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopAfterWaiting); /// 收到消息，处理消息。 handle_msg: /// 9.1 如果一个 Timer 到时间了，触发这个Timer的回调。 if (msg_is_timer) &#123; __CFRunLoopDoTimers(runloop, currentMode, mach_absolute_time()) &#125; /// 9.2 如果有dispatch到main_queue的block，执行block。 else if (msg_is_dispatch) &#123; __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(msg); &#125; /// 9.3 如果一个 Source1 (基于port) 发出事件了，处理这个事件 else &#123; CFRunLoopSourceRef source1 = __CFRunLoopModeFindSourceForMachPort(runloop, currentMode, livePort); sourceHandledThisLoop = __CFRunLoopDoSource1(runloop, currentMode, source1, msg); if (sourceHandledThisLoop) &#123; mach_msg(reply, MACH_SEND_MSG, reply); &#125; &#125; /// 执行加入到Loop的block __CFRunLoopDoBlocks(runloop, currentMode); if (sourceHandledThisLoop &amp;&amp; stopAfterHandle) &#123; /// 进入loop时参数说处理完事件就返回。 retVal = kCFRunLoopRunHandledSource; &#125; else if (timeout) &#123; /// 超出传入参数标记的超时时间了 retVal = kCFRunLoopRunTimedOut; &#125; else if (__CFRunLoopIsStopped(runloop)) &#123; /// 被外部调用者强制停止了 retVal = kCFRunLoopRunStopped; &#125; else if (__CFRunLoopModeIsEmpty(runloop, currentMode)) &#123; /// source/timer/observer一个都没有了 retVal = kCFRunLoopRunFinished; &#125; /// 如果没超时，mode里没空，loop也没被停止，那继续loop。 &#125; while (retVal == 0); &#125; /// 10. 通知 Observers: RunLoop 即将退出。 __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopExit);&#125; 可以看到，实际上 RunLoop 就是这样一个函数，其内部是一个 do-while 循环。当你调用 CFRunLoopRun() 时，线程就会一直停留在这个循环里；直到超时或被手动停止，该函数才会返回。 过程分析：结合上面的图示和CFRunLoop 源码可以更清晰的看出来Runloop内部的核心工作原理。当进入Loop后，首先会通知Observer 将要处理Timer、Source0事件，然后处理Source0任务，如果有Source1(基于port)则会唤醒loop并处理相应的任务，如果没有Source1则会休眠，等待唤醒，一直循环执行2-9之间的任务，直到RunLoop被停止。 难点注释：mach_portRunLoop的核心是基于mach port 的，其进入休眠时调用的函数是mach_msg()。OS X / iOS 系统架构采用的XNU内核，其内环被称作Mach，作为XNU的微内核，仅提供了诸如处理器调度、IPC (进程间通信)等非常少量的基础服务。 和其他架构不同， Mach 的对象间不能直接调用，只能通过消息传递的方式实现对象间的通信。”消息”是 Mach 中最基础的概念，消息在两个端口 (port) 之间传递，这就是 Mach 的 IPC (进程间通信) 的核心。 在RunLoop的实现代码中，当loop进入休眠后，会调用__CFRunLoopServiceMachPort（）函数（从7中可看出），用来等待内核mach_msg() 事件，当收到一个基于port（可理解为进程中通信的一个端口，uint32_t类型） 的source1 事件时，loop会被立即唤醒并处理相应任务，下面代码说明了可能处理的任务类型： ....... // 发送"从休眠中被唤醒的" 通知__CFRunLoopDoObservers(kCFRunLoopAfterWaiting);// 处理因timer的唤醒if (wakeUpPort == timerPort) __CFRunLoopDoTimers();// 处理异步方法唤醒,如dispatch_asyncelse if (wakeUpPort == mainDispatchQueuePort) __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__()// UI刷新,动画显示else __CFRunLoopDoSource1();// 再次确保是否有同步的方法需要调用__CFRunLoopDoBlocks();....... iOS中RunLoop实现的功能首先我们可以看一下 App 启动后 RunLoop 的状态： CFRunLoop &#123; current mode = kCFRunLoopDefaultMode common modes = &#123; UITrackingRunLoopMode kCFRunLoopDefaultMode &#125; common mode items = &#123; // source0 (manual) CFRunLoopSource &#123;order =-1, &#123; callout = _UIApplicationHandleEventQueue&#125;&#125; CFRunLoopSource &#123;order =-1, &#123; callout = PurpleEventSignalCallback &#125;&#125; CFRunLoopSource &#123;order = 0, &#123; callout = FBSSerialQueueRunLoopSourceHandler&#125;&#125; // source1 (mach port) CFRunLoopSource &#123;order = 0, &#123;port = 17923&#125;&#125; CFRunLoopSource &#123;order = 0, &#123;port = 12039&#125;&#125; CFRunLoopSource &#123;order = 0, &#123;port = 16647&#125;&#125; CFRunLoopSource &#123;order =-1, &#123; callout = PurpleEventCallback&#125;&#125; CFRunLoopSource &#123;order = 0, &#123;port = 2407, callout = _ZL20notify_port_callbackP12__CFMachPortPvlS1_&#125;&#125; CFRunLoopSource &#123;order = 0, &#123;port = 1c03, callout = __IOHIDEventSystemClientAvailabilityCallback&#125;&#125; CFRunLoopSource &#123;order = 0, &#123;port = 1b03, callout = __IOHIDEventSystemClientQueueCallback&#125;&#125; CFRunLoopSource &#123;order = 1, &#123;port = 1903, callout = __IOMIGMachPortPortCallback&#125;&#125; // Ovserver CFRunLoopObserver &#123;order = -2147483647, activities = 0x1, // Entry callout = _wrapRunLoopWithAutoreleasePoolHandler&#125; CFRunLoopObserver &#123;order = 0, activities = 0x20, // BeforeWaiting callout = _UIGestureRecognizerUpdateObserver&#125; CFRunLoopObserver &#123;order = 1999000, activities = 0xa0, // BeforeWaiting | Exit callout = _afterCACommitHandler&#125; CFRunLoopObserver &#123;order = 2000000, activities = 0xa0, // BeforeWaiting | Exit callout = _ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv&#125; CFRunLoopObserver &#123;order = 2147483647, activities = 0xa0, // BeforeWaiting | Exit callout = _wrapRunLoopWithAutoreleasePoolHandler&#125; // Timer CFRunLoopTimer &#123;firing = No, interval = 3.1536e+09, tolerance = 0, next fire date = 453098071 (-4421.76019 @ 96223387169499), callout = _ZN2CAL14timer_callbackEP16__CFRunLoopTimerPv (QuartzCore.framework)&#125; &#125;, modes ＝ &#123; CFRunLoopMode &#123; sources0 = &#123; /* same as 'common mode items' */ &#125;, sources1 = &#123; /* same as 'common mode items' */ &#125;, observers = &#123; /* same as 'common mode items' */ &#125;, timers = &#123; /* same as 'common mode items' */ &#125;, &#125;, CFRunLoopMode &#123; sources0 = &#123; /* same as 'common mode items' */ &#125;, sources1 = &#123; /* same as 'common mode items' */ &#125;, observers = &#123; /* same as 'common mode items' */ &#125;, timers = &#123; /* same as 'common mode items' */ &#125;, &#125;, CFRunLoopMode &#123; sources0 = &#123; CFRunLoopSource &#123;order = 0, &#123; callout = FBSSerialQueueRunLoopSourceHandler&#125;&#125; &#125;, sources1 = (null), observers = &#123; CFRunLoopObserver &gt;&#123;activities = 0xa0, order = 2000000, callout = _ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv&#125; )&#125;, timers = (null), &#125;, CFRunLoopMode &#123; sources0 = &#123; CFRunLoopSource &#123;order = -1, &#123; callout = PurpleEventSignalCallback&#125;&#125; &#125;, sources1 = &#123; CFRunLoopSource &#123;order = -1, &#123; callout = PurpleEventCallback&#125;&#125; &#125;, observers = (null), timers = (null), &#125;, CFRunLoopMode &#123; sources0 = (null), sources1 = (null), observers = (null), timers = (null), &#125; &#125;&#125; 可以看到，系统默认注册了5个Mode: kCFRunLoopDefaultMode: App的默认 Mode，通常主线程是在这个 Mode 下运行的。 UITrackingRunLoopMode: 界面跟踪 Mode，用于 ScrollView 追踪触摸滑动，保证界面滑动时不受其他 Mode 影响。 UIInitializationRunLoopMode: 在刚启动 App 时第进入的第一个 Mode，启动完成后就不再使用 GSEventReceiveRunLoopMode: 接受系统事件的内部 Mode，通常用不到。 kCFRunLoopCommonModes: 这是一个占位的 Mode，没有实际作用。 下面是RunnLoop在iOS开发中的相关应用 AutoreleasePoolApp启动后，苹果在主线程 RunLoop 里注册了两个 Observer，其回调都是 _wrapRunLoopWithAutoreleasePoolHandler()。 第一个 Observer 监视的事件是 Entry(即将进入Loop)，其回调内会调用 _objc_autoreleasePoolPush() 创建自动释放池。其 order 是-2147483647，优先级最高，保证创建释放池发生在其他所有回调之前。 第二个 Observer 监视了两个事件： BeforeWaiting(准备进入休眠) 时调用_objc_autoreleasePoolPop() 和 _objc_autoreleasePoolPush() 释放旧的池并创建新池；Exit(即将退出Loop) 时调用 _objc_autoreleasePoolPop() 来释放自动释放池。这个 Observer 的 order 是 2147483647，优先级最低，保证其释放池子发生在其他所有回调之后。 在主线程执行的代码，通常是写在诸如事件回调、Timer回调内的。这些回调会被 RunLoop 创建好的 AutoreleasePool 环绕着，所以不会出现内存泄漏，开发者也不必显示创建 Pool 了。 事件响应苹果注册了一个 Source1 (基于 mach port 的) 用来接收系统事件，其回调函数为 __IOHIDEventSystemClientQueueCallback()。 当一个硬件事件(触摸/锁屏/摇晃等)发生后，首先由 IOKit.framework 生成一个 IOHIDEvent 事件并由 SpringBoard 接收。这个过程的详细情况可以参考这里。SpringBoard 只接收按键(锁屏/静音等)，触摸，加速，接近传感器等几种 Event，随后用 mach port 转发给需要的App进程。随后苹果注册的那个 Source1 就会触发回调，并调用 _UIApplicationHandleEventQueue() 进行应用内部的分发。 _UIApplicationHandleEventQueue() 会把 IOHIDEvent 处理并包装成 UIEvent 进行处理或分发，其中包括识别 UIGesture/处理屏幕旋转/发送给 UIWindow 等。通常事件比如 UIButton 点击、touchesBegin/Move/End/Cancel 事件都是在这个回调中完成的。 手势识别当上面的 _UIApplicationHandleEventQueue() 识别了一个手势时，其首先会调用 Cancel 将当前的 touchesBegin/Move/End 系列回调打断。随后系统将对应的 UIGestureRecognizer 标记为待处理。 苹果注册了一个 Observer 监测 BeforeWaiting (Loop即将进入休眠) 事件，这个Observer的回调函数是 _UIGestureRecognizerUpdateObserver()，其内部会获取所有刚被标记为待处理的 GestureRecognizer，并执行GestureRecognizer的回调。 当有 UIGestureRecognizer 的变化(创建/销毁/状态改变)时，这个回调都会进行相应处理。 界面更新当在操作 UI 时，比如改变了 Frame、更新了 UIView/CALayer 的层次时，或者手动调用了 UIView/CALayer 的 setNeedsLayout/setNeedsDisplay方法后，这个 UIView/CALayer 就被标记为待处理，并被提交到一个全局的容器去。 苹果注册了一个 Observer 监听 BeforeWaiting(即将进入休眠) 和 Exit (即将退出Loop) 事件，回调去执行一个很长的函数：_ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv()。这个函数里会遍历所有待处理的 UIView/CAlayer 以执行实际的绘制和调整，并更新 UI 界面。 这个函数内部的调用栈大概是这样的： _ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv() QuartzCore:CA::Transaction::observer_callback: CA::Transaction::commit(); CA::Context::commit_transaction(); CA::Layer::layout_and_display_if_needed(); CA::Layer::layout_if_needed(); [CALayer layoutSublayers]; [UIView layoutSubviews]; CA::Layer::display_if_needed(); [CALayer display]; [UIView drawRect]; 定时器NSTimer 其实就是 CFRunLoopTimerRef，他们之间是 toll-free bridged 的。一个 NSTimer 注册到 RunLoop 后，RunLoop 会为其重复的时间点注册好事件。例如 10:00, 10:10, 10:20 这几个时间点。RunLoop为了节省资源，并不会在非常准确的时间点回调这个Timer。Timer 有个属性叫做 Tolerance (宽容度)，标示了当时间点到后，容许有多少最大误差。 如果某个时间点被错过了，例如执行了一个很长的任务，则那个时间点的回调也会跳过去，不会延后执行。就比如等公交，如果 10:10 时我忙着玩手机错过了那个点的公交，那我只能等 10:20 这一趟了。 CADisplayLink 是一个和屏幕刷新率一致的定时器（但实际实现原理更复杂，和 NSTimer 并不一样，其内部实际是操作了一个 Source）。如果在两次屏幕刷新之间执行了一个长任务，那其中就会有一帧被跳过去（和 NSTimer 相似），造成界面卡顿的感觉。在快速滑动TableView时，即使一帧的卡顿也会让用户有所察觉。Facebook 开源的 AsyncDisplayLink 就是为了解决界面卡顿的问题，其内部也用到了 RunLoop，这个稍后我会再单独写一页博客来分析。 PerformSelecter当调用 NSObject 的 performSelecter:afterDelay: 后，实际上其内部会创建一个 Timer 并添加到当前线程的 RunLoop 中。所以如果当前线程没有 RunLoop，则这个方法会失效。 当调用 performSelector:onThread: 时，实际上其会创建一个 Timer 加到对应的线程去，同样的，如果对应线程没有 RunLoop 该方法也会失效。 最后本文秉着学习RunLoop的应用及内部实现原理，阅读了大量前辈优秀的博文、以及查阅苹果开源代码进行整理学习，其中大部分参阅了ibireme大神的《深入理解RunLoop》一文，并有部分内容及图片的引用，感谢ibireme对于RunLoop文章的分享。 参考/引用 深入理解runloop iOS多线程编程指南(三)RunLoop]]></content>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入剖析Autorelease Pool (自动释放池)]]></title>
    <url>%2F2018%2F08%2F28%2F%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90Autorelease-Pool-%E8%87%AA%E5%8A%A8%E9%87%8A%E6%94%BE%E6%B1%A0%2F</url>
    <content type="text"><![CDATA[前言在MRC的内存管理模式下，可以将创建的对象加入自动释放池，程序员则无需手动调用release方法来释放对象，而是当自动释放池销毁的时候会对其中的每一个对象发送release消息，从而达到自动释放的目的。下面我们一步步揭开它的神秘面纱，深度剖析autoreleasepool的实现原理。 @autoreleasepool 实现原理main.m文件中的@autoreleasepool() 在iOS代码main.m文件中，我们可以看到@autoreleasepool{}代码块，其中包含的这一行代码将所有事件、消息全部交给了UIApplication来处理。需要注意的是：整个iOS的应用都是包含在一个自动释放池block中的。 // main.m 文件中的内容int main(int argc, char * argv[]) &#123; @autoreleasepool &#123; return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));&#125; 我们在命令行中使用 clang -rewrite-objc main.m 让编译器重新改写这个文件，可以看到该文件的c++代码实现细节，关键代码如下： ...int main(int argc,const char * argv[])&#123; /* @autoreleasepool */ &#123; __AtAutoreleasepool __autoreleasepool; &#125; return 0;&#125;... 通过分析上述代码，可以看到 {__AtAutoreleasepool __autoreleasepool;} 这段代码即是@atuoreleasepool的c++实现，通过创建一个__autoreleasepool对象来管理其他对象的自动释放操作。 分析__AtAutoreleasepool 结构体 我们在main.cpp文件中，定位到了其结构体的定义： ...struct __AtAutoreleasepool &#123; __AtAutoreleasepool() &#123; atautoreleasepoolobj = objc_autoreleasePoolPush();&#125; ~__AtAutoreleasepool() &#123; objc_autoreleasePoolPop(atautoreleasepoolpbj);&#125; void * atautoreleasepoolobj;&#125;... /*代码解释：1. __AtAutoreleasepool() 是其构造函数2. ~__AtAutoreleasepool() 是其析构函数析构函数：与构造函数相反, 析构函数是在对象被撤销时被自动调用, 用于对成员撤销时的一些清理工作, 例如在前面提到的手动释放使用 new 或 malloc 进行申请的内存空间。析构函数的特点：1. 析构函数函数名与类名相同, 紧贴在名称前面用波浪号 ~ 与构造函数进行区分, 例如: ~Point();2. 构造函数没有返回类型, 也不能指定参数, 因此析构函数只能有一个, 不能被重载;3. 当对象被撤销时析构函数被自动调用, 与构造函数不同的是, 析构函数可以被显式的调用, 以释放对象中动态申请的内存。*/ 这个结构体会在初始化时调用 objc_autoreleasePoolPush() 方法，会在析构时调用 objc_autoreleasePoolPop 方法。 这表明，我们的 main 函数在实际工作时其实是这样的： int main(int argc, const char * argv[]) &#123; &#123; void * atautoreleasepoolobj = objc_autoreleasePoolPush(); // do whatever you want objc_autoreleasePoolPop(atautoreleasepoolobj); &#125; return 0;&#125; 通过分析将@autoreleasepool{}的代码展开即可得到上述代码实现，在一个代码块中，先创建atautoreleasepoolobj 对象，然后中间插入iOS应用入口代码，最后自动调用析构函数objc_autoreleasePoolPop给当中的每一个对象发送 -release 消息销毁对象。 AutoreleasePool 实现原理从上一节我们对__AtAutoreleasepool结构体分析可以看出，自动释放池得以实现的核心是在它的构造函数和析构函数中，所以我们接下来就分析这两个函数的内部实现。 我们定位到 objc_autoreleasePoolPush 和 objc_autoreleasePoolPop 函数的实现代码如下： void *objc_autoreleasePoolPush(void) &#123; return AutoreleasePoolPage::push();&#125;void objc_autoreleasePoolPop(void *ctxt) &#123; AutoreleasePoolPage::pop(ctxt);&#125; 从函数实现中可以看出，内部使用了一个名为AutoreleasePoolPage的c++类，通过调用此类的push() 方法和pop()方法来实现被释放对象的添加和销毁操作。 既然这几个方法是拨开云雾的关键，那么我们就逐一分析：AutoreleasePoolPage的结构、objc_autoreleasePoolPush（） 方法、objc_autoreleasePoolPop（）方法。 AutoreleasePoolPage的结构 AutoreleasePoolPage的一个c++类，它在NSObject.mm 文件中的定义如下： class AutoreleasePoolPage &#123; magic_t const magic; id *next; pthread_t const thread; AutoreleasePoolPage * const parent; AutoreleasePoolPage *child; uint32_t const depth; uint32_t hiwat;&#125;;/* 类成员结构解析： magic：用来校验AutoreleasePoolPage 的结构是否完整 *next：指向最新添加的auoreleased 对象的下一个位置，初始化时指向begin() thread：指向当前线程 parent：指向父结点，第一个结点的 parent 值为 nil child：指向子结点，最后一个结点的 child 值为 nil depth：代表深度，从 0 开始，往后递增 1； hiwat：代表 high water mark 。*/ 一个空的AutoreleasePoolPage 的内存结构如下图所示： 另外，当 next == begin() 时，表示 AutoreleasePoolPage 为空；当 next == end() 时，表示 AutoreleasePoolPage 已满。 每个自动释放池都是由一系列的AutoreleasePoolPage组成的，并且每一个AutoreleasePoolPage的大小都是4096字节（16进制0x1000） AutoreleasePoolPage在自动释放池中的组织结构 AutoreleasePoolPage在自动释放池中是以双向链表的形式链接起来的： parent 和 child 就是用来构造双向链表的指针。 objc_autoreleasePoolPush() 方法解析 其中有个很重要定义POOL_SENTINEL ，它叫哨兵对象，本质是一个nil的宏定义： #define POOL_SENTINEL nil 在每个自动释放池初始化调用 objc_autoreleasePoolPush() 的时候，都会把一个 POOL_SENTINEL push 到自动释放池的栈顶，并且返回这个 POOL_SENTINEL 哨兵对象。上面讲解@autoreleasepool()代码块的时候，其中的atautoreleasepoolobj对象就是一个POOL_SENTINEL。 接下来我们分析objc_autoreleasePoolPush方法的实现，从上面的分析可以得出objc_autoreleasePoolPush方法、push()方法等的实现如下： /* 代码从上至下依次调用 */ // 1. objc_autoreleasePoolPush()void *objc_autoreleasePoolPush(void) &#123; return AutoreleasePoolPage::push();&#125;// 2. push()static inline void *push() &#123; return autoreleaseFast(POOL_SENTINEL);&#125;// 3. autoreleaseFast(), 参数obj 就是需要自动释放的对象static inline id *autoreleaseFast(id obj)&#123; AutoreleasePoolPage *page = hotPage(); if (page &amp;&amp; !page-&gt;full()) &#123; return page-&gt;add(obj); &#125; else if (page) &#123; return autoreleaseFullPage(obj, page); &#125; else &#123; return autoreleaseNoPage(obj); &#125;&#125; 上述方法autoreleaseFast:的实现中有三种选择： hotPage：可以理解为当前正在使用的 AutoreleasePoolPage 当page 存在，且没有满时：调用page-&gt;add(obj)方法将对象添加至AutoreleasePoolPage的栈中 当page存在，已经满时： 调用autoreleaseFullPage初始化一个新页 调用page-&gt;add(obj)将obj添加到新创建的page的栈中 无page时： 调用autoreleaseNoPage创建一个hotPage 调用page-&gt;add(obj)方法将对象添加至AutoreleasePoolPage的栈中 page-&gt; add() 方法的实现 id *add(id obj) &#123; id *ret = next; *next = obj; next++; return ret;&#125; 将obj对象添加到hotPage中，并移动 *next指针指向obj对象的下一个位置，本质上是一个压栈操作。 objc_autoreleasePoolPop() 方法解析 回顾上述分析，objc_autoreleasePoolPop方法的实现如下： void objc_autoreleasePoolPop(void *ctxt) &#123; if (UseGC) return; // fixme rdar://9167170 if (!ctxt) return; AutoreleasePoolPage::pop(ctxt);&#125;/*看起来传入任何一个指针都是可以的，但是在整个工程并没有发现传入其他对象的例子。不过在这个方法中传入其它的指针也是可行的，会将自动释放池释放到相应的位置。*/ pop 函数的入参就是 push 函数的返回值，也就是 POOL_SENTINEL 的内存地址 。当执行 pop 操作时，内存地址在 POOL_SENTINEL 之后的所有 autoreleased 对象都会被 release 。直到 POOL_SENTINEL 所在 page 的 next 指向 POOL_SENTINEL 为止。 下面是某个线程的 autoreleasepool 堆栈的内存结构图，在这个 autoreleasepool 堆栈中总共有两个 POOL_SENTINEL ，即有两个 autoreleasepool 。该堆栈由三个 AutoreleasePoolPage 结点组成，第一个 AutoreleasePoolPage 结点为 coldPage() ，最后一个 AutoreleasePoolPage 结点为 hotPage() 。其中，前两个结点已经满了，最后一个结点中保存了最新添加的 autoreleased 对象 objr3 的内存地址。 此时，如果执行 pop(token1) 操作，那么该 autoreleasepool 堆栈的内存结构将会变成如下图所示： autorelease 方法 最后我们分析下autorelease 方法内部的实现原理。首先，我们先看一下方法调用栈： - [obj autorelease]└── id objc_object::rootAutorelease() └── id objc_object::rootAutorelease2() └── static id AutoreleasePoolPage::autorelease(id obj) └── static id AutoreleasePoolPage::autoreleaseFast(id obj) ├── id *add(id obj) ├── static id *autoreleaseFullPage(id obj, AutoreleasePoolPage *page) │ ├── AutoreleasePoolPage(AutoreleasePoolPage *newParent) │ └── id *add(id obj) └── static id *autoreleaseNoPage(id obj) ├── AutoreleasePoolPage(AutoreleasePoolPage *newParent) └── id *add(id obj) 从上面从调用栈中可以看出， 会先调用AutoreleasePoolPage的autorelease()方法， 最后会调用上面提到autoreleaseFast方法，将obj对象添加AutoreleasePoolPage中。 下面是autorelease()方法的实现： static inline id autorelease(id obj)&#123; assert(obj); assert(!obj-&gt;isTaggedPointer()); id *dest __unused = autoreleaseFast(obj); // 最终会调用 autoreleaseFast 方法 assert(!dest || *dest == obj); return obj;&#125; 总结整个自动释放池 AutoreleasePool 的实现以及 autorelease 方法都已经分析完了，归纳总结后，得出了下面的几个要点： 自动释放池是由 AutoreleasePoolPage 以双向链表的方式实现的 当对象调用 autorelease 方法时，会将对象加入 AutoreleasePoolPage 的栈中 调用 AutoreleasePoolPage::pop 方法会向栈中的对象发送 release 消息 参考/引用 自动释放池的前世今生 —- 深入解析 autoreleasepool Objective-C Autorelease Pool 的实现原理]]></content>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[离屏渲染知多少?]]></title>
    <url>%2F2018%2F07%2F08%2F%E7%A6%BB%E5%B1%8F%E6%B8%B2%E6%9F%93%E7%9F%A5%E5%A4%9A%E5%B0%91%2F</url>
    <content type="text"><![CDATA[预备知识OpenGL中，GPU屏幕渲染有两种方式: On-Screen Rendering (当前屏幕渲染)：指的是GPU的渲染操作是在当前用于显示的屏幕缓冲区进行。 Off-Screen Rendering (离屏渲染)：指的是在GPU在当前屏幕缓冲区以外开辟一个缓冲区进行渲染操作。 当前屏幕渲染不需要额外创建新的缓存，也不需要开启新的上下文，相对于离屏渲染性能更好。但是受当前屏幕渲染的局限因素限制(只有自身上下文、屏幕缓存有限等)，当前屏幕渲染有些情况下的渲染解决不了的，就使用到离屏渲染。 相比于当前屏幕渲染，离屏渲染的代价是很高的，主要体现在两个方面： 创建新缓冲区：要想进行离屏渲染，首先要创建一个新的缓冲区。 上下文切换：离屏渲染的整个过程，需要多次切换上下文环境：先从当前屏幕切换到离屏，等待离屏渲 为什么要离屏渲染？有些效果被认为不能直接呈现于屏幕，而需要在别的地方做额外的处理预合成。图层属性的混合体没有预合成之前不能直接在屏幕中绘制，所以就需要屏幕外渲染。屏幕外渲染并不意味着软件绘制，但是它意味着图层必须在被显示之前在一个屏幕外上下文中被渲染（不论CPU还是GPU）。 在iOS开发中，当设置了以下属性时，会触发离屏渲染： 为图层设置遮罩（self.view.layer.mask = ?） 为图层设置圆角且开启遮罩属性（self.view.layer.corner = 5;self.view.layer.masksToBounds = YES） 注意：如果仅当给视图切圆角self.view.layer.corner = 5;，而没有设置遮罩属性self.view.layer.masksToBounds = YES;时，是不会触发离屏渲染的。只有设置了遮罩相关属性就会触发离屏渲染。 为图层设置阴影属性时（self.view.layer.shadow） 为图层设置栅格化（self.view.layer.shouldRasterize = YES） 设置图层不透明度属性layer.allowsGroupOpacity = YES或设置layer.opacity的值小于1.0时 图层设置了这些属性时：view.layer.edgeAntialiasingMask（设置边缘防锯齿遮罩），view.layer.allowsEdgeAntialiasing = YES（是否允许边缘防锯齿化为YES时，默认值：NO） 使用CGContext在drawRect :方法中绘制大部分情况下会导致离屏渲染，甚至仅仅是一个空的实现。 注意：这种方式触发的离屏渲染是CPU渲染，触发的CPU版本的离屏渲染，不是GPU的离屏渲染。如果我们重写了drawRect：方法并且使用任何Core Graphics Api 技术进行绘制操作时，都涉及到了CPU渲染。整个渲染过程由CPU在App内同步地完成，渲染得到的bitmap(位图)最后再交由GPU用于显示。 文本（任何种类，包括UILabel，CATextLayer，Core Text等）。 优化方案1. 圆角优化苹果官方对离屏渲染产生的性能问题也进行了优化： iOS 9.0 之前UIimageView跟UIButton设置圆角都会触发离屏渲染。 iOS 9.0 之后UIButton设置圆角会触发离屏渲染，而UIImageView里png图片设置圆角不会触发离屏渲染了，如果设置其他阴影效果之类的还是会触发离屏渲染的。 我们一般对UIView 、UIImageView 设置圆角时使用以下方式： imageView.layer.cornerRadius = 5.0;imageView.layer.masksToBounds = YES;// 注：这种设置圆角的组合方式，就会触发离屏渲染 优化方案1：使用贝塞尔曲线UIBezierPath 和Core Graphics 组合画出一个带有圆角的UIImage，如下示例： UIImageView *imageView = [[UIImageView alloc]initWithFrame:CGRectMake(0, 0, 100, 100)]; imageView.image = [UIImage imageNamed:@"myImg"]; // 开启原图大小的图形上下文UIGraphicsBeginImageContextWithOptions(imageView.bounds.size, NO, 1.0); // 使用贝塞尔曲线画出一个带有圆角的路径path[[UIBezierPath bezierPathWithRoundedRect:imageView.bounds cornerRadius:imageView.frame.size.width] addClip];// 绘制图形[imageView drawRect:imageView.bounds];imageView.image = UIGraphicsGetImageFromCurrentImageContext(); //结束画图 UIGraphicsEndImageContext();[self.view addSubview:imageView]; 优化方案2：使用CAShapeLayer和UIBezierPath设置圆角 UIImageView *imageView = [[UIImageView alloc]initWithFrame:CGRectMake(100, 100, 100, 100)]; imageView.image = [UIImage imageNamed:@"myImg"]; // 贝塞尔绘制路径UIBezierPath *maskPath = [UIBezierPath bezierPathWithRoundedRect:imageView.bounds byRoundingCorners:UIRectCornerAllCorners cornerRadii:imageView.bounds.size];// 绘制蒙版图层CAShapeLayer *maskLayer = [[CAShapeLayer alloc]init]; //设置大小 maskLayer.frame = imageView.bounds; //设置图形样子 maskLayer.path = maskPath.CGPath;// 关键一步：在原矩形图层上，添加一个带圆角的蒙层，实现圆角效果imageView.layer.mask = maskLayer; [self.view addSubview:imageView]; 对于方案2需要解释的是： CAShapeLayer继承于CALayer,可以使用CALayer的所有属性值； CAShapeLayer需要贝塞尔曲线配合使用才有意义（也就是说才有效果） 使用CAShapeLayer(属于CoreAnimation)与贝塞尔曲线可以实现不在view的drawRect（继承于CoreGraphics走的是CPU,消耗的性能较大）方法中画出一些想要的图形 CAShapeLayer动画渲染直接提交到手机的GPU当中，相较于view的drawRect方法使用CPU渲染而言，其效率极高，能大大优化内存使用情况。 总的来说就是用CAShapeLayer的内存消耗少，渲染速度快，建议使用优化方案2。 2. Shadow的优化对于shadow，如果图层是个简单的几何图形或者圆角图形，我们可以通过设置shadowPath来优化性能，能大幅提高性能。示例如下： // 对imageView添加阴影效果imageView.layer.shadowColor = [UIColor grayColor].CGColor;imageView.layer.shadowOpacity = 1.0; // 阴影不透明度，1.0表示不透明imageView.layer.shadowRadius = 2.0; // 阴影的模糊半径// 画出阴影路径UIBezierPath *path = [UIBezierPath bezierPathWithRect:imageView.frame];imageView.layer.shadowPath = path.CGPath; 我们还可以通过设置shouldRasterize属性值为YES来强制开启离屏渲染。其实就是光栅化（Rasterization）。 既然离屏渲染这么不好，为什么我们还要强制开启呢？当一个图像混合了多个图层，每次移动时，每一帧都要重新合成这些图层，十分消耗性能。 当我们开启光栅化后，会在首次产生一个位图缓存，当再次使用时候就会复用这个缓存。但是如果图层发生改变的时候就会重新产生位图缓存。所以这个功能一般不能用于UITableViewCell中，cell的复用反而降低了性能。最好用于图层较多的静态内容的图形。而且产生的位图缓存的大小是有限制的，一般是2.5个屏幕尺寸。在100ms之内不使用这个缓存，缓存也会被删除。所以我们要根据使用场景而定。 3. 其他优化建议圆角（主要针对ScrollView、TableView这种滑动视图上添加的视图） 当我们需要圆角效果时，可以使用一张中间透明图片蒙上去 直接让美工把图片切成圆角进行显示，这是效率最高的一种方案 如果能够只用cornerRadius解决，那就不要设置masksToBounds为YES，或者圆角视图数量较少且是静态页面时，也可以不用优化。 阴影、透明度等 使用ShadowPath指定layer阴影效果路径 使用异步进行layer渲染（Facebook开源的异步绘制框架AsyncDisplayKit） 设置layer的opaque值为YES，减少复杂图层合成 尽量使用不包含透明（alpha）通道的图片资源 尽量设置layer的大小值为整形值 很多情况下用户上传图片进行显示，可以让服务端处理圆角 使用代码手动生成圆角Image设置到要显示的View上，利用UIBezierPath（CoreGraphics框架）画出来圆角图片 总结文章中首先介绍了GPU的两种渲染方式，分别是当前屏幕渲染和离屏渲染，解释了为什么离屏渲染会引起UI性能问题。并且结合了iOS日常开发中，会触发离屏渲染的几种情形。最后针对会触发离屏渲染的几个要点问题，讲解了优化方案及实践思路，希望能帮助读者解决类似问题。 参考资料 iOS的离屏渲染 离屏渲染-Alibaba]]></content>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS中各种“锁”的理解及应用]]></title>
    <url>%2F2018%2F06%2F07%2FiOS%E4%B8%AD%E5%90%84%E7%A7%8D%E2%80%9C%E9%94%81%E2%80%9D%E7%9A%84%E7%90%86%E8%A7%A3%E5%8F%8A%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[前言通常在一般的iOS应用开发中会很少碰到使用“锁”的业务逻辑，但是在需要使用多线程技术，解决大多数场景写的业务逻辑时，会使用到线程锁来保证临界数据的读写安全性。当然，“锁”的概念在计算机科学及应用中也是举足轻重的，对于要写出高质量、高性能、安全可靠的代码来说，也是非常重要的。 预备知识 线程调度 计算机通常只有一个CPU,在任意时刻只能执行一条机器指令,每个线程只有获得CPU的使用权才能执行指令.所谓多线程的并发运行,其实是指从宏观上看,各个线程轮流获得CPU的使用权,分别执行各自的任务.在运行池中,会有多个处于就绪状态的线程在等待CPU,JAVA虚拟机的一项任务就是负责线程的调度,线程调度是指按照特定机制为多个线程分配CPU的使用权.线程调度有两种调度模式： 分时调度模型，分时调度模型是指让所有的线程轮流获得 CPU 的使用权，并且平均分配每个线程占用的 CPU 的时间片。 抢占式调度模型，指优先让可运行池中优先级高的线程占用 CPU，如果可运行池中的线程优先级相同，那么就随机选择一个线程，使其占用 CPU。处于运行状态的线程会一直运行，直至它不得不放弃 CPU 时间片轮转算法 时间片：（timeslice）是分时操作系统分配给每个正在运行的进程微观上的一段CPU时间（在抢占内核中是：从进程开始运行直到被抢占的时间）。现代操作系统（如：Windows、Linux、Mac OS X等）允许同时运行多个进程 —— 例如，你可以在打开音乐播放器听音乐的同时用浏览器浏览网页并下载文件。事实上，由于一台计算机通常只有一个CPU，所以永远不可能真正地同时运行多个任务。这些进程“看起来像”同时运行的，实则是轮番穿插地运行，由于时间片通常很短（在Linux上为5ms－800ms），用户不会感觉到。– 维基百科 时间片由操作系统内核的调度程序分配给每个进程。首先，内核会给每个进程分配相等的初始时间片，然后每个进程轮番地执行相应的时间，当所有进程都处于时间片耗尽的状态时，内核会重新为每个进程计算并分配时间片，如此往复。 分配算法：现代操作系统再管理普通线程时，通常采用时间片轮转算法，每个线程会被分配一段时间片，通常在 10-100 毫秒左右，当线程使用完自己的时间片之后j就被会操作系统挂起，放入等待队列中，等待下一次被分配时间片。 原子操作 狭义上的原子操作表示一条不可打断的操作，也就是说线程在执行操作过程中，不会被操作系统挂起，而是一定会执行完。在单处理器环境下，一条汇编指令显然是原子操作，因为中断也要通过指令来实现。 然而在多处理器的情况下，能够被多个处理器同时执行的操作任然算不上原子操作。因此，真正的原子操作必须由硬件提供支持，比如 x86 平台上如果在指令前面加上 “LOCK” 前缀，对应的机器码在执行时会把总线锁住，使得其他 CPU不能再执行相同操作，从而从硬件层面确保了操作的原子性。 这些非常底层的概念无需完全掌握，我们只要知道上述申请锁的过程，可以用一个原子性操作 test_and_set 来完成，它用伪代码可以这样表示: bool test_and_set (bool *target) &#123; bool rv = *target; *target = TRUE; return rv;&#125; 这段代码的作用是把 target 的值设置为 1，并返回原来的值。当然，在具体实现时，它通过一个原子性的指令来完成。 —— 参考bestswifter博客《深入理解iOS开发中的锁》 自旋锁和互斥锁 都属于CPU时间分片算法下的实现保护共享资源的一种机制。都实现互斥操作，加锁后仅允许一个访问者。区别在于自旋锁不会使线程进入wait状态，而通过轮训不停查看是否该自旋锁的持有者已经释放的锁；对应的，互斥锁在出现锁已经被占用的情况会进入wait状态，CPU会当即切换时间片。 参考资料《自旋锁和互斥锁的区别》：https://blog.csdn.net/susidian/article/details/51068858 各种锁的应用及性能对比下面讨论iOS开发中常见的几种锁。包括锁的简单介绍及使用，锁的特性及加解锁性能对比。业界大神YYKit的作者ibireme 已经在其博客中讨论了各种锁的性能，且做出一个速度由快至慢的排名进行对比。图示如下： 需要说明的是，加解锁速度不表示锁的效率，只表示加解锁操作在执行时的复杂程度，下文会通过具体的例子来解释。 OSSpinLock（自旋锁）文中指出，其中性能最好的OSSpinLock(自旋锁)，已经不再安全了，主要原因发生在低优先级线程拿到锁时，高优先级线程进入忙等(busy-wait)状态，消耗大量 CPU 时间，从而导致低优先级线程拿不到 CPU 时间，也就无法完成任务并释放锁。这种问题被称为优先级反转。 为什么忙等会导致低优先级线程拿不到时间片？这还得从操作系统的线程调度说起。 现代操作系统在管理普通线程时，通常采用时间片轮转算法(Round Robin，简称 RR)。每个线程会被分配一段时间片(quantum)，通常在 10-100 毫秒左右。当线程用完属于自己的时间片以后，就会被操作系统挂起，放入等待队列中，直到下一次被分配时间片。 实现原理 自旋锁的目的是为了确保临界区只有一个线程可以访问，它的使用可以用下面这段伪代码来描述: do &#123; Acquire Lock // 获取锁 Critical section // 临界区 Release Lock // 释放锁 Reminder section // 不需要锁保护的代码&#125; 在 Acquire Lock 这一步，我们申请加锁，目的是为了保护临界区(Critical Section) 中的代码不会被多个线程执行。 自旋锁的实现思路很简单，理论上来说只要定义一个全局变量，用来表示锁的可用情况即可，伪代码如下: bool lock = false; // 一开始没有锁上，任何线程都可以申请锁 do &#123; while(lock); // 如果 lock 为 true 就一直死循环，相当于申请锁 lock = true; // 挂上锁，这样别的线程就无法获得锁 Critical section // 临界区 lock = false; // 相当于释放锁，这样别的线程可以进入临界区 Reminder section // 不需要锁保护的代码 &#125; 这段代码存在一个问题: 如果一开始有多个线程同时执行 while 循环，他们都不会在这里卡住，而是继续执行，这样就无法保证锁的可靠性了。解决思路也很简单，只要确保申请锁的过程是原子操作即可。 至此，自旋锁的实现原理就很清楚了，在申请锁的过程中确保原子操作，代码如下： bool lock = false; // 一开始没有锁上，任何线程都可以申请锁 do &#123; while(test_and_set(&amp;lock); // test_and_set 是一个原子操作 Critical section // 临界区 lock = false; // 相当于释放锁，这样别的线程可以进入临界区 Reminder section // 不需要锁保护的代码 &#125; 如果临界区的执行时间过长，使用自旋锁不是个好主意。之前我们介绍过时间片轮转算法，线程在多种情况下会退出自己的时间片。其中一种是用完了时间片的时间，被操作系统强制抢占。除此以外，当线程进行 I/O 操作，或进入睡眠状态时，都会主动让出时间片。显然在 while 循环中，线程处于忙等状态，白白浪费 CPU 时间，最终因为超时被操作系统抢占时间片。如果临界区执行时间较长，比如是文件读写，这种忙等是毫无必要的。 自旋锁使用范例 // 需要导入的头文件#import &lt;libkern/OSAtomic.h&gt;#import &lt;os/lock.h&gt;#import &lt;AddressBook/AddressBook.h&gt;// 自旋锁 实现- (void)OSSpinLock &#123; if (@available(iOS 10.0, *)) &#123; // iOS 10以后解决了优先级反转问题 os_unfair_lock_t unfairLock = &amp;(OS_UNFAIR_LOCK_INIT); NSLog(@"线程1 准备上锁"); os_unfair_lock_lock(unfairLock); sleep(4); NSLog(@"线程1执行"); os_unfair_lock_unlock(unfairLock); NSLog(@"线程1 解锁成功"); &#125; else &#123; // 会造成优先级反转，不建议使用 __block OSSpinLock oslock = OS_SPINLOCK_INIT; //线程2 dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_LOW, 0), ^&#123; NSLog(@"线程2 befor lock"); OSSpinLockLock(&amp;oslock); NSLog(@"线程2执行"); sleep(3); OSSpinLockUnlock(&amp;oslock); NSLog(@"线程2 unlock"); &#125;); //线程1 dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0), ^&#123; NSLog(@"线程1 befor lock"); OSSpinLockLock(&amp;oslock); NSLog(@"线程1 sleep"); sleep(3); NSLog(@"线程1执行"); OSSpinLockUnlock(&amp;oslock); NSLog(@"线程1 unlock"); &#125;); // 可以看出不同的队列优先级，执行的顺序不同，优先级越高，越早被执行 &#125;&#125; dispatch_semaphore_t（信号量）信号量在GCD多线程技术中是一个重要的角色，在保证性能的情况下，可实现多线程同步功能，也可以通过初始化value=1，来实现加锁。 在实现加锁的过程中，如果线程1已经获取了锁，并在执行任务过程中，其他线程会被阻塞，直到线程1任务完成释放锁。 YY大神推荐使用信号量dispatch_semaphore作为自旋锁的替代方案。 实现原理 信号量 dispatch_semaphore_t 的实现原理，它最终会调用到 sem_wait 方法，这个方法在 glibc 中被实现如下: int sem_wait (sem_t *sem) &#123; int *futex = (int *) sem; if (atomic_decrement_if_positive (futex) &gt; 0) return 0; int err = lll_futex_wait (futex, 0); return -1;) 首先会把信号量的值减一，并判断是否大于零。如果大于零，说明不用等待，所以立刻返回。具体的等待操作在 lll_futex_wait 函数中实现，lll 是 low level lock 的简称。这个函数通过汇编代码实现，调用到 SYS_futex 这个系统调用，使线程进入睡眠状态，主动让出时间片，这个函数在互斥锁的实现中，也有可能被用到。 主动让出时间片并不总是代表效率高。让出时间片会导致操作系统切换到另一个线程，这种上下文切换通常需要 10 微秒左右，而且至少需要两次切换。如果等待时间很短，比如只有几个微秒，忙等就比线程睡眠更高效。 可以看到，自旋锁和信号量的实现都非常简单，这也是两者的加解锁耗时分别排在第一和第二的原因。再次强调，加解锁耗时不能准确反应出锁的效率(比如时间片切换就无法发生)，它只能从一定程度上衡量锁的实现复杂程度。 应用示例 // 创建sem ,value 设置为1dispatch_semaphore_t signal = dispatch_semaphore_create(1);// 设置超时时间5s，当超过5s会自动释放锁dispatch_time_t timeout = dispatch_time(DISPATCH_TIME_NOW, 5.0f * NSEC_PER_SEC); //线程1dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; NSLog(@"线程1 holding"); dispatch_semaphore_wait(signal, timeout); //signal 值 -1 NSLog(@"线程1 sleep"); sleep(4); NSLog(@"线程1"); dispatch_semaphore_signal(signal); //signal 值 +1 NSLog(@"线程1 post singal");&#125;); //线程2dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; NSLog(@"线程2 holding"); dispatch_semaphore_wait(signal, timeout); NSLog(@"线程2 sleep"); sleep(4); NSLog(@"线程2"); dispatch_semaphore_signal(signal); NSLog(@"线程2 post signal");&#125;);// 代码执行结果：class:AppDelegate+AppService.m line:162 msg:线程2 holdingclass:AppDelegate+AppService.m line:151 msg:线程1 holdingclass:AppDelegate+AppService.m line:153 msg:线程1 sleepclass:AppDelegate+AppService.m line:155 msg:线程1class:AppDelegate+AppService.m line:164 msg:线程2 sleepclass:AppDelegate+AppService.m line:157 msg:线程1 post singal Pthread_mutex（互斥锁）pthread 表示 POSIX thread，定义了一组跨平台的线程相关的 API，pthread_mutex 表示互斥锁。互斥锁的实现原理与信号量非常相似，不是使用忙等，而是阻塞线程并睡眠，需要进行上下文切换，性能不及信号量。 实现原理 互斥锁在申请锁时，调用了 pthread_mutex_lock 方法，它在不同的系统上实现各有不同，有时候它的内部是使用信号量来实现，即使不用信号量，也会调用到 lll_futex_wait 函数，从而导致线程休眠。 上文说到如果临界区很短，忙等的效率也许更高，所以在有些版本的实现中，会首先尝试一定次数(比如 1000 次)的 testandtest，这样可以在错误使用互斥锁时提高性能。 另外，由于 pthread_mutex 有多种类型，可以支持递归锁等，因此在申请加锁时，需要对锁的类型加以判断，这也就是为什么它和信号量的实现类似，但效率略低的原因。 常见用法 互斥锁的常见用法如下: #import &lt;pthread.h&gt; // 需要导入头文件pthread_mutexattr_t attr; pthread_mutexattr_init(&amp;attr); pthread_mutexattr_settype(&amp;attr, PTHREAD_MUTEX_NORMAL); // 定义锁的属性pthread_mutex_t mutex; pthread_mutex_init(&amp;mutex, &amp;attr) // 创建锁pthread_mutex_lock(&amp;mutex); // 申请锁 // 临界区pthread_mutex_unlock(&amp;mutex); // 释放锁 对于 pthread_mutex 来说，它的用法和之前没有太大的改变，比较重要的是锁的类型，可以有 PTHREAD_MUTEX_NORMAL、PTHREAD_MUTEX_ERRORCHECK、PTHREAD_MUTEX_RECURSIVE 等等，具体的特性就不做解释了，网上有很多相关资料。 一般情况下，一个线程只能申请一次锁，也只能在获得锁的情况下才能释放锁，多次申请锁或释放未获得的锁都会导致崩溃。假设在已经获得锁的情况下再次申请锁，线程会因为等待锁的释放而进入睡眠状态，因此就不可能再释放锁，从而导致死锁。 然而这种情况经常会发生，比如某个函数申请了锁，在临界区内又递归调用了自己。辛运的是 pthread_mutex 支持递归锁，也就是允许一个线程递归的申请锁，只要把 attr 的类型改成 PTHREAD_MUTEX_RECURSIVE 即可。 YTKNetworking 中就有使用这种锁方式： pthread_mutex_t lock; // 创建 lock// 宏定义，加解锁方法#define Lock() pthread_mutex_lock(&amp;_lock) #define Unlock() pthread_mutex_unlock(&amp;_lock)/* 使用范例 *///添加 request 到字典- (void)addRequestToRecord:(YTKBaseRequest *)request &#123; Lock(); _requestsRecord[@(request.requestTask.taskIdentifier)] = request; Unlock();&#125;//从字典中移除指定的 request- (void)removeRequestFromRecord:(YTKBaseRequest *)request &#123; Lock(); [_requestsRecord removeObjectForKey:@(request.requestTask.taskIdentifier)]; YTKLog(@"Request queue size = %zd", [_requestsRecord count]); Unlock();&#125; NSLockNSLock 是 Objective-C 以对象的形式暴露给开发者的一种锁，它的实现非常简单，通过宏，定义了 lock 方法: #define MLOCK \- (void) lock\&#123;\ int err = pthread_mutex_lock(&amp;_mutex);\ // 错误处理 ……&#125; NSLock 只是在内部封装了一个 pthread_mutex，属性为 PTHREAD_MUTEX_ERRORCHECK，它会损失一定性能换来错误提示。 这里使用宏定义的原因是，OC 内部还有其他几种锁，他们的 lock 方法都是一模一样，仅仅是内部 pthread_mutex 互斥锁的类型不同。通过宏定义，可以简化方法的定义。 NSLock 比 pthread_mutex 略慢的原因在于它需要经过方法调用，同时由于缓存的存在，多次方法调用不会对性能产生太大的影响。 应用范例 AFNetworking 中就是用的NSLock方式: @property (readwrite, nonatomic, strong) NSLock *lock; // 声明锁// 初始化锁self.lock = [[NSLock alloc] init];self.lock.name = AFURLSessionManagerLockName;// 应用- (void)removeDelegateForTask:(NSURLSessionTask *)task &#123; NSParameterAssert(task); AFURLSessionManagerTaskDelegate *delegate = [self delegateForTask:task]; [self.lock lock]; [delegate cleanUpProgressForTask:task]; [self removeNotificationObserverForTask:task]; [self.mutableTaskDelegatesKeyedByTaskIdentifier removeObjectForKey:@(task.taskIdentifier)]; [self.lock unlock];&#125; NSConditionNSCondition 的底层是通过条件变量(condition variable) pthread_cond_t 来实现的。条件变量有点像信号量，提供了线程阻塞与信号机制，因此可以用来阻塞某个线程，并等待某个数据就绪，随后唤醒线程，比如常见的生产者-消费者模式。 实现原理 NSCondition 其实是封装了一个互斥锁和条件变量， 它把前者的 lock 方法和后者的 wait/signal 统一在 NSCondition 对象中，暴露给使用者: - (void) signal &#123; pthread_cond_signal(&amp;_condition);&#125;// 其实这个函数是通过宏来定义的，展开后就是这样- (void) lock &#123; int err = pthread_mutex_lock(&amp;_mutex);&#125; 它的加解锁过程与 NSLock 几乎一致，理论上来说耗时也应该一样(实际测试也是如此)。在图中显示它耗时略长，我猜测有可能是测试者在每次加解锁的前后还附带了变量的初始化和销毁操作。 条件锁使用 很多介绍 pthread_cond_t 的文章都会提到，它需要与互斥锁配合使用: void consumer () &#123; // 消费者 pthread_mutex_lock(&amp;mutex); while (data == NULL) &#123; pthread_cond_wait(&amp;condition_variable_signal, &amp;mutex); // 等待数据 &#125; // --- 有新的数据，以下代码负责处理 ↓↓↓↓↓↓ // temp = data; // --- 有新的数据，以上代码负责处理 ↑↑↑↑↑↑ pthread_mutex_unlock(&amp;mutex);&#125;void producer () &#123; pthread_mutex_lock(&amp;mutex); // 生产数据 pthread_cond_signal(&amp;condition_variable_signal); // 发出信号给消费者，告诉他们有了新的数据 pthread_mutex_unlock(&amp;mutex);&#125; 自然我们会有疑问:“如果不用互斥锁，只用条件变量会有什么问题呢？”。问题在于，temp = data; 这段代码不是线程安全的，也许在你把 data 读出来以前，已经有别的线程修改了数据。因此我们需要保证消费者拿到的数据是线程安全的。 wait 方法除了会被 signal 方法唤醒，有时还会被虚假唤醒，所以需要这里 while 循环中的判断来做二次确认。 NSConditionLock（条件锁）NSConditionLock 借助 NSCondition 来实现，它的本质就是一个生产者-消费者模型。“条件被满足”可以理解为生产者提供了新的内容。NSConditionLock 的内部持有一个 NSCondition 对象，以及 _condition_value 属性，在初始化时就会对这个属性进行赋值: // 简化版代码- (id) initWithCondition: (NSInteger)value &#123; if (nil != (self = [super init])) &#123; _condition = [NSCondition new] _condition_value = value; &#125; return self;&#125; 它的 lockWhenCondition 方法其实就是消费者方法: - (void) lockWhenCondition: (NSInteger)value &#123; [_condition lock]; while (value != _condition_value) &#123; [_condition wait]; &#125;&#125; 对应的 unlockWhenCondition 方法则是生产者，使用了 broadcast 方法通知了所有的消费者: - (void) unlockWithCondition: (NSInteger)value &#123; _condition_value = value; [_condition broadcast]; [_condition unlock];&#125; NSRecursiveLock（递归锁）上文已经说过，递归锁也是通过 pthread_mutex_lock 函数来实现，在函数内部会判断锁的类型，如果显示是递归锁，就允许递归调用，仅仅将一个计数器加一，锁的释放过程也是同理。 NSRecursiveLock 与 NSLock 的区别在于内部封装的 pthread_mutex_t 对象的类型不同，前者的类型为 PTHREAD_MUTEX_RECURSIVE。 @synchronized（同步锁）这其实是一个 OC 层面的锁， 主要是通过牺牲性能换来语法上的简洁与可读。 我们知道 @synchronized 后面需要紧跟一个 OC 对象，它实际上是把这个对象当做锁来使用。这是通过一个哈希表来实现的，OC 在底层使用了一个互斥锁的数组(你可以理解为锁池)，通过对对象去哈希值来得到对应的互斥锁。 在 SDWebImage 中用的就是这种方式： - (void)cancel &#123; @synchronized (self) &#123; [self cancelInternal]; &#125;&#125; 总结文章梳理了在iOS开发中用到的各种锁，简单介绍了其实现原理、不同锁的应用场景和注意事项。希望对看到这篇文章的小伙伴有所帮助。 参考资料 https://blog.ibireme.com/2016/01/16/spinlock_is_unsafe_in_ios/ https://blog.csdn.net/susidian/article/details/51068858]]></content>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[对象、类、元类、isa指针之间的爱恨情仇]]></title>
    <url>%2F2018%2F05%2F28%2F%E5%AF%B9%E8%B1%A1%E3%80%81%E7%B1%BB%E3%80%81%E5%85%83%E7%B1%BB%E3%80%81isa%E6%8C%87%E9%92%88%E4%B9%8B%E9%97%B4%E7%9A%84%E7%88%B1%E6%81%A8%E6%83%85%E4%BB%87%2F</url>
    <content type="text"><![CDATA[前言在iOS开发中，对象、类的使用可以说是无处不在，伴随着整个项目的开发周期，也是程序的重要组成部分。但是在日常开发中，很难直观的见到元类、isa指针，那么它们究竟是谁，在开发中起着什么作用呢？下面我们就分别介绍下这几位亲兄弟的结构体定义，以及之间的关联关系。 类(class)的结构体定义类对象(Class)是由程序员定义并在运行时有编译器创建的，他没有自己的实例变量，这里需要注意的是类的成员变量和实例方法列表是属于实例对象的，但其存储于类对象当中。下图指出类的结构体定义： // An opaque type that represents an Objective-C class.typedef struct objc_class *Class;// OC1.0 class 结构体定义struct objc_class &#123; Class _Nonnull isa OBJC_ISA_AVAILABILITY;#if !__OBJC2__ Class _Nullable super_class OBJC2_UNAVAILABLE; const char * _Nonnull name OBJC2_UNAVAILABLE; long version OBJC2_UNAVAILABLE; long info OBJC2_UNAVAILABLE; long instance_size OBJC2_UNAVAILABLE; struct objc_ivar_list * _Nullable ivars OBJC2_UNAVAILABLE; struct objc_method_list * _Nullable * _Nullable methodLists OBJC2_UNAVAILABLE; struct objc_cache * _Nonnull cache OBJC2_UNAVAILABLE; struct objc_protocol_list * _Nullable protocols OBJC2_UNAVAILABLE;#endif&#125; OBJC2_UNAVAILABLE;/* Use `Class` instead of `struct objc_class *` */// OC2.0 class 结构体定义，我们注意到上面的定义后面的标识符OBJC2_UNAVAILABLE，意思是已经不适用ObjC2.0了，现在ObjC2.0 对objc_class的定义如下：struct objc_class : objc_object &#123; isa_t isa; Class superclass; cache_t cache; class_data_bits_t bits;&#125;; 我们在objc/objc.h 源码文件中找到了Class 类结构体的定义，下面我们分析并说明一下几个关键的结构体成员： isa： 是一个不能为空(null)的Class对象，它指向该类的元类(meta class)。 super_class：是一个可以为空的Class对象，它指向当前类的父类。会一直追溯到根类(NSObject)，那么根类(NSObject)的父类是指向谁的呢？通过分析根类的父类是指向空(nil)的，这样也就可以解释为什么super_class 是可以为空的。 ivars：是实例变量列表，保存着该类的所有实例变量 methodLists：是方法列表，保存着实例方法和类方法 protocols：是协议列表，保存该类的协议方法 cache：是一个缓存，用于缓存最近使用过的方法。 … 上面我们根据Class 类的结构体，分析内部成员的作用及含义。想必大家已经对Class类的内部结构有了一个初步的认识。如果想再深入理解isa和super_class在不同情况下都是如何进行指向的，我们再看下面的一个图示来逐步分析： 首先，注意图中的注释，实线的箭头(→ superclass)代表父类指针，虚线的箭头(→isa)代表isa指针，从上至下的深色方框依次代表：根类-&gt; 父类-&gt; 子类，下面咱们从上至下层层分析上图的含义： 第一层： isa指针： 根类的实例对象(instance Of Root class)的isa指向根类(Root class)，根类的isa指针指向根元类(Root meta class)，根元类的isa指向它本身。 superclass指针：根类(Root class)的superclass指向nil，根元类的父类指向根类。 第二层： isa指针：父类的实例对象(instance of superclass)的isa指向父类（superclass），父类的isa指向父元类，父元类的isa指向根元类。 superclass指针：父类的superclass指向根类，父元类的superclass指向根元类。 第三层： isa指针：子类实例对象（instance of subclass）的isa指向子类，子类的isa指向子元类，子元类的isa指向根元类。 superclass指针：子类的superclass指向父类，子元类的superclass指向父元类。 动态创建一个类 // 创建一个新类和元类Class objc_allocateClassPair ( Class superclass, const char *name, size_t extraBytes ); //如果创建的是root class，则superclass为Nil。extraBytes通常为0// 销毁一个类及其相关联的类void objc_disposeClassPair ( Class cls ); //在运行中还存在或存在子类实例，就不能够调用这个。// 在应用中注册由objc_allocateClassPair创建的类void objc_registerClassPair ( Class cls ); //创建了新类后，然后使用class_addMethod，class_addIvar函数为新类添加方法，实例变量和属性后再调用这个来注册类，再之后就能够用了。 对象(object)的结构体定义// Represents an instance of a class.struct objc_object &#123; Class _Nonnull isa OBJC_ISA_AVAILABILITY;&#125;; 我们可以看到，objc_object代表一个实例对象，它的结构体内部有一个不为空的isa指针，isa是指向对象所属类的指针。另外，我们常用的id类型是一个指向objc_object结构体的指针，它可以指向任意一个oc对象。 // A pointer to an instance of a class.typedef struct objc_object &#123; Class isa;&#125; *id; 元类(Meta class)的结构体定义元类(Meta class) 就是类对象的类，每个类都有自己的元类，也就是objc_class结构体里面的isa指针所指向的类。元类用来表述类对象本身所具备的元数据， 因为元类中存储着类对象的方法列表，即类方法。 下面将介绍实例对象、类、元类之间的关系，如下图所示： 当向对象发消息时，runtime会在这个对象所属类的实例方法列表中查找消息对应的方法实现(IMP)。但当向类发送消息时，runtime就会在这个类的元类(meta class)方法列表里查找。所有的元类(meta class)，包括根类(Root class)，父类(Superclass)，子类(Subclass)的isa最终都指向根类(Root class)的元类(meta class)，这样能够形成一个闭环。可以总结为： 当发送消息给实例对象时，runtime函数会在此实例对象所属类的实例方法列表中查找方法实现(IMP)并调用，此为实例方法调用。 当发送消息给类对象时，runtime函数会在此实例对象所属类的元类的方法列表中查找方法实例(IMP)并调用，此为类方法调用。 延伸扩展方法的调用流程 OC的方法调用本质上是给对象发送消息，即调用runtime的消息发送函数，如下所示： /* param: self(id) 接收消息的对象， param: op(SEL) 发送的消息，即方法签名(@selector(method_name))*/id _Nullable objc_msgSend(id _Nullable self, SEL _Nonnull op, ...) 通过对objc_msgSend()函数的源码分析，总结以下调用流程： 检查 selector 是否需要忽略 检查 target 是否为 nil，如果是 nil 就直接 cleanup，然后 return 在 target 的 Class 中根据 selector 去找 IMP 寻找IMP的流程 在当前 class 的方法缓存里寻找（cache methodLists） 找到了跳到对应的方法实现，没找到继续往下执行 从当前 class 的 方法列表里查找（methodLists），找到了添加到缓存列表里，然后跳转到对应的方法实现；没找到继续往下执行 从 superClass 的缓存列表和方法列表里查找，直到找到基类为止 以上步骤还找不到 IMP，则进入消息动态处理和消息转发(objc_msgForward)流程，详见这篇文章 我们从objc-class.mm 官方源码中找到了寻找IMP的实现过程，如下： IMP class_getMethodImplementation(Class cls, SEL sel)&#123;IMP imp;if (!cls || !sel) return nil;imp = lookUpImpOrNil(cls, sel, nil,YES/*initialize*/, YES/*cache*/, YES/*resolver*/);// Translate forwarding function to C-callable external versionif (!imp) &#123;return _objc_msgForward;&#125;return imp;&#125; 参考资料 http://limbank.com/2018/03/09/post18/ https://tingxins.com/2017/05/metaclass-class-relationship/]]></content>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
</search>