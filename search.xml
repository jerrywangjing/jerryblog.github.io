<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[iOS中各种“锁”的理解及应用]]></title>
    <url>%2F2019%2F04%2F07%2FiOS%E4%B8%AD%E5%90%84%E7%A7%8D%E2%80%9C%E9%94%81%E2%80%9D%E7%9A%84%E7%90%86%E8%A7%A3%E5%8F%8A%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[前言通常在一般的iOS应用开发中会很少碰到使用“锁”的业务逻辑，但是在需要使用多线程技术，解决大多数场景写的业务逻辑时，会使用到线程锁来保证临界数据的读写安全性。当然，“锁”的概念在计算机科学及应用中也是举足轻重的，对于要写出高质量、高性能、安全可靠的代码来说，也是非常重要的。 预备知识 线程调度 计算机通常只有一个CPU,在任意时刻只能执行一条机器指令,每个线程只有获得CPU的使用权才能执行指令.所谓多线程的并发运行,其实是指从宏观上看,各个线程轮流获得CPU的使用权,分别执行各自的任务.在运行池中,会有多个处于就绪状态的线程在等待CPU,JAVA虚拟机的一项任务就是负责线程的调度,线程调度是指按照特定机制为多个线程分配CPU的使用权.线程调度有两种调度模式： 分时调度模型，分时调度模型是指让所有的线程轮流获得 CPU 的使用权，并且平均分配每个线程占用的 CPU 的时间片。 抢占式调度模型，指优先让可运行池中优先级高的线程占用 CPU，如果可运行池中的线程优先级相同，那么就随机选择一个线程，使其占用 CPU。处于运行状态的线程会一直运行，直至它不得不放弃 CPU 时间片轮转算法 时间片：（timeslice）是分时操作系统分配给每个正在运行的进程微观上的一段CPU时间（在抢占内核中是：从进程开始运行直到被抢占的时间）。现代操作系统（如：Windows、Linux、Mac OS X等）允许同时运行多个进程 —— 例如，你可以在打开音乐播放器听音乐的同时用浏览器浏览网页并下载文件。事实上，由于一台计算机通常只有一个CPU，所以永远不可能真正地同时运行多个任务。这些进程“看起来像”同时运行的，实则是轮番穿插地运行，由于时间片通常很短（在Linux上为5ms－800ms），用户不会感觉到。– 维基百科 时间片由操作系统内核的调度程序分配给每个进程。首先，内核会给每个进程分配相等的初始时间片，然后每个进程轮番地执行相应的时间，当所有进程都处于时间片耗尽的状态时，内核会重新为每个进程计算并分配时间片，如此往复。 分配算法：现代操作系统再管理普通线程时，通常采用时间片轮转算法，每个线程会被分配一段时间片，通常在 10-100 毫秒左右，当线程使用完自己的时间片之后j就被会操作系统挂起，放入等待队列中，等待下一次被分配时间片。 原子操作 狭义上的原子操作表示一条不可打断的操作，也就是说线程在执行操作过程中，不会被操作系统挂起，而是一定会执行完。在单处理器环境下，一条汇编指令显然是原子操作，因为中断也要通过指令来实现。 然而在多处理器的情况下，能够被多个处理器同时执行的操作任然算不上原子操作。因此，真正的原子操作必须由硬件提供支持，比如 x86 平台上如果在指令前面加上 “LOCK” 前缀，对应的机器码在执行时会把总线锁住，使得其他 CPU不能再执行相同操作，从而从硬件层面确保了操作的原子性。 这些非常底层的概念无需完全掌握，我们只要知道上述申请锁的过程，可以用一个原子性操作 test_and_set 来完成，它用伪代码可以这样表示: bool test_and_set (bool *target) &#123; bool rv = *target; *target = TRUE; return rv;&#125; 这段代码的作用是把 target 的值设置为 1，并返回原来的值。当然，在具体实现时，它通过一个原子性的指令来完成。 —— 参考bestswifter博客《深入理解iOS开发中的锁》 自旋锁和互斥锁 都属于CPU时间分片算法下的实现保护共享资源的一种机制。都实现互斥操作，加锁后仅允许一个访问者。区别在于自旋锁不会使线程进入wait状态，而通过轮训不停查看是否该自旋锁的持有者已经释放的锁；对应的，互斥锁在出现锁已经被占用的情况会进入wait状态，CPU会当即切换时间片。 参考资料《自旋锁和互斥锁的区别》：https://blog.csdn.net/susidian/article/details/51068858 各种锁的应用及性能对比下面讨论iOS开发中常见的几种锁。包括锁的简单介绍及使用，锁的特性及加解锁性能对比。业界大神YYKit的作者ibireme 已经在其博客中讨论了各种锁的性能，且做出一个速度由快至慢的排名进行对比。图示如下： 需要说明的是，加解锁速度不表示锁的效率，只表示加解锁操作在执行时的复杂程度，下文会通过具体的例子来解释。 OSSpinLock（自旋锁）文中指出，其中性能最好的OSSpinLock(自旋锁)，已经不再安全了，主要原因发生在低优先级线程拿到锁时，高优先级线程进入忙等(busy-wait)状态，消耗大量 CPU 时间，从而导致低优先级线程拿不到 CPU 时间，也就无法完成任务并释放锁。这种问题被称为优先级反转。 为什么忙等会导致低优先级线程拿不到时间片？这还得从操作系统的线程调度说起。 现代操作系统在管理普通线程时，通常采用时间片轮转算法(Round Robin，简称 RR)。每个线程会被分配一段时间片(quantum)，通常在 10-100 毫秒左右。当线程用完属于自己的时间片以后，就会被操作系统挂起，放入等待队列中，直到下一次被分配时间片。 实现原理 自旋锁的目的是为了确保临界区只有一个线程可以访问，它的使用可以用下面这段伪代码来描述: do &#123; Acquire Lock // 获取锁 Critical section // 临界区 Release Lock // 释放锁 Reminder section // 不需要锁保护的代码&#125; 在 Acquire Lock 这一步，我们申请加锁，目的是为了保护临界区(Critical Section) 中的代码不会被多个线程执行。 自旋锁的实现思路很简单，理论上来说只要定义一个全局变量，用来表示锁的可用情况即可，伪代码如下: bool lock = false; // 一开始没有锁上，任何线程都可以申请锁 do &#123; while(lock); // 如果 lock 为 true 就一直死循环，相当于申请锁 lock = true; // 挂上锁，这样别的线程就无法获得锁 Critical section // 临界区 lock = false; // 相当于释放锁，这样别的线程可以进入临界区 Reminder section // 不需要锁保护的代码 &#125; 这段代码存在一个问题: 如果一开始有多个线程同时执行 while 循环，他们都不会在这里卡住，而是继续执行，这样就无法保证锁的可靠性了。解决思路也很简单，只要确保申请锁的过程是原子操作即可。 至此，自旋锁的实现原理就很清楚了，在申请锁的过程中确保原子操作，代码如下： bool lock = false; // 一开始没有锁上，任何线程都可以申请锁 do &#123; while(test_and_set(&amp;lock); // test_and_set 是一个原子操作 Critical section // 临界区 lock = false; // 相当于释放锁，这样别的线程可以进入临界区 Reminder section // 不需要锁保护的代码 &#125; 如果临界区的执行时间过长，使用自旋锁不是个好主意。之前我们介绍过时间片轮转算法，线程在多种情况下会退出自己的时间片。其中一种是用完了时间片的时间，被操作系统强制抢占。除此以外，当线程进行 I/O 操作，或进入睡眠状态时，都会主动让出时间片。显然在 while 循环中，线程处于忙等状态，白白浪费 CPU 时间，最终因为超时被操作系统抢占时间片。如果临界区执行时间较长，比如是文件读写，这种忙等是毫无必要的。 自旋锁使用范例 // 需要导入的头文件#import &lt;libkern/OSAtomic.h&gt;#import &lt;os/lock.h&gt;#import &lt;AddressBook/AddressBook.h&gt;// 自旋锁 实现- (void)OSSpinLock &#123; if (@available(iOS 10.0, *)) &#123; // iOS 10以后解决了优先级反转问题 os_unfair_lock_t unfairLock = &amp;(OS_UNFAIR_LOCK_INIT); NSLog(@"线程1 准备上锁"); os_unfair_lock_lock(unfairLock); sleep(4); NSLog(@"线程1执行"); os_unfair_lock_unlock(unfairLock); NSLog(@"线程1 解锁成功"); &#125; else &#123; // 会造成优先级反转，不建议使用 __block OSSpinLock oslock = OS_SPINLOCK_INIT; //线程2 dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_LOW, 0), ^&#123; NSLog(@"线程2 befor lock"); OSSpinLockLock(&amp;oslock); NSLog(@"线程2执行"); sleep(3); OSSpinLockUnlock(&amp;oslock); NSLog(@"线程2 unlock"); &#125;); //线程1 dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0), ^&#123; NSLog(@"线程1 befor lock"); OSSpinLockLock(&amp;oslock); NSLog(@"线程1 sleep"); sleep(3); NSLog(@"线程1执行"); OSSpinLockUnlock(&amp;oslock); NSLog(@"线程1 unlock"); &#125;); // 可以看出不同的队列优先级，执行的顺序不同，优先级越高，越早被执行 &#125;&#125; dispatch_semaphore_t（信号量）信号量在GCD多线程技术中是一个重要的角色，在保证性能的情况下，可实现多线程同步功能，也可以通过初始化value=1，来实现加锁。 在实现加锁的过程中，如果线程1已经获取了锁，并在执行任务过程中，其他线程会被阻塞，直到线程1任务完成释放锁。 YY大神推荐使用信号量dispatch_semaphore作为自旋锁的替代方案。 实现原理 信号量 dispatch_semaphore_t 的实现原理，它最终会调用到 sem_wait 方法，这个方法在 glibc 中被实现如下: int sem_wait (sem_t *sem) &#123; int *futex = (int *) sem; if (atomic_decrement_if_positive (futex) &gt; 0) return 0; int err = lll_futex_wait (futex, 0); return -1;) 首先会把信号量的值减一，并判断是否大于零。如果大于零，说明不用等待，所以立刻返回。具体的等待操作在 lll_futex_wait 函数中实现，lll 是 low level lock 的简称。这个函数通过汇编代码实现，调用到 SYS_futex 这个系统调用，使线程进入睡眠状态，主动让出时间片，这个函数在互斥锁的实现中，也有可能被用到。 主动让出时间片并不总是代表效率高。让出时间片会导致操作系统切换到另一个线程，这种上下文切换通常需要 10 微秒左右，而且至少需要两次切换。如果等待时间很短，比如只有几个微秒，忙等就比线程睡眠更高效。 可以看到，自旋锁和信号量的实现都非常简单，这也是两者的加解锁耗时分别排在第一和第二的原因。再次强调，加解锁耗时不能准确反应出锁的效率(比如时间片切换就无法发生)，它只能从一定程度上衡量锁的实现复杂程度。 应用示例 // 创建sem ,value 设置为1dispatch_semaphore_t signal = dispatch_semaphore_create(1);// 设置超时时间5s，当超过5s会自动释放锁dispatch_time_t timeout = dispatch_time(DISPATCH_TIME_NOW, 5.0f * NSEC_PER_SEC); //线程1dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; NSLog(@"线程1 holding"); dispatch_semaphore_wait(signal, timeout); //signal 值 -1 NSLog(@"线程1 sleep"); sleep(4); NSLog(@"线程1"); dispatch_semaphore_signal(signal); //signal 值 +1 NSLog(@"线程1 post singal");&#125;); //线程2dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; NSLog(@"线程2 holding"); dispatch_semaphore_wait(signal, timeout); NSLog(@"线程2 sleep"); sleep(4); NSLog(@"线程2"); dispatch_semaphore_signal(signal); NSLog(@"线程2 post signal");&#125;);// 代码执行结果：class:AppDelegate+AppService.m line:162 msg:线程2 holdingclass:AppDelegate+AppService.m line:151 msg:线程1 holdingclass:AppDelegate+AppService.m line:153 msg:线程1 sleepclass:AppDelegate+AppService.m line:155 msg:线程1class:AppDelegate+AppService.m line:164 msg:线程2 sleepclass:AppDelegate+AppService.m line:157 msg:线程1 post singal Pthread_mutex（互斥锁）pthread 表示 POSIX thread，定义了一组跨平台的线程相关的 API，pthread_mutex 表示互斥锁。互斥锁的实现原理与信号量非常相似，不是使用忙等，而是阻塞线程并睡眠，需要进行上下文切换，性能不及信号量。 实现原理 互斥锁在申请锁时，调用了 pthread_mutex_lock 方法，它在不同的系统上实现各有不同，有时候它的内部是使用信号量来实现，即使不用信号量，也会调用到 lll_futex_wait 函数，从而导致线程休眠。 上文说到如果临界区很短，忙等的效率也许更高，所以在有些版本的实现中，会首先尝试一定次数(比如 1000 次)的 testandtest，这样可以在错误使用互斥锁时提高性能。 另外，由于 pthread_mutex 有多种类型，可以支持递归锁等，因此在申请加锁时，需要对锁的类型加以判断，这也就是为什么它和信号量的实现类似，但效率略低的原因。 常见用法 互斥锁的常见用法如下: #import &lt;pthread.h&gt; // 需要导入头文件pthread_mutexattr_t attr; pthread_mutexattr_init(&amp;attr); pthread_mutexattr_settype(&amp;attr, PTHREAD_MUTEX_NORMAL); // 定义锁的属性pthread_mutex_t mutex; pthread_mutex_init(&amp;mutex, &amp;attr) // 创建锁pthread_mutex_lock(&amp;mutex); // 申请锁 // 临界区pthread_mutex_unlock(&amp;mutex); // 释放锁 对于 pthread_mutex 来说，它的用法和之前没有太大的改变，比较重要的是锁的类型，可以有 PTHREAD_MUTEX_NORMAL、PTHREAD_MUTEX_ERRORCHECK、PTHREAD_MUTEX_RECURSIVE 等等，具体的特性就不做解释了，网上有很多相关资料。 一般情况下，一个线程只能申请一次锁，也只能在获得锁的情况下才能释放锁，多次申请锁或释放未获得的锁都会导致崩溃。假设在已经获得锁的情况下再次申请锁，线程会因为等待锁的释放而进入睡眠状态，因此就不可能再释放锁，从而导致死锁。 然而这种情况经常会发生，比如某个函数申请了锁，在临界区内又递归调用了自己。辛运的是 pthread_mutex 支持递归锁，也就是允许一个线程递归的申请锁，只要把 attr 的类型改成 PTHREAD_MUTEX_RECURSIVE 即可。 YTKNetworking 中就有使用这种锁方式： pthread_mutex_t lock; // 创建 lock// 宏定义，加解锁方法#define Lock() pthread_mutex_lock(&amp;_lock) #define Unlock() pthread_mutex_unlock(&amp;_lock)/* 使用范例 *///添加 request 到字典- (void)addRequestToRecord:(YTKBaseRequest *)request &#123; Lock(); _requestsRecord[@(request.requestTask.taskIdentifier)] = request; Unlock();&#125;//从字典中移除指定的 request- (void)removeRequestFromRecord:(YTKBaseRequest *)request &#123; Lock(); [_requestsRecord removeObjectForKey:@(request.requestTask.taskIdentifier)]; YTKLog(@"Request queue size = %zd", [_requestsRecord count]); Unlock();&#125; NSLockNSLock 是 Objective-C 以对象的形式暴露给开发者的一种锁，它的实现非常简单，通过宏，定义了 lock 方法: #define MLOCK \- (void) lock\&#123;\ int err = pthread_mutex_lock(&amp;_mutex);\ // 错误处理 ……&#125; NSLock 只是在内部封装了一个 pthread_mutex，属性为 PTHREAD_MUTEX_ERRORCHECK，它会损失一定性能换来错误提示。 这里使用宏定义的原因是，OC 内部还有其他几种锁，他们的 lock 方法都是一模一样，仅仅是内部 pthread_mutex 互斥锁的类型不同。通过宏定义，可以简化方法的定义。 NSLock 比 pthread_mutex 略慢的原因在于它需要经过方法调用，同时由于缓存的存在，多次方法调用不会对性能产生太大的影响。 应用范例 AFNetworking 中就是用的NSLock方式: @property (readwrite, nonatomic, strong) NSLock *lock; // 声明锁// 初始化锁self.lock = [[NSLock alloc] init];self.lock.name = AFURLSessionManagerLockName;// 应用- (void)removeDelegateForTask:(NSURLSessionTask *)task &#123; NSParameterAssert(task); AFURLSessionManagerTaskDelegate *delegate = [self delegateForTask:task]; [self.lock lock]; [delegate cleanUpProgressForTask:task]; [self removeNotificationObserverForTask:task]; [self.mutableTaskDelegatesKeyedByTaskIdentifier removeObjectForKey:@(task.taskIdentifier)]; [self.lock unlock];&#125; NSConditionNSCondition 的底层是通过条件变量(condition variable) pthread_cond_t 来实现的。条件变量有点像信号量，提供了线程阻塞与信号机制，因此可以用来阻塞某个线程，并等待某个数据就绪，随后唤醒线程，比如常见的生产者-消费者模式。 实现原理 NSCondition 其实是封装了一个互斥锁和条件变量， 它把前者的 lock 方法和后者的 wait/signal 统一在 NSCondition 对象中，暴露给使用者: - (void) signal &#123; pthread_cond_signal(&amp;_condition);&#125;// 其实这个函数是通过宏来定义的，展开后就是这样- (void) lock &#123; int err = pthread_mutex_lock(&amp;_mutex);&#125; 它的加解锁过程与 NSLock 几乎一致，理论上来说耗时也应该一样(实际测试也是如此)。在图中显示它耗时略长，我猜测有可能是测试者在每次加解锁的前后还附带了变量的初始化和销毁操作。 条件锁使用 很多介绍 pthread_cond_t 的文章都会提到，它需要与互斥锁配合使用: void consumer () &#123; // 消费者 pthread_mutex_lock(&amp;mutex); while (data == NULL) &#123; pthread_cond_wait(&amp;condition_variable_signal, &amp;mutex); // 等待数据 &#125; // --- 有新的数据，以下代码负责处理 ↓↓↓↓↓↓ // temp = data; // --- 有新的数据，以上代码负责处理 ↑↑↑↑↑↑ pthread_mutex_unlock(&amp;mutex);&#125;void producer () &#123; pthread_mutex_lock(&amp;mutex); // 生产数据 pthread_cond_signal(&amp;condition_variable_signal); // 发出信号给消费者，告诉他们有了新的数据 pthread_mutex_unlock(&amp;mutex);&#125; 自然我们会有疑问:“如果不用互斥锁，只用条件变量会有什么问题呢？”。问题在于，temp = data; 这段代码不是线程安全的，也许在你把 data 读出来以前，已经有别的线程修改了数据。因此我们需要保证消费者拿到的数据是线程安全的。 wait 方法除了会被 signal 方法唤醒，有时还会被虚假唤醒，所以需要这里 while 循环中的判断来做二次确认。 NSConditionLock（条件锁）NSConditionLock 借助 NSCondition 来实现，它的本质就是一个生产者-消费者模型。“条件被满足”可以理解为生产者提供了新的内容。NSConditionLock 的内部持有一个 NSCondition 对象，以及 _condition_value 属性，在初始化时就会对这个属性进行赋值: // 简化版代码- (id) initWithCondition: (NSInteger)value &#123; if (nil != (self = [super init])) &#123; _condition = [NSCondition new] _condition_value = value; &#125; return self;&#125; 它的 lockWhenCondition 方法其实就是消费者方法: - (void) lockWhenCondition: (NSInteger)value &#123; [_condition lock]; while (value != _condition_value) &#123; [_condition wait]; &#125;&#125; 对应的 unlockWhenCondition 方法则是生产者，使用了 broadcast 方法通知了所有的消费者: - (void) unlockWithCondition: (NSInteger)value &#123; _condition_value = value; [_condition broadcast]; [_condition unlock];&#125; NSRecursiveLock（递归锁）上文已经说过，递归锁也是通过 pthread_mutex_lock 函数来实现，在函数内部会判断锁的类型，如果显示是递归锁，就允许递归调用，仅仅将一个计数器加一，锁的释放过程也是同理。 NSRecursiveLock 与 NSLock 的区别在于内部封装的 pthread_mutex_t 对象的类型不同，前者的类型为 PTHREAD_MUTEX_RECURSIVE。 @synchronized（同步锁）这其实是一个 OC 层面的锁， 主要是通过牺牲性能换来语法上的简洁与可读。 我们知道 @synchronized 后面需要紧跟一个 OC 对象，它实际上是把这个对象当做锁来使用。这是通过一个哈希表来实现的，OC 在底层使用了一个互斥锁的数组(你可以理解为锁池)，通过对对象去哈希值来得到对应的互斥锁。 在 SDWebImage 中用的就是这种方式： - (void)cancel &#123; @synchronized (self) &#123; [self cancelInternal]; &#125;&#125; 总结文章梳理了在iOS开发中用到的各种锁，简单介绍了其实现原理、不同锁的应用场景和注意事项。希望对看到这篇文章的小伙伴有所帮助。 参考资料 https://blog.ibireme.com/2016/01/16/spinlock_is_unsafe_in_ios/ https://blog.csdn.net/susidian/article/details/51068858]]></content>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS代码混淆之编译优化]]></title>
    <url>%2F2019%2F03%2F10%2FiOS%E4%BB%A3%E7%A0%81%E6%B7%B7%E6%B7%86%E4%B9%8B%E7%BC%96%E8%AF%91%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[这是iOS代码混淆系列文章的最后一篇，前两篇可以点击下方链接查看 iOS代码混淆之方法名替换 iOS代码混淆之资源替换 前言前2篇文章已近讲了对于函数名的混淆，对项目中关键信息、资源文件的修改等相关混淆手段。但是，仅仅做到这几点就能万事大吉吗，黑客仍然可以通过分析代码逻辑或伪装代码来寻找程序漏洞，那么还有其他更坚固可靠的混淆方式呢，接下来就介绍下编译器级别的加固混淆方案。 iOS编译原理iOS 开发中 Objective-C 和 Swift 都用的是 Clang / LLVM 来编译的。Clang是作为编译前端，LLVM做为编译后端，共同完成了iOS项目代码的编译阶段。 Clang(编译前端)Clang 是 LLVM 的子项目，是 C，C++ 和 Objective-C 编译器，目的是提供惊人的快速编译，比 GCC 快3倍，其中的 clang static analyzer 主要是进行语法分析，语义分析和生成中间代码，当然这个过程会对代码进行检查，出错的和需要警告的会标注出来。 LLVM(编译后端)LLVM是一个模块化和可重用的编译器和工具链技术的集合，LLVM 核心库提供一个优化器，对流行的 CPU 做代码生成支持。LLVM 比较有特色的一点是它能提供一种代码编写良好的中间表示 IR，这意味着它可以作为多种语言的后端，这样就能够提供语言无关的优化同时还能够方便的针对多种 CPU 的代码生成。 HikariHikari 是一个基于 Obfuscator-LLVM 的改进，增加了一些额外的自定义构建通道，更简单易用，结合使用文档，可以快速体验编译级别的代码加固效果。 OLLVM 是瑞士西北应用科技大学安全实验室于2010年6月份发起的一个项目，该项目旨在提供一套开源的针对 LLVM 的代码混淆工具，以增加对逆向工程的难度。目前，OLLVM已经支持LLVM8.0版本。 安装 在这里下载最新release版的pkg文件双击安装 安装完成后，重启Xcode就可以在Xcode-&gt; Toolchains -&gt; Hikari 中看到已经有了编译器选项。 使用然后在 Build Settings -&gt; Other C Flags 中加入混淆标记 -mllvm -enable-bcfobf 启用伪控制流 -mllvm -enable-cffobf 启用控制流平坦化-mllvm -enable-splitobf 启用基本块分割 -mllvm -enable-subobf 启用指令替换 -mllvm -enable-acdobf 启用反class-dump -mllvm -enable-indibran 启用基于寄存器的相对跳转，配合其他加固可以彻底破坏IDA/Hopper的伪代码(俗称F5) -mllvm -enable-strcry 启用字符串加密 -mllvm -enable-funcwra 启用函数封装-mllvm -enable-allobf 依次性启用上述所有标记 修改Xcode 相关配置，得到混淆效果。 选择Xcode -&gt; Toolchains -&gt; Hikari 将混淆工具和项目关联 将所有与要运行的 target 相关的 target（包括pod进来的库），在BuildSetting中修改Enable Index-While-Building 的值改为 NO。 修该BuildSetting 中的Optimization Level 的值为 None[-O0] 重新编译项目即可。 可能遇到的问题 编译过程中报错，内容如下： Undefined symbols for architecture arm64: "___isOSVersionAtLeast", referenced from: -[MyLayoutPos posNumVal] in MyLayoutPos.o -[MyLayoutViewSizeClass myLayoutTopPadding] in MyLayoutSizeClass.o -[MyLayoutViewSizeClass myLayoutBottomPadding] in MyLayoutSizeClass.o -[MyLayoutViewSizeClass myLayoutLeadingPadding] in MyLayoutSizeClass.o -[MyLayoutViewSizeClass myLayoutTrailingPadding] in MyLayoutSizeClass.o _HikariFunctionWrapper.7182 in MyLayoutSizeClass.o _HikariFunctionWrapper.7188 in MyLayoutSizeClass.o ...ld: symbol(s) not found for architecture arm64clang-7: error: linker command failed with exit code 1 (use -v to see invocation) &quot;___isOSVersionAtLeast&quot;符号在arm64架构下找不到，根据以往的经验，出现这种错误的时候一般都是没有导入相关动态库(.Framework)，或静态库(.a)等造成的。庆幸的是已经有人在GitHub上提交了issues并给出了解决方案： 作者的回答：You probably need to explicitly link to clang-rt, available in your LLVM Toolchain directorySorry I mean clang-rt, at Hikari.xctoolchain/usr/lib/clang/10.0.0/lib/darwin/libclang_rt.ios.a (or macOS suffix) 意思是说：可能是缺少某个编译器库造成的，需要手动将这个库添加到Xcode的Linked Frameworks andLibraries动态链接库目录中。并说明了此库所在的目录Hikari.xctoolchain/usr/lib/clang/10.0.0/lib/darwin/libclang_rt.ios.a，意思是在Hikari编译器的子目录中找到文件libclang_rt.ios.a，并将他引入到Xcode项目中即可。查找路径顺序如下： 打开Show in Finder 定位到Hikari的安装目录，然后按照此路径usr/lib/clang/10.0.0/lib/darwin/libclang_rt.ios.a找到libclang_rt.ios.a文件，添加到Xcode的链接库中即可。 使用Hikari编译后，Archive 打包后，需要上传App Store 时可能会出现 “App Store” 按钮消失的问题，Archives页面右下角会出现一个提示字符： “App Store distribution requires an Xcode Default Toolchain” 意思是：App Store 发布版需要使用Xcode 默认的Toolchain (编译工具) 如下图所示： 出现这个问题是因为，我们使用了Hikari编译器 Archive的包，所以需要想办法去除这个警告即可。在Hikari的wiki文档中，我们发现作者在AppStore Guideline 安装指南中已经说明了解决方案： Alternatively, you could use Hikari’s toolchain to build normally then remove DefaultToolchainOverrideInfo from the IPA’s Info.plist 只需要在Arichive 包中的Info.plist 中找到这个值”DefaultToolchainOverrideInfo” 删除即可。可以看出此字段正是标记是否使用默认Toolchain的关键。 操作步骤为下面图示顺序，注意：记得删除字段后，一定要重启Xcode才能生效的。 删除上面红色框所示的字段即可，完了后要重启Xcode才会生效。 总结这是iOS代码混淆系列文章的最后一篇，着重讲解了iOS编译原理相关知识，编译前端Clang和编译后端LLVM在整个编译期间各自所做的工作。后面重点讲述了如何使用开源工具Hikari 进行编译混淆、加固，在实践过程中，对遇到的坑也讲了解决方案。 希望看了这几篇文章的小伙伴，能对iOS代码混淆有个初步的学习和了解，最好能结合自身条件加以实践，想必会理解的更深刻。]]></content>
      <tags>
        <tag>iOS</tag>
        <tag>代码混淆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS代码混淆之资源替换]]></title>
    <url>%2F2019%2F03%2F05%2FiOS%E4%BB%A3%E7%A0%81%E6%B7%B7%E6%B7%86%E4%B9%8B%E8%B5%84%E6%BA%90%E6%9B%BF%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[这是iOS代码混淆系列文章的第二篇，其他两篇可以点击下方链接查看 iOS代码混淆之方法名替换 iOS代码混淆之编译优化 为什么要替换项目资源在某些公司项目开发当中 ，有时候需要通过技术手段，多次上架同一款产品。这些功能类似，且界面不同的产品也称作马甲包。为了达到将同一个包，经过较少的改动，快速更改为另一个类似的产品时，在代码混淆的基础之上还需要修改项目名称、静态资源等来达到目的。 需替换的资源及注意事项 工程内部：工程名称、类名前缀、BundleId、icon、启动图、静态资源等 产品界面：整体UI布局配色、产品功能逻辑、Tabbar顺序等 打包机器：更换打包电脑、使用WIFI网络、使用Application Uploader 上传不同二进制包 工具介绍及实践KLGenerateSpamCode是在GitHub上开源的一个可快速修改项目名称、文件前缀、生成垃圾代码等功能的集成工具，可方便的实现上述部分资源替换的功能。具体功能如下： 修改工程名 修改类名前缀 扫描工程中的代码，生成同等数量的 Category 文件，文件中及是同等方法数量的垃圾代码。 修改 xxx.xcassets 文件夹中的 png 资源文件名。 删除代码中的所有注释和空行。 由于在使用此工具之前，需要先配置修改参数，通过这些参数程序可以自动的修改项目中所需的内容，下面是从使用的角度对各项参数的解释： # 1. 项目名地址，注意：不是项目文件夹地址，是项目名那个目录/Users/jerry/Desktop/testProject0/century# 2. 修改项目名称，注意：放到最后修改,因为其他的修改需要依赖这个目录来查找-modifyProjectName century&gt;actualbyte# 3. 忽略文件夹，对添加的文件夹内的文件不执行修改。注意：多个文件夹之间用逗号隔开-ignoreDirNames ThirdPartLib,Tools,Category,Utils,MacrosDefine,Main,Resource,Support Files# 4. 修改类名前缀。没有前缀的会加上前缀，有前缀的会修改。注意：修改后是否重名-modifyClassNamePrefix /Users/jerry/Desktop/testProject0/century.xcodeproj CG&gt;WB# 5. 生成垃圾代码，注意：生成后的垃圾代码，需要拖入到工程目录中，如有报错可以自己修改或删除-spamCodeOut /Users/jerry/Desktop/testProject0/SpamCode WBLog# 6. 修改 xxx.xcassets 文件夹中的 png 资源文件名，必须指定(#1)的地址为xcassets所在的目录，才能生效。注意：此修改不会影响代码中图片的引用名称，只是对资源实体名和json配置文件中的修改。-handleXcassets# 7. 删除空行和注释 ，在项目根目录下运行，无效果可以单独运行一次。-deleteComments 上述的参数需要在下载的KLGenerateSpamCode工具目录中配置，如下图： ​ 参数配置好之后，Run 运行项目即可实现修改。另外，如果包含pod，需要到原项目文件夹下中执行pod update更新。 静态资源的修改静态资源包括项目的icon、启动图、和.xcassets 文件中的图标资源。其中为了更改UI页面元素，icon和启动图需要重新做，并替换进去，而xcassets 资源图片，可以通过修改其hash值达到修改资源的目的，具体可以使用MAC 下的一个终端工具实现。 ImageMagick：是一款创建、编辑、合成，转换图像的命令行工具，可对 png 图片做轻量压缩，既不损失图片质量，又可改变图片文件 hash 值，正是我们想要的工具。 如果电脑中没有安装的话，需要使用Homebrew来安装执行命令如下： brew install imagemagick 安装完成后，就可以使用ImageMagick的命令来修改： find . -iname "*.png" -exec echo &#123;&#125; \; -exec convert &#123;&#125; &#123;&#125; \; 总结本篇介绍了，如何通过修改工程名称、类前缀、资源hash值等方式，达到修改二进制包的目的，为上架苹果App Store 做准备。有兴趣的小伙伴可以亲自尝试一下，想必可以给您带来一些帮助。]]></content>
      <tags>
        <tag>iOS</tag>
        <tag>代码混淆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS代码混淆之方法名替换]]></title>
    <url>%2F2019%2F03%2F02%2FiOS%E4%BB%A3%E7%A0%81%E6%B7%B7%E6%B7%86%E4%B9%8B%E6%96%B9%E6%B3%95%E5%90%8D%E6%9B%BF%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[这是iOS代码混淆系列文章的第一篇，后两篇可以点击下方链接查看 iOS代码混淆之资源替换 iOS代码混淆之编译优化 前言在iOS开发中，某些项目为了保护代码安全，不被黑客攻破，通常需要在上架之前对源代码进行加密混淆，下面就介绍一种简单可行的Objective-C代码混淆方案。 混淆思路由于现在的逆向技术越来越高超，各种破解方案层出不穷，其中就可以使用class-dump命令行工具轻易的dump出demo.app文件中的所有头文件，代码立马回暴露在黑客面前，对项目产生了很多不利因素。因此将代码关键方法进行混淆保护迫在眉睫。 现有的一种混淆方案就是通过对指定class name 方法名进行MD5加密（显示乱码），然后通过脚本代码将加密的方法名生成到指定的头文件中，然后再使用宏替换的方式将混淆过的方法名在代码预编译阶段进行替换，使方法名即便在class-dump后也只会显示加密后的乱码显示，造成代码不易读，从而实现一定程度上的混淆保护。 混淆方式通过宏定义（#define）的方法名映射，进行字符串替换。这样做的好处在于可以将映射类别规整到一个头文件中，并#import 进项目的prefixHeader.h 预编译头文件中，方便在项目编译时进行全局替换。当不需要混淆的时候，则不导入该头文件即可。 混淆脚本下面的shell脚本引自的是“念茜-安全攻防”系列文章，实现思路是将敏感的方法名集中写入func.plist文件中，并逐一#define成随机字符串，最后写入一个.h头文件中。脚本代码如下： #!/usr/bin/env bashTABLENAME=symbolsSYMBOL_DB_FILE="symbols"STRING_SYMBOL_FILE="func.list"HEAD_FILE="$PROJECT_DIR/$PROJECT_NAME/codeObfuscation.h"export LC_CTYPE=C#维护数据库方便日后作排重createTable()&#123; echo "create table $TABLENAME(src text, des text);" | sqlite3 $SYMBOL_DB_FILE&#125;insertValue()&#123; echo "insert into $TABLENAME values('$1' ,'$2');" | sqlite3 $SYMBOL_DB_FILE&#125;query()&#123; echo "select * from $TABLENAME where src='$1';" | sqlite3 $SYMBOL_DB_FILE&#125;ramdomString()&#123; openssl rand -base64 64 | tr -cd 'a-zA-Z' |head -c 16&#125;rm -f $SYMBOL_DB_FILErm -f $HEAD_FILEcreateTabletouch $HEAD_FILEecho '#ifndef Demo_codeObfuscation_h#define Demo_codeObfuscation_h' &gt;&gt; $HEAD_FILEecho "//confuse string at `date`" &gt;&gt; $HEAD_FILEcat "$STRING_SYMBOL_FILE" | while read -ra line; do if [[ ! -z "$line" ]]; then ramdom=`ramdomString` echo $line $ramdom insertValue $line $ramdom echo "#define $line $ramdom" &gt;&gt; $HEAD_FILE fidoneecho "#endif" &gt;&gt; $HEAD_FILEsqlite3 $SYMBOL_DB_FILE .dump 配置步骤 创建混淆脚本文件confuse.sh，拷贝上述脚本代码到文件中保存，然后把该脚本文件放到项目根目录。例如：yourProject_path/目录下。 创建配置方法名称的列表文件，名为：func.list，此文件用于将需要混淆的方法名称写入进去，当项目编译时Build，会执行脚本遍历此文件中的方法名执行混淆操作，填写示例： -(void)sample; // 无参数方法-(void)seg1:(NSString *)string seg2:(NSUInteger)num; // 有参数方法// func.list 文件中这样写即可sampleseg1seg2 然后将创建好的func.list文件同样拷贝到项目根目录，也可以将confuse.sh 和func.list文件都添加进项目目录中，方便日后查看与维护，Xcode 左上角点击File --&gt; Add Files to &quot;xxx&quot;添加即可。 配置Build Phases脚本 // 脚本代码$PROJECT_DIR/confuse.sh 操作步骤如下图： 在PrefixHeader.h头文件中添加如下代码，意思是只有在Release模式下，才导入混淆头文件 // 混淆定义宏头文件，当在debug模式下，会执行脚本生成替换字符串，在release模式下导入宏文件执行替换#if (DEBUG != 1)#import "codeObfuscation.h"#endif 执行编译，可观察编译日志，查看custom shell 是否正确执行，如下图： 如果编译成功，会在项目根目录生成一个头文件codeObfuscation.h，此文件中正是包含了宏替换的关键内容，将此文件添加到项目中，会在release模式下进行替换。 可能会遇到的问题 第一次编译成功之前，即脚本代码执行之前是不会有codeObfuscation.h文件的，所以可能在PrefixHeader.h 文件中报错：Error_找不到该文件。解决方法：暂时注释掉即可。 在执行脚本时，编译日志处出现如下报错： 上图表示在执行脚本代码时，未能找到func.list 文件或其他文件，这时需要查看脚本代码中该文件的配置路径是否正确。解决方法：在confuse.sh文件中排查各项配置路径，并改正。 在执行脚本时，如遇到如下报错： confuse.sh: Permission denied 说明confuse.sh脚本文件没有可执行权限，需要在终端iTerm2 中给confuse.sh文件添加执行权限，如下操作即可： chmod a+x confuse.sh 使用class-dump 来测试class-dump是一个命令行工具，它利用Objective-C语言的runtime的特性，将存储在mach-O文件中的@interface和@protocol信息提取出来，并生成对应的.h文件。 它将xx.app格式的iOS项目文件进行分析，并通过命令生成该app源代码中的所有头文件列表，其中就包含了方法名称，可以清晰的查看dump出来的方法名是否已经被混淆。 安装 class-dump首先需要去这里：http://stevenygard.com/projects/class-dump/，下载class-dump-3.5.dmg压缩包，解压后将文件夹中的class-dump可执行文件拷贝到/usr/local/bin目录下。 具体操作步骤： 解压class-dump文件，如下图所示： 打开终端，输入如下命令，即可打开/usr/local/bin目录文件夹，然后将class-dump文件拷贝到此目录下。 open /usr/local/bin 给class-dump文件更改权限，终端输入如下命令： sudo chmod 777 /usr/local/bin/class-dump 在终端输入class-dump 查看是否安装成功，如显示命令的介绍和版本信息，就说明已经安装成功。 class-dump使用方法dump命令如下： class-dump -H /Users/xxx/Desktop/century.app -o /Users/jerry/Desktop/centuryHeaders 其中，-H 是生成头文件的命令，-o 是指定的头文件保存目录，/Users/xxx/Desktop/century.app 则是App文件的路径。 将在centuryHeaders文件夹中看到所有dump出的头文件。如下示例： Tips：如何从打包出来的xxx.ipa 文件中提取xxx.app 文件 先将xxx.ipa 文件后缀名修改为xxx.zip ， 然后解压xxx.zip 文件，会得到一个名为Payload的文件夹，文件夹中就放置的咱们需要的xxx.app文件，导出即可。 注意： 不是所有的xxx.app 文件都可以轻易的dump出头文件列表，只有未加密的，自己开发暂未上架App store 的app可以导出，App store 上架的三方应用由于被苹果加过密（加壳），不能直接dump，需要先进行砸壳（Dumpdecrypted工具）后，才能dump出需要的头文件。 后记至此，iOS开发中的Objective-C 代码混淆方案和class-dump技术的使用，都已经讲述清楚了，希望读者能体会到其中的安全攻防思路，在之后的开发中能多注意代码的安全防范。 注意：这种替换方法名的混淆方案会让App Store 审核被拒，2.3.1 - Performance We discovered that your app contains obfuscated code…，因此，不建议在App Store 上架的项目中使用。 参考资料： https://blog.csdn.net/yiyaaixuexi/article/details/29201699 https://www.jianshu.com/p/1e3fe0a8c048]]></content>
      <tags>
        <tag>iOS</tag>
        <tag>代码混淆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[对象、类、元类、isa指针之间的爱恨情仇]]></title>
    <url>%2F2019%2F02%2F28%2F%E5%AF%B9%E8%B1%A1%E3%80%81%E7%B1%BB%E3%80%81%E5%85%83%E7%B1%BB%E3%80%81isa%E6%8C%87%E9%92%88%E4%B9%8B%E9%97%B4%E7%9A%84%E7%88%B1%E6%81%A8%E6%83%85%E4%BB%87%2F</url>
    <content type="text"><![CDATA[前言在iOS开发中，对象、类的使用可以说是无处不在，伴随着整个项目的开发周期，也是程序的重要组成部分。但是在日常开发中，很难直观的见到元类、isa指针，那么它们究竟是谁，在开发中起着什么作用呢？下面我们就分别介绍下这几位亲兄弟的结构体定义，以及之间的关联关系。 类(class)的结构体定义类对象(Class)是由程序员定义并在运行时有编译器创建的，他没有自己的实例变量，这里需要注意的是类的成员变量和实例方法列表是属于实例对象的，但其存储于类对象当中。下图指出类的结构体定义： // An opaque type that represents an Objective-C class.typedef struct objc_class *Class;// OC1.0 class 结构体定义struct objc_class &#123; Class _Nonnull isa OBJC_ISA_AVAILABILITY;#if !__OBJC2__ Class _Nullable super_class OBJC2_UNAVAILABLE; const char * _Nonnull name OBJC2_UNAVAILABLE; long version OBJC2_UNAVAILABLE; long info OBJC2_UNAVAILABLE; long instance_size OBJC2_UNAVAILABLE; struct objc_ivar_list * _Nullable ivars OBJC2_UNAVAILABLE; struct objc_method_list * _Nullable * _Nullable methodLists OBJC2_UNAVAILABLE; struct objc_cache * _Nonnull cache OBJC2_UNAVAILABLE; struct objc_protocol_list * _Nullable protocols OBJC2_UNAVAILABLE;#endif&#125; OBJC2_UNAVAILABLE;/* Use `Class` instead of `struct objc_class *` */// OC2.0 class 结构体定义，我们注意到上面的定义后面的标识符OBJC2_UNAVAILABLE，意思是已经不适用ObjC2.0了，现在ObjC2.0 对objc_class的定义如下：struct objc_class : objc_object &#123; isa_t isa; Class superclass; cache_t cache; class_data_bits_t bits;&#125;; 我们在objc/objc.h 源码文件中找到了Class 类结构体的定义，下面我们分析并说明一下几个关键的结构体成员： isa： 是一个不能为空(null)的Class对象，它指向该类的元类(meta class)。 super_class：是一个可以为空的Class对象，它指向当前类的父类。会一直追溯到根类(NSObject)，那么根类(NSObject)的父类是指向谁的呢？通过分析根类的父类是指向空(nil)的，这样也就可以解释为什么super_class 是可以为空的。 ivars：是实例变量列表，保存着该类的所有实例变量 methodLists：是方法列表，保存着实例方法和类方法 protocols：是协议列表，保存该类的协议方法 cache：是一个缓存，用于缓存最近使用过的方法。 … 上面我们根据Class 类的结构体，分析内部成员的作用及含义。想必大家已经对Class类的内部结构有了一个初步的认识。如果想再深入理解isa和super_class在不同情况下都是如何进行指向的，我们再看下面的一个图示来逐步分析： 首先，注意图中的注释，实线的箭头(→ superclass)代表父类指针，虚线的箭头(→isa)代表isa指针，从上至下的深色方框依次代表：根类-&gt; 父类-&gt; 子类，下面咱们从上至下层层分析上图的含义： 第一层： isa指针： 根类的实例对象(instance Of Root class)的isa指向根类(Root class)，根类的isa指针指向根元类(Root meta class)，根元类的isa指向它本身。 superclass指针：根类(Root class)的superclass指向nil，根元类的父类指向根类。 第二层： isa指针：父类的实例对象(instance of superclass)的isa指向父类（superclass），父类的isa指向父元类，父元类的isa指向根元类。 superclass指针：父类的superclass指向根类，父元类的superclass指向根元类。 第三层： isa指针：子类实例对象（instance of subclass）的isa指向子类，子类的isa指向子元类，子元类的isa指向根元类。 superclass指针：子类的superclass指向父类，子元类的superclass指向父元类。 动态创建一个类 // 创建一个新类和元类Class objc_allocateClassPair ( Class superclass, const char *name, size_t extraBytes ); //如果创建的是root class，则superclass为Nil。extraBytes通常为0// 销毁一个类及其相关联的类void objc_disposeClassPair ( Class cls ); //在运行中还存在或存在子类实例，就不能够调用这个。// 在应用中注册由objc_allocateClassPair创建的类void objc_registerClassPair ( Class cls ); //创建了新类后，然后使用class_addMethod，class_addIvar函数为新类添加方法，实例变量和属性后再调用这个来注册类，再之后就能够用了。 对象(object)的结构体定义// Represents an instance of a class.struct objc_object &#123; Class _Nonnull isa OBJC_ISA_AVAILABILITY;&#125;; 我们可以看到，objc_object代表一个实例对象，它的结构体内部有一个不为空的isa指针，isa是指向对象所属类的指针。另外，我们常用的id类型是一个指向objc_object结构体的指针，它可以指向任意一个oc对象。 // A pointer to an instance of a class.typedef struct objc_object &#123; Class isa;&#125; *id; 元类(Meta class)的结构体定义元类(Meta class) 就是类对象的类，每个类都有自己的元类，也就是objc_class结构体里面的isa指针所指向的类。元类用来表述类对象本身所具备的元数据， 因为元类中存储着类对象的方法列表，即类方法。 下面将介绍实例对象、类、元类之间的关系，如下图所示： 当向对象发消息时，runtime会在这个对象所属类的实例方法列表中查找消息对应的方法实现(IMP)。但当向类发送消息时，runtime就会在这个类的元类(meta class)方法列表里查找。所有的元类(meta class)，包括根类(Root class)，父类(Superclass)，子类(Subclass)的isa最终都指向根类(Root class)的元类(meta class)，这样能够形成一个闭环。可以总结为： 当发送消息给实例对象时，runtime函数会在此实例对象所属类的实例方法列表中查找方法实现(IMP)并调用，此为实例方法调用。 当发送消息给类对象时，runtime函数会在此实例对象所属类的元类的方法列表中查找方法实例(IMP)并调用，此为类方法调用。 延伸扩展方法的调用流程 OC的方法调用本质上是给对象发送消息，即调用runtime的消息发送函数，如下所示： /* param: self(id) 接收消息的对象， param: op(SEL) 发送的消息，即方法签名(@selector(method_name))*/id _Nullable objc_msgSend(id _Nullable self, SEL _Nonnull op, ...) 通过对objc_msgSend()函数的源码分析，总结以下调用流程： 检查 selector 是否需要忽略 检查 target 是否为 nil，如果是 nil 就直接 cleanup，然后 return 在 target 的 Class 中根据 selector 去找 IMP 寻找IMP的流程 在当前 class 的方法缓存里寻找（cache methodLists） 找到了跳到对应的方法实现，没找到继续往下执行 从当前 class 的 方法列表里查找（methodLists），找到了添加到缓存列表里，然后跳转到对应的方法实现；没找到继续往下执行 从 superClass 的缓存列表和方法列表里查找，直到找到基类为止 以上步骤还找不到 IMP，则进入消息动态处理和消息转发(objc_msgForward)流程，详见这篇文章 我们从objc-class.mm 官方源码中找到了寻找IMP的实现过程，如下： IMP class_getMethodImplementation(Class cls, SEL sel)&#123;IMP imp;if (!cls || !sel) return nil;imp = lookUpImpOrNil(cls, sel, nil,YES/*initialize*/, YES/*cache*/, YES/*resolver*/);// Translate forwarding function to C-callable external versionif (!imp) &#123;return _objc_msgForward;&#125;return imp;&#125; 参考资料 http://limbank.com/2018/03/09/post18/ https://tingxins.com/2017/05/metaclass-class-relationship/]]></content>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入剖析Autorelease Pool (自动释放池)]]></title>
    <url>%2F2019%2F02%2F28%2F%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90Autorelease-Pool-%E8%87%AA%E5%8A%A8%E9%87%8A%E6%94%BE%E6%B1%A0%2F</url>
    <content type="text"><![CDATA[前言在MRC的内存管理模式下，可以将创建的对象加入自动释放池，程序员则无需手动调用release方法来释放对象，而是当自动释放池销毁的时候会对其中的每一个对象发送release消息，从而达到自动释放的目的。下面我们一步步揭开它的神秘面纱，深度剖析autoreleasepool的实现原理。 @autoreleasepool 实现原理main.m文件中的@autoreleasepool() 在iOS代码main.m文件中，我们可以看到@autoreleasepool{}代码块，其中包含的这一行代码将所有事件、消息全部交给了UIApplication来处理。需要注意的是：整个iOS的应用都是包含在一个自动释放池block中的。 // main.m 文件中的内容int main(int argc, char * argv[]) &#123; @autoreleasepool &#123; return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));&#125; 我们在命令行中使用 clang -rewrite-objc main.m 让编译器重新改写这个文件，可以看到该文件的c++代码实现细节，关键代码如下： ...int main(int argc,const char * argv[])&#123; /* @autoreleasepool */ &#123; __AtAutoreleasepool __autoreleasepool; &#125; return 0;&#125;... 通过分析上述代码，可以看到 {__AtAutoreleasepool __autoreleasepool;} 这段代码即是@atuoreleasepool的c++实现，通过创建一个__autoreleasepool对象来管理其他对象的自动释放操作。 分析__AtAutoreleasepool 结构体 我们在main.cpp文件中，定位到了其结构体的定义： ...struct __AtAutoreleasepool &#123; __AtAutoreleasepool() &#123; atautoreleasepoolobj = objc_autoreleasePoolPush();&#125; ~__AtAutoreleasepool() &#123; objc_autoreleasePoolPop(atautoreleasepoolpbj);&#125; void * atautoreleasepoolobj;&#125;... /*代码解释：1. __AtAutoreleasepool() 是其构造函数2. ~__AtAutoreleasepool() 是其析构函数析构函数：与构造函数相反, 析构函数是在对象被撤销时被自动调用, 用于对成员撤销时的一些清理工作, 例如在前面提到的手动释放使用 new 或 malloc 进行申请的内存空间。析构函数的特点：1. 析构函数函数名与类名相同, 紧贴在名称前面用波浪号 ~ 与构造函数进行区分, 例如: ~Point();2. 构造函数没有返回类型, 也不能指定参数, 因此析构函数只能有一个, 不能被重载;3. 当对象被撤销时析构函数被自动调用, 与构造函数不同的是, 析构函数可以被显式的调用, 以释放对象中动态申请的内存。*/ 这个结构体会在初始化时调用 objc_autoreleasePoolPush() 方法，会在析构时调用 objc_autoreleasePoolPop 方法。 这表明，我们的 main 函数在实际工作时其实是这样的： int main(int argc, const char * argv[]) &#123; &#123; void * atautoreleasepoolobj = objc_autoreleasePoolPush(); // do whatever you want objc_autoreleasePoolPop(atautoreleasepoolobj); &#125; return 0;&#125; 通过分析将@autoreleasepool{}的代码展开即可得到上述代码实现，在一个代码块中，先创建atautoreleasepoolobj 对象，然后中间插入iOS应用入口代码，最后自动调用析构函数objc_autoreleasePoolPop给当中的每一个对象发送 -release 消息销毁对象。 AutoreleasePool 实现原理从上一节我们对__AtAutoreleasepool结构体分析可以看出，自动释放池得以实现的核心是在它的构造函数和析构函数中，所以我们接下来就分析这两个函数的内部实现。 我们定位到 objc_autoreleasePoolPush 和 objc_autoreleasePoolPop 函数的实现代码如下： void *objc_autoreleasePoolPush(void) &#123; return AutoreleasePoolPage::push();&#125;void objc_autoreleasePoolPop(void *ctxt) &#123; AutoreleasePoolPage::pop(ctxt);&#125; 从函数实现中可以看出，内部使用了一个名为AutoreleasePoolPage的c++类，通过调用此类的push() 方法和pop()方法来实现被释放对象的添加和销毁操作。 既然这几个方法是拨开云雾的关键，那么我们就逐一分析：AutoreleasePoolPage的结构、objc_autoreleasePoolPush（） 方法、objc_autoreleasePoolPop（）方法。 AutoreleasePoolPage的结构 AutoreleasePoolPage的一个c++类，它在NSObject.mm 文件中的定义如下： class AutoreleasePoolPage &#123; magic_t const magic; id *next; pthread_t const thread; AutoreleasePoolPage * const parent; AutoreleasePoolPage *child; uint32_t const depth; uint32_t hiwat;&#125;;/* 类成员结构解析： magic：用来校验AutoreleasePoolPage 的结构是否完整 *next：指向最新添加的auoreleased 对象的下一个位置，初始化时指向begin() thread：指向当前线程 parent：指向父结点，第一个结点的 parent 值为 nil child：指向子结点，最后一个结点的 child 值为 nil depth：代表深度，从 0 开始，往后递增 1； hiwat：代表 high water mark 。*/ 一个空的AutoreleasePoolPage 的内存结构如下图所示： 另外，当 next == begin() 时，表示 AutoreleasePoolPage 为空；当 next == end() 时，表示 AutoreleasePoolPage 已满。 每个自动释放池都是由一系列的AutoreleasePoolPage组成的，并且每一个AutoreleasePoolPage的大小都是4096字节（16进制0x1000） AutoreleasePoolPage在自动释放池中的组织结构 AutoreleasePoolPage在自动释放池中是以双向链表的形式链接起来的： parent 和 child 就是用来构造双向链表的指针。 objc_autoreleasePoolPush() 方法解析 其中有个很重要定义POOL_SENTINEL ，它叫哨兵对象，本质是一个nil的宏定义： #define POOL_SENTINEL nil 在每个自动释放池初始化调用 objc_autoreleasePoolPush() 的时候，都会把一个 POOL_SENTINEL push 到自动释放池的栈顶，并且返回这个 POOL_SENTINEL 哨兵对象。上面讲解@autoreleasepool()代码块的时候，其中的atautoreleasepoolobj对象就是一个POOL_SENTINEL。 接下来我们分析objc_autoreleasePoolPush方法的实现，从上面的分析可以得出objc_autoreleasePoolPush方法、push()方法等的实现如下： /* 代码从上至下依次调用 */ // 1. objc_autoreleasePoolPush()void *objc_autoreleasePoolPush(void) &#123; return AutoreleasePoolPage::push();&#125;// 2. push()static inline void *push() &#123; return autoreleaseFast(POOL_SENTINEL);&#125;// 3. autoreleaseFast(), 参数obj 就是需要自动释放的对象static inline id *autoreleaseFast(id obj)&#123; AutoreleasePoolPage *page = hotPage(); if (page &amp;&amp; !page-&gt;full()) &#123; return page-&gt;add(obj); &#125; else if (page) &#123; return autoreleaseFullPage(obj, page); &#125; else &#123; return autoreleaseNoPage(obj); &#125;&#125; 上述方法autoreleaseFast:的实现中有三种选择： hotPage：可以理解为当前正在使用的 AutoreleasePoolPage 当page 存在，且没有满时：调用page-&gt;add(obj)方法将对象添加至AutoreleasePoolPage的栈中 当page存在，已经满时： 调用autoreleaseFullPage初始化一个新页 调用page-&gt;add(obj)将obj添加到新创建的page的栈中 无page时： 调用autoreleaseNoPage创建一个hotPage 调用page-&gt;add(obj)方法将对象添加至AutoreleasePoolPage的栈中 page-&gt; add() 方法的实现 id *add(id obj) &#123; id *ret = next; *next = obj; next++; return ret;&#125; 将obj对象添加到hotPage中，并移动 *next指针指向obj对象的下一个位置，本质上是一个压栈操作。 objc_autoreleasePoolPop() 方法解析 回顾上述分析，objc_autoreleasePoolPop方法的实现如下： void objc_autoreleasePoolPop(void *ctxt) &#123; if (UseGC) return; // fixme rdar://9167170 if (!ctxt) return; AutoreleasePoolPage::pop(ctxt);&#125;/*看起来传入任何一个指针都是可以的，但是在整个工程并没有发现传入其他对象的例子。不过在这个方法中传入其它的指针也是可行的，会将自动释放池释放到相应的位置。*/ pop 函数的入参就是 push 函数的返回值，也就是 POOL_SENTINEL 的内存地址 。当执行 pop 操作时，内存地址在 POOL_SENTINEL 之后的所有 autoreleased 对象都会被 release 。直到 POOL_SENTINEL 所在 page 的 next 指向 POOL_SENTINEL 为止。 下面是某个线程的 autoreleasepool 堆栈的内存结构图，在这个 autoreleasepool 堆栈中总共有两个 POOL_SENTINEL ，即有两个 autoreleasepool 。该堆栈由三个 AutoreleasePoolPage 结点组成，第一个 AutoreleasePoolPage 结点为 coldPage() ，最后一个 AutoreleasePoolPage 结点为 hotPage() 。其中，前两个结点已经满了，最后一个结点中保存了最新添加的 autoreleased 对象 objr3 的内存地址。 此时，如果执行 pop(token1) 操作，那么该 autoreleasepool 堆栈的内存结构将会变成如下图所示： autorelease 方法 最后我们分析下autorelease 方法内部的实现原理。首先，我们先看一下方法调用栈： - [obj autorelease]└── id objc_object::rootAutorelease() └── id objc_object::rootAutorelease2() └── static id AutoreleasePoolPage::autorelease(id obj) └── static id AutoreleasePoolPage::autoreleaseFast(id obj) ├── id *add(id obj) ├── static id *autoreleaseFullPage(id obj, AutoreleasePoolPage *page) │ ├── AutoreleasePoolPage(AutoreleasePoolPage *newParent) │ └── id *add(id obj) └── static id *autoreleaseNoPage(id obj) ├── AutoreleasePoolPage(AutoreleasePoolPage *newParent) └── id *add(id obj) 从上面从调用栈中可以看出， 会先调用AutoreleasePoolPage的autorelease()方法， 最后会调用上面提到autoreleaseFast方法，将obj对象添加AutoreleasePoolPage中。 下面是autorelease()方法的实现： static inline id autorelease(id obj)&#123; assert(obj); assert(!obj-&gt;isTaggedPointer()); id *dest __unused = autoreleaseFast(obj); // 最终会调用 autoreleaseFast 方法 assert(!dest || *dest == obj); return obj;&#125; 总结整个自动释放池 AutoreleasePool 的实现以及 autorelease 方法都已经分析完了，归纳总结后，得出了下面的几个要点： 自动释放池是由 AutoreleasePoolPage 以双向链表的方式实现的 当对象调用 autorelease 方法时，会将对象加入 AutoreleasePoolPage 的栈中 调用 AutoreleasePoolPage::pop 方法会向栈中的对象发送 release 消息 参考/引用 自动释放池的前世今生 —- 深入解析 autoreleasepool Objective-C Autorelease Pool 的实现原理]]></content>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VPS下搭建ownCloud云盘]]></title>
    <url>%2F2018%2F11%2F03%2FVPS%E4%B8%8B%E6%90%AD%E5%BB%BAownCloud%E4%BA%91%E7%9B%98%2F</url>
    <content type="text"><![CDATA[前言鉴于各大网络云盘的各种限制，收费制度和用户体验并不好，利用VPS来搭建一个私有云盘就会变得越来越受欢迎，目前主流的开源软件ownCloud，NexCloud等都可以实现，下面我们就选ownCloud来搭建，vps选择的搬瓦工。 准备 一台VPS服务器，开启root权限 LAMP环境。ownCloud需要Web服务器，数据库和PHP才能正常工作。 设置LAMP（Linux，Apache，MySQL和PHP）服务器满足所有这些要求 安装ownCloud ，并配置相关参数。 设置LAMP环境“LAMP”是一组开放源代码软件，通常安装在一起以使服务器能够托管动态网站和网络应用。这个词其实是代表linux下的操作系统，Apache Web服务器的缩写。 站点数据存储在MySQL数据库（使用MariaDB），以及动态内容用PHP处理。 接下来，我们将在CentOS 7 VPS上安装一个LAMP。 CentOS将满足我们的第一个需求：一个Linux操作系统。 安装Apache 在终端输入命令安装： sudo yum install httpd 安装完成后，启动该服务 sudo systemctl start httpd.service 踩坑：如果无法启动报错，可能是没有设置防火墙对http/https的访问权限，输入下面命令开启 sudo firewall-cmd --permanent --zone=public --add-service=http sudo firewall-cmd --permanent --zone=public --add-service=httpssudo firewall-cmd --reload// 注意：如果提示 firewall 没有启动，则使用命令开启：// 注意：如果开启防火墙后，ssh 无法访问远程vps，可以在vps服务商提供的web页面中的root shell 控制台来设置上述命令。启动： systemctl start firewalld关闭： systemctl stop firewalld查看状态： systemctl status firewalld 开机禁用 ： systemctl disable firewalld开机启用 ： systemctl enable firewalld 再次使用命令来尝试开启httpd 服务。如果开启后(即没有报错信息)，下面设置开机默认启动： sudo systemctl enable httpd.service 输入http://你的服务器地址/测试是否安装成功，如果能访问就说明安装没问题，如下截图： 到这里就Apache 服务就安装完成了。 安装MySQL（MariaDB） 现在我们已经开始运行Web服务器，现在是安装MariaDB的时候了，这是一个MySQL插件替换。 启动数据库以后会提示输入数据库密码。由于我们是首次安装，直接enter即可，同时会提示你设置密码，输入你想要设置的数据库密码即可。 // 1. 安装数据库sudo yum install mariadb-server mariadb// 2. 启动数据库sudo systemctl enable mariadb.service// 3. 设置数据库，默认启动sudo systemctl enable mariadb.service 安装PHP PHP是我们的设置的组件，它将处理代码以显示动态内容。它可以运行脚本，连接到我们的MySQL数据库以获取信息，并将处理的内容传递到我们的Web服务器以显示。 注意此处CentOS 7默认PHP为5.4版本，ownCloud需要的PHP版本为5.6以上。所以此处我们安装PHP5.6版本。 执行下面命令升级php仓库 rpm -Uvh https://mirror.webtatic.com/yum/el7/epel-release.rpmrpm -Uvh https://mirror.webtatic.com/yum/el7/webtatic-release.rpm 执行安装 yum install -y php56w php56w-opcache php56w-xml php56w-mcrypt php56w-gd php56w-devel php56w-mysql php56w-intl php56w-mbstring php56w-openssl php56w-Tokenizer php56w-posix php56w-pcntl 这里要特别注意，可能会报错php56w-commen 和php5.4-commen发生文件冲突，导致安装不成功。因为centOS 7 系统默认会安装php5.4，如果直接执行安装高版本的话就会报错，通过踩坑经验最简单直接的方法就是删除掉原有的php5.4，在安装php56w或更高的版本： 删除旧版本php的方法命令： yum remove php-common 再次执行上面的安装命令，如果安装成功，执行下面命令重启httpd服务 sudo systemctl restart httpd.service 还可以通过执行命令php -v查看php的安装版本 为了测试PHP是否正确配置，可以创建一个php脚本来查看。在web根目录/var/www/html/创建一个info.php 文件，然后使用vim打开这个文件插入下面这句话保持退出： &lt;?php phpinfo(); ?&gt; 然后访问 http://你的服务器地址/info.php 如果没有问题页面会展示PHP的一些基本信息。 最后不忘删除我们的测试页面 sudo rm /var/www/html/info.php 到这里整个LAMP服务就都安装完成了。 安装ownCloudownCloud服务器软件包不存在于CentOS的默认存储库中。然而，ownCloud为发行版维护了一个专用的存储库。 首先，导入与他们释放钥匙rpm命令。 关键的授权包管理器yum信任库。 sudo rpm --import https://download.owncloud.org/download/repositories/stable/CentOS_7/repodata/repomd.xml.key 接下来，使用curl命令下载ownCloud库文件： sudo curl -L https://download.owncloud.org/download/repositories/stable/CentOS_7/ce:stable.repo -o /etc/yum.repos.d/ownCloud.repo 添加新文件后，用clean命令使yum知道所做的更改： sudo yum clean expire-cache// 如果提示类似下列命令，说明执行成功了OutputLoaded plugins: fastestmirrorCleaning repos: base ce_stable extras updates6 metadata files removed 最后，使用进行ownCloud安装yum实用程序和install命令： sudo yum install owncloud// 当提示Is this ok [y/d/N]:消息类型Y然后按ENTER键授权安装 配置数据库 mysql -u root -p// 可能会提示要输入密码，如果没有直接enter即可 为ownCloud 创建表，注意：每个MySQL的语句必须以分号;结束 CREATE DATABASE owncloud; 接下来，创建一个单独的MySQL用户帐户，与新创建的数据库进行交互。从管理和安全的角度来看，这样做不仅有利于数据安全更有利于我们日后的管理工作。与数据库的命名一样，选择您喜欢的用户名。我们选择owncloud GRANT ALL ON owncloud.* to 'owncloud'@'localhost' IDENTIFIED BY '此处填写你想要设置的密码'; 执行flush-privileges操作以确保MySQL应用权限分配 FLUSH PRIVILEGES; 数据库已经完成配置，执行命令exit退出。 配置ownCloud打开https://你的服务器地址/owncloud进入web管理页面 此时页面会提示你创建管理员账号，输入你想要的管理员账号和密码。在下方的数据库选项中选择MySQL／MariaDB，并且填入相应的账号和密码。此处填入的账号和密码即之前我们设置数据库时设置的账号和密码 点击Finish setup 完成安装。然后重新进入ownCloud web页面就可以进入到网盘。 到这里整个安装流程就都完成，可以开心的上传自己的文件啦。]]></content>
      <tags>
        <tag>ownCloud</tag>
        <tag>vps</tag>
      </tags>
  </entry>
</search>