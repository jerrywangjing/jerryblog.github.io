<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[iOS代码混淆方案（一）]]></title>
    <url>%2F2019%2F04%2F02%2FObjective-C%E4%BB%A3%E7%A0%81%E6%B7%B7%E6%B7%86%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[iOS代码混淆方案（一）在iOS开发中，某些项目为了保护代码安全，不被黑客攻破，通常需要在上架之前对源代码进行加密混淆，下面就介绍一种简单可行的Objective-C代码混淆方案。 混淆思路由于现在的逆向技术越来越高超，各种破解方案层出不穷，其中就可以使用class-dump命令行工具轻易的dump出demo.app文件中的所有头文件，代码立马回暴露在黑客面前，对项目产生了很多不利因素。因此将代码关键方法进行混淆保护迫在眉睫。 现有的一种混淆方案就是通过对指定class name 方法名进行MD5加密（显示乱码），然后通过脚本代码将加密的方法名生成到指定的头文件中，然后再使用宏替换的方式将混淆过的方法名在代码预编译阶段进行替换，使方法名即便在class-dump后也只会显示加密后的乱码显示，造成代码不易读，从而实现一定程度上的混淆保护。 混淆方式通过宏定义（#define）的方法名映射，进行字符串替换。这样做的好处在于可以将映射类别规整到一个头文件中，并#import 进项目的prefixHeader.h 预编译头文件中，方便在项目编译时进行全局替换。当不需要混淆的时候，则不导入该头文件即可。 混淆脚本下面的shell脚本引自的是“念茜-安全攻防”系列文章，实现思路是将敏感的方法名集中写入func.plist文件中，并逐一#define成随机字符串，最后写入一个.h头文件中。脚本代码如下： #!/usr/bin/env bashTABLENAME=symbolsSYMBOL_DB_FILE="symbols"STRING_SYMBOL_FILE="func.list"HEAD_FILE="$PROJECT_DIR/$PROJECT_NAME/codeObfuscation.h"export LC_CTYPE=C#维护数据库方便日后作排重createTable()&#123; echo "create table $TABLENAME(src text, des text);" | sqlite3 $SYMBOL_DB_FILE&#125;insertValue()&#123; echo "insert into $TABLENAME values('$1' ,'$2');" | sqlite3 $SYMBOL_DB_FILE&#125;query()&#123; echo "select * from $TABLENAME where src='$1';" | sqlite3 $SYMBOL_DB_FILE&#125;ramdomString()&#123; openssl rand -base64 64 | tr -cd 'a-zA-Z' |head -c 16&#125;rm -f $SYMBOL_DB_FILErm -f $HEAD_FILEcreateTabletouch $HEAD_FILEecho '#ifndef Demo_codeObfuscation_h#define Demo_codeObfuscation_h' &gt;&gt; $HEAD_FILEecho "//confuse string at `date`" &gt;&gt; $HEAD_FILEcat "$STRING_SYMBOL_FILE" | while read -ra line; do if [[ ! -z "$line" ]]; then ramdom=`ramdomString` echo $line $ramdom insertValue $line $ramdom echo "#define $line $ramdom" &gt;&gt; $HEAD_FILE fidoneecho "#endif" &gt;&gt; $HEAD_FILEsqlite3 $SYMBOL_DB_FILE .dump 配置步骤 创建混淆脚本文件confuse.sh，拷贝上述脚本代码到文件中保存，然后把该脚本文件放到项目根目录。例如：yourProject_path/目录下。 创建配置方法名称的列表文件，名为：func.list，此文件用于将需要混淆的方法名称写入进去，当项目编译时Build，会执行脚本遍历此文件中的方法名执行混淆操作，填写示例： -(void)sample; // 无参数方法-(void)seg1:(NSString *)string seg2:(NSUInteger)num; // 有参数方法// func.list 文件中这样写即可sampleseg1seg2 然后将创建好的func.list文件同样拷贝到项目根目录，也可以将confuse.sh 和func.list文件都添加进项目目录中，方便日后查看与维护，Xcode 左上角点击File --&gt; Add Files to &quot;xxx&quot;添加即可。 配置Build Phases脚本 // 脚本代码$PROJECT_DIR/confuse.sh 操作步骤如下图： 在PrefixHeader.h头文件中添加如下代码，意思是只有在Release模式下，才导入混淆头文件 // 混淆定义宏头文件，当在debug模式下，会执行脚本生成替换字符串，在release模式下导入宏文件执行替换#if (DEBUG != 1)#import "codeObfuscation.h"#endif 执行编译，可观察编译日志，查看custom shell 是否正确执行，如下图： 如果编译成功，会在项目根目录生成一个头文件codeObfuscation.h，此文件中正是包含了宏替换的关键内容，将此文件添加到项目中，会在release模式下进行替换。 可能会遇到的问题 第一次编译成功之前，即脚本代码执行之前是不会有codeObfuscation.h文件的，所以可能在PrefixHeader.h 文件中报错：Error_找不到该文件。解决方法：暂时注释掉即可。 在执行脚本时，编译日志处出现如下报错： 上图表示在执行脚本代码时，未能找到func.list 文件或其他文件，这时需要查看脚本代码中该文件的配置路径是否正确。解决方法：在confuse.sh文件中排查各项配置路径，并改正。 在执行脚本时，如遇到如下报错： confuse.sh: Permission denied 说明confuse.sh脚本文件没有可执行权限，需要在终端iTerm2 中给confuse.sh文件添加执行权限，如下操作即可： chmod a+x confuse.sh 使用class-dump 来测试class-dump是一个命令行工具，它利用Objective-C语言的runtime的特性，将存储在mach-O文件中的@interface和@protocol信息提取出来，并生成对应的.h文件。 它将xx.app格式的iOS项目文件进行分析，并通过命令生成该app源代码中的所有头文件列表，其中就包含了方法名称，可以清晰的查看dump出来的方法名是否已经被混淆。 安装 class-dump首先需要去这里：http://stevenygard.com/projects/class-dump/，下载class-dump-3.5.dmg压缩包，解压后将文件夹中的class-dump可执行文件拷贝到/usr/local/bin目录下。 具体操作步骤： 解压class-dump文件，如下图所示： 打开终端，输入如下命令，即可打开/usr/local/bin目录文件夹，然后将class-dump文件拷贝到此目录下。 open /usr/local/bin 给class-dump文件更改权限，终端输入如下命令： sudo chmod 777 /usr/local/bin/class-dump 在终端输入class-dump 查看是否安装成功，如显示命令的介绍和版本信息，就说明已经安装成功。 class-dump使用方法dump命令如下： class-dump -H /Users/xxx/Desktop/century.app -o /Users/jerry/Desktop/centuryHeaders 其中，-H 是生成头文件的命令，-o 是指定的头文件保存目录，/Users/xxx/Desktop/century.app 则是App文件的路径。 将在centuryHeaders文件夹中看到所有dump出的头文件。如下示例： Tips：如何从打包出来的xxx.ipa 文件中提取xxx.app 文件 先将xxx.ipa 文件后缀名修改为xxx.zip ， 然后解压xxx.zip 文件，会得到一个名为Payload的文件夹，文件夹中就放置的咱们需要的xxx.app文件，导出即可。 注意： 不是所有的xxx.app 文件都可以轻易的dump出头文件列表，只有未加密的，自己开发暂未上架App store 的app可以导出，App store 上架的三方应用由于被苹果加过密（加壳），不能直接dump，需要先进行砸壳（Dumpdecrypted工具）后，才能dump出需要的头文件。 后记至此，iOS开发中的Objective-C 代码混淆方案和class-dump技术的使用，都已经讲述清楚了，希望读者能体会到其中的安全攻防思路，在之后的开发中能多注意代码的安全防范。 注意：这种替换方法名的混淆方案会让App Store 审核被拒，2.3.1 - Performance We discovered that your app contains obfuscated code…，因此，不建议在App Store 上架的项目中使用。 参考资料： https://blog.csdn.net/yiyaaixuexi/article/details/29201699 https://www.jianshu.com/p/1e3fe0a8c048]]></content>
      <tags>
        <tag>iOS,代码混淆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VPS下搭建ownCloud云盘]]></title>
    <url>%2F2018%2F11%2F03%2FVPS%E4%B8%8B%E6%90%AD%E5%BB%BAownCloud%E4%BA%91%E7%9B%98%2F</url>
    <content type="text"><![CDATA[基于ownCloud在VPS（CentOS 7）上搭建私有云盘前言鉴于各大网络云盘的各种限制，收费制度和用户体验并不好，利用VPS来搭建一个私有云盘就会变得越来越受欢迎，目前主流的开源软件ownCloud，NexCloud等都可以实现，下面我们就选ownCloud来搭建，vps选择的搬瓦工。 准备 一台VPS服务器，开启root权限 LAMP环境。ownCloud需要Web服务器，数据库和PHP才能正常工作。 设置LAMP（Linux，Apache，MySQL和PHP）服务器满足所有这些要求 安装ownCloud ，并配置相关参数。 设置LAMP环境“LAMP”是一组开放源代码软件，通常安装在一起以使服务器能够托管动态网站和网络应用。这个词其实是代表linux下的操作系统，Apache Web服务器的缩写。 站点数据存储在MySQL数据库（使用MariaDB），以及动态内容用PHP处理。 接下来，我们将在CentOS 7 VPS上安装一个LAMP。 CentOS将满足我们的第一个需求：一个Linux操作系统。 安装Apache 在终端输入命令安装： sudo yum install httpd 安装完成后，启动该服务 sudo systemctl start httpd.service 踩坑：如果无法启动报错，可能是没有设置防火墙对http/https的访问权限，输入下面命令开启 sudo firewall-cmd --permanent --zone=public --add-service=http sudo firewall-cmd --permanent --zone=public --add-service=httpssudo firewall-cmd --reload// 注意：如果提示 firewall 没有启动，则使用命令开启：// 注意：如果开启防火墙后，ssh 无法访问远程vps，可以在vps服务商提供的web页面中的root shell 控制台来设置上述命令。启动： systemctl start firewalld关闭： systemctl stop firewalld查看状态： systemctl status firewalld 开机禁用 ： systemctl disable firewalld开机启用 ： systemctl enable firewalld 再次使用命令来尝试开启httpd 服务。如果开启后(即没有报错信息)，下面设置开机默认启动： sudo systemctl enable httpd.service 输入http://你的服务器地址/测试是否安装成功，如果能访问就说明安装没问题，如下截图： 到这里就Apache 服务就安装完成了。 安装MySQL（MariaDB） 现在我们已经开始运行Web服务器，现在是安装MariaDB的时候了，这是一个MySQL插件替换。 启动数据库以后会提示输入数据库密码。由于我们是首次安装，直接enter即可，同时会提示你设置密码，输入你想要设置的数据库密码即可。 // 1. 安装数据库sudo yum install mariadb-server mariadb// 2. 启动数据库sudo systemctl enable mariadb.service// 3. 设置数据库，默认启动sudo systemctl enable mariadb.service 安装PHP PHP是我们的设置的组件，它将处理代码以显示动态内容。它可以运行脚本，连接到我们的MySQL数据库以获取信息，并将处理的内容传递到我们的Web服务器以显示。 注意此处CentOS 7默认PHP为5.4版本，ownCloud需要的PHP版本为5.6以上。所以此处我们安装PHP5.6版本。 执行下面命令升级php仓库 rpm -Uvh https://mirror.webtatic.com/yum/el7/epel-release.rpmrpm -Uvh https://mirror.webtatic.com/yum/el7/webtatic-release.rpm 执行安装 yum install -y php56w php56w-opcache php56w-xml php56w-mcrypt php56w-gd php56w-devel php56w-mysql php56w-intl php56w-mbstring php56w-openssl php56w-Tokenizer php56w-posix php56w-pcntl 这里要特别注意，可能会报错php56w-commen 和php5.4-commen发生文件冲突，导致安装不成功。因为centOS 7 系统默认会安装php5.4，如果直接执行安装高版本的话就会报错，通过踩坑经验最简单直接的方法就是删除掉原有的php5.4，在安装php56w或更高的版本： 删除旧版本php的方法命令： yum remove php-common 再次执行上面的安装命令，如果安装成功，执行下面命令重启httpd服务 sudo systemctl restart httpd.service 还可以通过执行命令php -v查看php的安装版本 为了测试PHP是否正确配置，可以创建一个php脚本来查看。在web根目录/var/www/html/创建一个info.php 文件，然后使用vim打开这个文件插入下面这句话保持退出： &lt;?php phpinfo(); ?&gt; 然后访问 http://你的服务器地址/info.php 如果没有问题页面会展示PHP的一些基本信息。 最后不忘删除我们的测试页面 sudo rm /var/www/html/info.php 到这里整个LAMP服务就都安装完成了。 安装ownCloudownCloud服务器软件包不存在于CentOS的默认存储库中。然而，ownCloud为发行版维护了一个专用的存储库。 首先，导入与他们释放钥匙rpm命令。 关键的授权包管理器yum信任库。 sudo rpm --import https://download.owncloud.org/download/repositories/stable/CentOS_7/repodata/repomd.xml.key 接下来，使用curl命令下载ownCloud库文件： sudo curl -L https://download.owncloud.org/download/repositories/stable/CentOS_7/ce:stable.repo -o /etc/yum.repos.d/ownCloud.repo 添加新文件后，用clean命令使yum知道所做的更改： sudo yum clean expire-cache// 如果提示类似下列命令，说明执行成功了OutputLoaded plugins: fastestmirrorCleaning repos: base ce_stable extras updates6 metadata files removed 最后，使用进行ownCloud安装yum实用程序和install命令： sudo yum install owncloud// 当提示Is this ok [y/d/N]:消息类型Y然后按ENTER键授权安装 配置数据库 mysql -u root -p// 可能会提示要输入密码，如果没有直接enter即可 为ownCloud 创建表，注意：每个MySQL的语句必须以分号;结束 CREATE DATABASE owncloud; 接下来，创建一个单独的MySQL用户帐户，与新创建的数据库进行交互。从管理和安全的角度来看，这样做不仅有利于数据安全更有利于我们日后的管理工作。与数据库的命名一样，选择您喜欢的用户名。我们选择owncloud GRANT ALL ON owncloud.* to 'owncloud'@'localhost' IDENTIFIED BY '此处填写你想要设置的密码'; 执行flush-privileges操作以确保MySQL应用权限分配 FLUSH PRIVILEGES; 数据库已经完成配置，执行命令exit退出。 配置ownCloud打开https://你的服务器地址/owncloud进入web管理页面 此时页面会提示你创建管理员账号，输入你想要的管理员账号和密码。在下方的数据库选项中选择MySQL／MariaDB，并且填入相应的账号和密码。此处填入的账号和密码即之前我们设置数据库时设置的账号和密码 点击Finish setup 完成安装。然后重新进入ownCloud web页面就可以进入到网盘。 到这里整个安装流程就都完成，可以开心的上传自己的文件啦。]]></content>
      <tags>
        <tag>ownCloud</tag>
        <tag>vps</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决Hexo DTraceProviderBindings MODULE_NOT_FOUND报错]]></title>
    <url>%2F2018%2F01%2F16%2F%E8%A7%A3%E5%86%B3Hexo-DTraceProviderBindings-MODULE-NOT-FOUND%E6%8A%A5%E9%94%99%2F</url>
    <content type="text"><![CDATA[问题描述：当我们在执行hexo 命令的时候有时会出现如下报错，这是因为hexo没有安装dtrace-prodider 模块导致的错误提示。但是hexo命令任然可以正常执行。可通过下面方法来屏蔽此报错信息。 hexo报错信息 &#123; [Error: Cannot find module './build/Release/DTraceProviderBindings'] code: 'MODULE_NOT_FOUND' &#125;&#123; [Error: Cannot find module './build/default/DTraceProviderBindings'] code: 'MODULE_NOT_FOUND' &#125;&#123; [Error: Cannot find module './build/Debug/DTraceProviderBindings'] code: 'MODULE_NOT_FOUND' &#125; 解决方法：可以通过重新安装hexo-cli来解决此问题： 安装命令： //1. 卸载hexo-cli $ sudo npm uninstall hexo-cli -g//2. 安装hexo-cli ，注意：这里必须用管理员权限安装，否则会报错。$ sudo npm install hexo-cli -g]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F01%2F01%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post$ hexo new "My New Post" More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment 这是一段测试代码- (void)clearAllChatRecord&#123; [WJAlertSheetView showAlertSheetViewWithTips:@"确认清空所有聊天记录？清空后将无法恢复" items:@[@"确定"] completion:^(NSInteger index,UIButton *item) &#123; if (index == 1) &#123; BOOL success = [[DBManager shareManager] deleteAllMessageRecord]; [MBProgressHUD hideHUD]; if (!success) &#123; [MBProgressHUD showLabelWithText:@"清除失败，请重试"]; &#125;else&#123; [MBProgressHUD showLabelWithText:@"清除完成"]; &#125; &#125; &#125;]; // 测试文字&#125;]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>