<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[iOS代码混淆之编译优化(三)]]></title>
    <url>%2F2019%2F03%2F10%2FiOS%E4%BB%A3%E7%A0%81%E6%B7%B7%E6%B7%86%E4%B9%8B%E7%BC%96%E8%AF%91%E4%BC%98%E5%8C%96(%E4%B8%89)%2F</url>
    <content type="text"><![CDATA[这是iOS代码混淆系列文章的最后一篇，前两篇可以点击下方链接查看 iOS代码混淆之方法名替换 iOS代码混淆之资源替换 前言前2篇文章已近讲了对于函数名的混淆，对项目中关键信息、资源文件的修改等相关混淆手段。但是，仅仅做到这几点就能万事大吉吗，黑客仍然可以通过分析代码逻辑或伪装代码来寻找程序漏洞，那么还有其他更坚固可靠的混淆方式呢，接下来就介绍下编译器级别的加固混淆方案。 iOS编译原理iOS 开发中 Objective-C 和 Swift 都用的是 Clang / LLVM 来编译的。Clang是作为编译前端，LLVM做为编译后端，共同完成了iOS项目代码的编译阶段。 Clang(编译前端)Clang 是 LLVM 的子项目，是 C，C++ 和 Objective-C 编译器，目的是提供惊人的快速编译，比 GCC 快3倍，其中的 clang static analyzer 主要是进行语法分析，语义分析和生成中间代码，当然这个过程会对代码进行检查，出错的和需要警告的会标注出来。 LLVM(编译后端)LLVM是一个模块化和可重用的编译器和工具链技术的集合，LLVM 核心库提供一个优化器，对流行的 CPU 做代码生成支持。LLVM 比较有特色的一点是它能提供一种代码编写良好的中间表示 IR，这意味着它可以作为多种语言的后端，这样就能够提供语言无关的优化同时还能够方便的针对多种 CPU 的代码生成。 HikariHikari 是一个基于 Obfuscator-LLVM 的改进，增加了一些额外的自定义构建通道，更简单易用，结合使用文档，可以快速体验编译级别的代码加固效果。 OLLVM 是瑞士西北应用科技大学安全实验室于2010年6月份发起的一个项目，该项目旨在提供一套开源的针对 LLVM 的代码混淆工具，以增加对逆向工程的难度。目前，OLLVM已经支持LLVM8.0版本。 安装 在这里下载最新release版的pkg文件双击安装 安装完成后，重启Xcode就可以在Xcode-&gt; Toolchains -&gt; Hikari 中看到已经有了编译器选项。 使用然后在 Build Settings -&gt; Other C Flags 中加入混淆标记 -mllvm -enable-bcfobf 启用伪控制流 -mllvm -enable-cffobf 启用控制流平坦化-mllvm -enable-splitobf 启用基本块分割 -mllvm -enable-subobf 启用指令替换 -mllvm -enable-acdobf 启用反class-dump -mllvm -enable-indibran 启用基于寄存器的相对跳转，配合其他加固可以彻底破坏IDA/Hopper的伪代码(俗称F5) -mllvm -enable-strcry 启用字符串加密 -mllvm -enable-funcwra 启用函数封装-mllvm -enable-allobf 依次性启用上述所有标记 修改Xcode 相关配置，得到混淆效果。 选择Xcode -&gt; Toolchains -&gt; Hikari 将混淆工具和项目关联 将所有与要运行的 target 相关的 target（包括pod进来的库），在BuildSetting中修改Enable Index-While-Building 的值改为 NO。 修该BuildSetting 中的Optimization Level 的值为 None[-O0] 重新编译项目即可。 可能遇到的问题 编译过程中报错，内容如下： Undefined symbols for architecture arm64: "___isOSVersionAtLeast", referenced from: -[MyLayoutPos posNumVal] in MyLayoutPos.o -[MyLayoutViewSizeClass myLayoutTopPadding] in MyLayoutSizeClass.o -[MyLayoutViewSizeClass myLayoutBottomPadding] in MyLayoutSizeClass.o -[MyLayoutViewSizeClass myLayoutLeadingPadding] in MyLayoutSizeClass.o -[MyLayoutViewSizeClass myLayoutTrailingPadding] in MyLayoutSizeClass.o _HikariFunctionWrapper.7182 in MyLayoutSizeClass.o _HikariFunctionWrapper.7188 in MyLayoutSizeClass.o ...ld: symbol(s) not found for architecture arm64clang-7: error: linker command failed with exit code 1 (use -v to see invocation) &quot;___isOSVersionAtLeast&quot;符号在arm64架构下找不到，根据以往的经验，出现这种错误的时候一般都是没有导入相关动态库(.Framework)，或静态库(.a)等造成的。庆幸的是已经有人在GitHub上提交了issues并给出了解决方案： 作者的回答：You probably need to explicitly link to clang-rt, available in your LLVM Toolchain directorySorry I mean clang-rt, at Hikari.xctoolchain/usr/lib/clang/10.0.0/lib/darwin/libclang_rt.ios.a (or macOS suffix) 意思是说：可能是缺少某个编译器库造成的，需要手动将这个库添加到Xcode的Linked Frameworks andLibraries动态链接库目录中。并说明了此库所在的目录Hikari.xctoolchain/usr/lib/clang/10.0.0/lib/darwin/libclang_rt.ios.a，意思是在Hikari编译器的子目录中找到文件libclang_rt.ios.a，并将他引入到Xcode项目中即可。查找路径顺序如下： 打开Show in Finder 定位到Hikari的安装目录，然后按照此路径usr/lib/clang/10.0.0/lib/darwin/libclang_rt.ios.a找到libclang_rt.ios.a文件，添加到Xcode的链接库中即可。 使用Hikari编译后，Archive 打包后，需要上传App Store 时可能会出现 “App Store” 按钮消失的问题，Archives页面右下角会出现一个提示字符： “App Store distribution requires an Xcode Default Toolchain” 意思是：App Store 发布版需要使用Xcode 默认的Toolchain (编译工具) 如下图所示： 出现这个问题是因为，我们使用了Hikari编译器 Archive的包，所以需要想办法去除这个警告即可。在Hikari的wiki文档中，我们发现作者在AppStore Guideline 安装指南中已经说明了解决方案： Alternatively, you could use Hikari’s toolchain to build normally then remove DefaultToolchainOverrideInfo from the IPA’s Info.plist 只需要在Arichive 包中的Info.plist 中找到这个值”DefaultToolchainOverrideInfo” 删除即可。可以看出此字段正是标记是否使用默认Toolchain的关键。 操作步骤为下面图示顺序，注意：记得删除字段后，一定要重启Xcode才能生效的。 删除上面红色框所示的字段即可，完了后要重启Xcode才会生效。 总结这是iOS代码混淆系列文章的最后一篇，着重讲解了iOS编译原理相关知识，编译前端Clang和编译后端LLVM在整个编译期间各自所做的工作。后面重点讲述了如何使用开源工具Hikari 进行编译混淆、加固，在实践过程中，对遇到的坑也讲了解决方案。 希望看了这几篇文章的小伙伴，能对iOS代码混淆有个初步的学习和了解，最好能结合自身条件加以实践，想必会理解的更深刻。]]></content>
      <tags>
        <tag>iOS</tag>
        <tag>代码混淆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS代码混淆之资源替换(二)]]></title>
    <url>%2F2019%2F03%2F05%2FiOS%E4%BB%A3%E7%A0%81%E6%B7%B7%E6%B7%86%E4%B9%8B%E8%B5%84%E6%BA%90%E6%9B%BF%E6%8D%A2(%E4%BA%8C)%2F</url>
    <content type="text"><![CDATA[这是iOS代码混淆系列文章的第二篇，其他两篇可以点击下方链接查看 iOS代码混淆之方法名替换 iOS代码混淆之编译优化 为什么要替换项目资源在某些公司项目开发当中 ，有时候需要通过技术手段，多次上架同一款产品。这些功能类似，且界面不同的产品也称作马甲包。为了达到将同一个包，经过较少的改动，快速更改为另一个类似的产品时，在代码混淆的基础之上还需要修改项目名称、静态资源等来达到目的。 需替换的资源及注意事项 工程内部：工程名称、类名前缀、BundleId、icon、启动图、静态资源等 产品界面：整体UI布局配色、产品功能逻辑、Tabbar顺序等 打包机器：更换打包电脑、使用WIFI网络、使用Application Uploader 上传不同二进制包 工具介绍及实践KLGenerateSpamCode是在GitHub上开源的一个可快速修改项目名称、文件前缀、生成垃圾代码等功能的集成工具，可方便的实现上述部分资源替换的功能。具体功能如下： 修改工程名 修改类名前缀 扫描工程中的代码，生成同等数量的 Category 文件，文件中及是同等方法数量的垃圾代码。 修改 xxx.xcassets 文件夹中的 png 资源文件名。 删除代码中的所有注释和空行。 由于在使用此工具之前，需要先配置修改参数，通过这些参数程序可以自动的修改项目中所需的内容，下面是从使用的角度对各项参数的解释： # 1. 项目名地址，注意：不是项目文件夹地址，是项目名那个目录/Users/jerry/Desktop/testProject0/century# 2. 修改项目名称，注意：放到最后修改,因为其他的修改需要依赖这个目录来查找-modifyProjectName century&gt;actualbyte# 3. 忽略文件夹，对添加的文件夹内的文件不执行修改。注意：多个文件夹之间用逗号隔开-ignoreDirNames ThirdPartLib,Tools,Category,Utils,MacrosDefine,Main,Resource,Support Files# 4. 修改类名前缀。没有前缀的会加上前缀，有前缀的会修改。注意：修改后是否重名-modifyClassNamePrefix /Users/jerry/Desktop/testProject0/century.xcodeproj CG&gt;WB# 5. 生成垃圾代码，注意：生成后的垃圾代码，需要拖入到工程目录中，如有报错可以自己修改或删除-spamCodeOut /Users/jerry/Desktop/testProject0/SpamCode WBLog# 6. 修改 xxx.xcassets 文件夹中的 png 资源文件名，必须指定(#1)的地址为xcassets所在的目录，才能生效。注意：此修改不会影响代码中图片的引用名称，只是对资源实体名和json配置文件中的修改。-handleXcassets# 7. 删除空行和注释 ，在项目根目录下运行，无效果可以单独运行一次。-deleteComments 上述的参数需要在下载的KLGenerateSpamCode工具目录中配置，如下图： ​ 参数配置好之后，Run 运行项目即可实现修改。另外，如果包含pod，需要到原项目文件夹下中执行pod update更新。 静态资源的修改静态资源包括项目的icon、启动图、和.xcassets 文件中的图标资源。其中为了更改UI页面元素，icon和启动图需要重新做，并替换进去，而xcassets 资源图片，可以通过修改其hash值达到修改资源的目的，具体可以使用MAC 下的一个终端工具实现。 ImageMagick：是一款创建、编辑、合成，转换图像的命令行工具，可对 png 图片做轻量压缩，既不损失图片质量，又可改变图片文件 hash 值，正是我们想要的工具。 如果电脑中没有安装的话，需要使用Homebrew来安装执行命令如下： brew install imagemagick 安装完成后，就可以使用ImageMagick的命令来修改： find . -iname "*.png" -exec echo &#123;&#125; \; -exec convert &#123;&#125; &#123;&#125; \; 总结本篇介绍了，如何通过修改工程名称、类前缀、资源hash值等方式，达到修改二进制包的目的，为上架苹果App Store 做准备。有兴趣的小伙伴可以亲自尝试一下，想必可以给您带来一些帮助。]]></content>
      <tags>
        <tag>iOS</tag>
        <tag>代码混淆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS代码混淆之方法名替换(一)]]></title>
    <url>%2F2019%2F03%2F02%2FiOS%E4%BB%A3%E7%A0%81%E6%B7%B7%E6%B7%86%E4%B9%8B%E6%96%B9%E6%B3%95%E5%90%8D%E6%9B%BF%E6%8D%A2(%E4%B8%80)%2F</url>
    <content type="text"><![CDATA[这是iOS代码混淆系列文章的第一篇，后两篇可以点击下方链接查看 iOS代码混淆之资源替换 iOS代码混淆之编译优化 前言在iOS开发中，某些项目为了保护代码安全，不被黑客攻破，通常需要在上架之前对源代码进行加密混淆，下面就介绍一种简单可行的Objective-C代码混淆方案。 混淆思路由于现在的逆向技术越来越高超，各种破解方案层出不穷，其中就可以使用class-dump命令行工具轻易的dump出demo.app文件中的所有头文件，代码立马回暴露在黑客面前，对项目产生了很多不利因素。因此将代码关键方法进行混淆保护迫在眉睫。 现有的一种混淆方案就是通过对指定class name 方法名进行MD5加密（显示乱码），然后通过脚本代码将加密的方法名生成到指定的头文件中，然后再使用宏替换的方式将混淆过的方法名在代码预编译阶段进行替换，使方法名即便在class-dump后也只会显示加密后的乱码显示，造成代码不易读，从而实现一定程度上的混淆保护。 混淆方式通过宏定义（#define）的方法名映射，进行字符串替换。这样做的好处在于可以将映射类别规整到一个头文件中，并#import 进项目的prefixHeader.h 预编译头文件中，方便在项目编译时进行全局替换。当不需要混淆的时候，则不导入该头文件即可。 混淆脚本下面的shell脚本引自的是“念茜-安全攻防”系列文章，实现思路是将敏感的方法名集中写入func.plist文件中，并逐一#define成随机字符串，最后写入一个.h头文件中。脚本代码如下： #!/usr/bin/env bashTABLENAME=symbolsSYMBOL_DB_FILE="symbols"STRING_SYMBOL_FILE="func.list"HEAD_FILE="$PROJECT_DIR/$PROJECT_NAME/codeObfuscation.h"export LC_CTYPE=C#维护数据库方便日后作排重createTable()&#123; echo "create table $TABLENAME(src text, des text);" | sqlite3 $SYMBOL_DB_FILE&#125;insertValue()&#123; echo "insert into $TABLENAME values('$1' ,'$2');" | sqlite3 $SYMBOL_DB_FILE&#125;query()&#123; echo "select * from $TABLENAME where src='$1';" | sqlite3 $SYMBOL_DB_FILE&#125;ramdomString()&#123; openssl rand -base64 64 | tr -cd 'a-zA-Z' |head -c 16&#125;rm -f $SYMBOL_DB_FILErm -f $HEAD_FILEcreateTabletouch $HEAD_FILEecho '#ifndef Demo_codeObfuscation_h#define Demo_codeObfuscation_h' &gt;&gt; $HEAD_FILEecho "//confuse string at `date`" &gt;&gt; $HEAD_FILEcat "$STRING_SYMBOL_FILE" | while read -ra line; do if [[ ! -z "$line" ]]; then ramdom=`ramdomString` echo $line $ramdom insertValue $line $ramdom echo "#define $line $ramdom" &gt;&gt; $HEAD_FILE fidoneecho "#endif" &gt;&gt; $HEAD_FILEsqlite3 $SYMBOL_DB_FILE .dump 配置步骤 创建混淆脚本文件confuse.sh，拷贝上述脚本代码到文件中保存，然后把该脚本文件放到项目根目录。例如：yourProject_path/目录下。 创建配置方法名称的列表文件，名为：func.list，此文件用于将需要混淆的方法名称写入进去，当项目编译时Build，会执行脚本遍历此文件中的方法名执行混淆操作，填写示例： -(void)sample; // 无参数方法-(void)seg1:(NSString *)string seg2:(NSUInteger)num; // 有参数方法// func.list 文件中这样写即可sampleseg1seg2 然后将创建好的func.list文件同样拷贝到项目根目录，也可以将confuse.sh 和func.list文件都添加进项目目录中，方便日后查看与维护，Xcode 左上角点击File --&gt; Add Files to &quot;xxx&quot;添加即可。 配置Build Phases脚本 // 脚本代码$PROJECT_DIR/confuse.sh 操作步骤如下图： 在PrefixHeader.h头文件中添加如下代码，意思是只有在Release模式下，才导入混淆头文件 // 混淆定义宏头文件，当在debug模式下，会执行脚本生成替换字符串，在release模式下导入宏文件执行替换#if (DEBUG != 1)#import "codeObfuscation.h"#endif 执行编译，可观察编译日志，查看custom shell 是否正确执行，如下图： 如果编译成功，会在项目根目录生成一个头文件codeObfuscation.h，此文件中正是包含了宏替换的关键内容，将此文件添加到项目中，会在release模式下进行替换。 可能会遇到的问题 第一次编译成功之前，即脚本代码执行之前是不会有codeObfuscation.h文件的，所以可能在PrefixHeader.h 文件中报错：Error_找不到该文件。解决方法：暂时注释掉即可。 在执行脚本时，编译日志处出现如下报错： 上图表示在执行脚本代码时，未能找到func.list 文件或其他文件，这时需要查看脚本代码中该文件的配置路径是否正确。解决方法：在confuse.sh文件中排查各项配置路径，并改正。 在执行脚本时，如遇到如下报错： confuse.sh: Permission denied 说明confuse.sh脚本文件没有可执行权限，需要在终端iTerm2 中给confuse.sh文件添加执行权限，如下操作即可： chmod a+x confuse.sh 使用class-dump 来测试class-dump是一个命令行工具，它利用Objective-C语言的runtime的特性，将存储在mach-O文件中的@interface和@protocol信息提取出来，并生成对应的.h文件。 它将xx.app格式的iOS项目文件进行分析，并通过命令生成该app源代码中的所有头文件列表，其中就包含了方法名称，可以清晰的查看dump出来的方法名是否已经被混淆。 安装 class-dump首先需要去这里：http://stevenygard.com/projects/class-dump/，下载class-dump-3.5.dmg压缩包，解压后将文件夹中的class-dump可执行文件拷贝到/usr/local/bin目录下。 具体操作步骤： 解压class-dump文件，如下图所示： 打开终端，输入如下命令，即可打开/usr/local/bin目录文件夹，然后将class-dump文件拷贝到此目录下。 open /usr/local/bin 给class-dump文件更改权限，终端输入如下命令： sudo chmod 777 /usr/local/bin/class-dump 在终端输入class-dump 查看是否安装成功，如显示命令的介绍和版本信息，就说明已经安装成功。 class-dump使用方法dump命令如下： class-dump -H /Users/xxx/Desktop/century.app -o /Users/jerry/Desktop/centuryHeaders 其中，-H 是生成头文件的命令，-o 是指定的头文件保存目录，/Users/xxx/Desktop/century.app 则是App文件的路径。 将在centuryHeaders文件夹中看到所有dump出的头文件。如下示例： Tips：如何从打包出来的xxx.ipa 文件中提取xxx.app 文件 先将xxx.ipa 文件后缀名修改为xxx.zip ， 然后解压xxx.zip 文件，会得到一个名为Payload的文件夹，文件夹中就放置的咱们需要的xxx.app文件，导出即可。 注意： 不是所有的xxx.app 文件都可以轻易的dump出头文件列表，只有未加密的，自己开发暂未上架App store 的app可以导出，App store 上架的三方应用由于被苹果加过密（加壳），不能直接dump，需要先进行砸壳（Dumpdecrypted工具）后，才能dump出需要的头文件。 后记至此，iOS开发中的Objective-C 代码混淆方案和class-dump技术的使用，都已经讲述清楚了，希望读者能体会到其中的安全攻防思路，在之后的开发中能多注意代码的安全防范。 注意：这种替换方法名的混淆方案会让App Store 审核被拒，2.3.1 - Performance We discovered that your app contains obfuscated code…，因此，不建议在App Store 上架的项目中使用。 参考资料： https://blog.csdn.net/yiyaaixuexi/article/details/29201699 https://www.jianshu.com/p/1e3fe0a8c048]]></content>
      <tags>
        <tag>iOS</tag>
        <tag>代码混淆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VPS下搭建ownCloud云盘]]></title>
    <url>%2F2018%2F11%2F03%2FVPS%E4%B8%8B%E6%90%AD%E5%BB%BAownCloud%E4%BA%91%E7%9B%98%2F</url>
    <content type="text"><![CDATA[前言鉴于各大网络云盘的各种限制，收费制度和用户体验并不好，利用VPS来搭建一个私有云盘就会变得越来越受欢迎，目前主流的开源软件ownCloud，NexCloud等都可以实现，下面我们就选ownCloud来搭建，vps选择的搬瓦工。 准备 一台VPS服务器，开启root权限 LAMP环境。ownCloud需要Web服务器，数据库和PHP才能正常工作。 设置LAMP（Linux，Apache，MySQL和PHP）服务器满足所有这些要求 安装ownCloud ，并配置相关参数。 设置LAMP环境“LAMP”是一组开放源代码软件，通常安装在一起以使服务器能够托管动态网站和网络应用。这个词其实是代表linux下的操作系统，Apache Web服务器的缩写。 站点数据存储在MySQL数据库（使用MariaDB），以及动态内容用PHP处理。 接下来，我们将在CentOS 7 VPS上安装一个LAMP。 CentOS将满足我们的第一个需求：一个Linux操作系统。 安装Apache 在终端输入命令安装： sudo yum install httpd 安装完成后，启动该服务 sudo systemctl start httpd.service 踩坑：如果无法启动报错，可能是没有设置防火墙对http/https的访问权限，输入下面命令开启 sudo firewall-cmd --permanent --zone=public --add-service=http sudo firewall-cmd --permanent --zone=public --add-service=httpssudo firewall-cmd --reload// 注意：如果提示 firewall 没有启动，则使用命令开启：// 注意：如果开启防火墙后，ssh 无法访问远程vps，可以在vps服务商提供的web页面中的root shell 控制台来设置上述命令。启动： systemctl start firewalld关闭： systemctl stop firewalld查看状态： systemctl status firewalld 开机禁用 ： systemctl disable firewalld开机启用 ： systemctl enable firewalld 再次使用命令来尝试开启httpd 服务。如果开启后(即没有报错信息)，下面设置开机默认启动： sudo systemctl enable httpd.service 输入http://你的服务器地址/测试是否安装成功，如果能访问就说明安装没问题，如下截图： 到这里就Apache 服务就安装完成了。 安装MySQL（MariaDB） 现在我们已经开始运行Web服务器，现在是安装MariaDB的时候了，这是一个MySQL插件替换。 启动数据库以后会提示输入数据库密码。由于我们是首次安装，直接enter即可，同时会提示你设置密码，输入你想要设置的数据库密码即可。 // 1. 安装数据库sudo yum install mariadb-server mariadb// 2. 启动数据库sudo systemctl enable mariadb.service// 3. 设置数据库，默认启动sudo systemctl enable mariadb.service 安装PHP PHP是我们的设置的组件，它将处理代码以显示动态内容。它可以运行脚本，连接到我们的MySQL数据库以获取信息，并将处理的内容传递到我们的Web服务器以显示。 注意此处CentOS 7默认PHP为5.4版本，ownCloud需要的PHP版本为5.6以上。所以此处我们安装PHP5.6版本。 执行下面命令升级php仓库 rpm -Uvh https://mirror.webtatic.com/yum/el7/epel-release.rpmrpm -Uvh https://mirror.webtatic.com/yum/el7/webtatic-release.rpm 执行安装 yum install -y php56w php56w-opcache php56w-xml php56w-mcrypt php56w-gd php56w-devel php56w-mysql php56w-intl php56w-mbstring php56w-openssl php56w-Tokenizer php56w-posix php56w-pcntl 这里要特别注意，可能会报错php56w-commen 和php5.4-commen发生文件冲突，导致安装不成功。因为centOS 7 系统默认会安装php5.4，如果直接执行安装高版本的话就会报错，通过踩坑经验最简单直接的方法就是删除掉原有的php5.4，在安装php56w或更高的版本： 删除旧版本php的方法命令： yum remove php-common 再次执行上面的安装命令，如果安装成功，执行下面命令重启httpd服务 sudo systemctl restart httpd.service 还可以通过执行命令php -v查看php的安装版本 为了测试PHP是否正确配置，可以创建一个php脚本来查看。在web根目录/var/www/html/创建一个info.php 文件，然后使用vim打开这个文件插入下面这句话保持退出： &lt;?php phpinfo(); ?&gt; 然后访问 http://你的服务器地址/info.php 如果没有问题页面会展示PHP的一些基本信息。 最后不忘删除我们的测试页面 sudo rm /var/www/html/info.php 到这里整个LAMP服务就都安装完成了。 安装ownCloudownCloud服务器软件包不存在于CentOS的默认存储库中。然而，ownCloud为发行版维护了一个专用的存储库。 首先，导入与他们释放钥匙rpm命令。 关键的授权包管理器yum信任库。 sudo rpm --import https://download.owncloud.org/download/repositories/stable/CentOS_7/repodata/repomd.xml.key 接下来，使用curl命令下载ownCloud库文件： sudo curl -L https://download.owncloud.org/download/repositories/stable/CentOS_7/ce:stable.repo -o /etc/yum.repos.d/ownCloud.repo 添加新文件后，用clean命令使yum知道所做的更改： sudo yum clean expire-cache// 如果提示类似下列命令，说明执行成功了OutputLoaded plugins: fastestmirrorCleaning repos: base ce_stable extras updates6 metadata files removed 最后，使用进行ownCloud安装yum实用程序和install命令： sudo yum install owncloud// 当提示Is this ok [y/d/N]:消息类型Y然后按ENTER键授权安装 配置数据库 mysql -u root -p// 可能会提示要输入密码，如果没有直接enter即可 为ownCloud 创建表，注意：每个MySQL的语句必须以分号;结束 CREATE DATABASE owncloud; 接下来，创建一个单独的MySQL用户帐户，与新创建的数据库进行交互。从管理和安全的角度来看，这样做不仅有利于数据安全更有利于我们日后的管理工作。与数据库的命名一样，选择您喜欢的用户名。我们选择owncloud GRANT ALL ON owncloud.* to 'owncloud'@'localhost' IDENTIFIED BY '此处填写你想要设置的密码'; 执行flush-privileges操作以确保MySQL应用权限分配 FLUSH PRIVILEGES; 数据库已经完成配置，执行命令exit退出。 配置ownCloud打开https://你的服务器地址/owncloud进入web管理页面 此时页面会提示你创建管理员账号，输入你想要的管理员账号和密码。在下方的数据库选项中选择MySQL／MariaDB，并且填入相应的账号和密码。此处填入的账号和密码即之前我们设置数据库时设置的账号和密码 点击Finish setup 完成安装。然后重新进入ownCloud web页面就可以进入到网盘。 到这里整个安装流程就都完成，可以开心的上传自己的文件啦。]]></content>
      <tags>
        <tag>ownCloud</tag>
        <tag>vps</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Method Swizzling]]></title>
    <url>%2F2018%2F10%2F21%2FMethod-Swizzling%2F</url>
    <content type="text"><![CDATA[前言Method swizzling 用于改变Foundation 框架中一个已存在的方法（selector）的实现。常用于对系统方法实现的替换，可实现插入自定义代码逻辑，代码hook等功能。 实现原理这项技术使得在运行时通过改变 selector 在类的消息分发列表中的映射从而改变方法的掉用成为可能。 例如：我们想要在一款 iOS app 中追踪每一个视图控制器被用户呈现了几次： 这可以通过在每个视图控制器的 viewDidAppear: 方法中添加追踪代码来实现，但这样会大量重复的样板代码。继承是另一种可行的方式，但是这要求所有被继承的视图控制器如 UIViewController, UITableViewController, UINavigationController 都在 viewDidAppear：实现追踪代码，这同样会造成很多重复代码。 幸运的是，这里有另外一种可行的方式：从 category 实现 method swizzling 。 实现方式#import &lt;objc/runtime.h&gt;@implementation UIViewController (Tracking)+ (void)load &#123; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; // dispatch_once() 保证代码只执行一次 Class class = [self class]; SEL originalSelector = @selector(viewWillAppear:); SEL swizzledSelector = @selector(xxx_viewWillAppear:); Method originalMethod = class_getInstanceMethod(class, originalSelector); Method swizzledMethod = class_getInstanceMethod(class, swizzledSelector); // When swizzling a class method, use the following: // Class class = object_getClass((id)self); // ... // Method originalMethod = class_getClassMethod(class, originalSelector); // Method swizzledMethod = class_getClassMethod(class, swizzledSelector); // 检查系统方法是否已经被交换 BOOL didAddMethod = class_addMethod(class, originalSelector, method_getImplementation(swizzledMethod), method_getTypeEncoding(swizzledMethod)); if (didAddMethod) &#123; class_replaceMethod(class, swizzledSelector, method_getImplementation(originalMethod), method_getTypeEncoding(originalMethod)); &#125; else &#123; method_exchangeImplementations(originalMethod, swizzledMethod); &#125; &#125;);&#125;#pragma mark - Method Swizzling// Discuss： 下面自定义方法不会造成递归调用，因为在交换了方法的实现后，xxx_viewWillAppear:方法的实现已经被替换为了 UIViewController -viewWillAppear：的原生实现，所以这里并不是在递归调用。- (void)xxx_viewWillAppear:(BOOL)animated &#123; [self xxx_viewWillAppear:animated]; NSLog(@"viewWillAppear: %@", self);&#125; 相关概念解释：+load vs +initializeswizzling 应该只在 +load 中完成。 在 Objective-C 的运行时中，每个类有两个方法都会自动调用。+load 是在一个类被初始装载时调用，+initialize 是在应用第一次调用该类的类方法或实例方法前调用的。两个方法都是可选的，并且只有在方法被实现的情况下才会被调用。 dispatch_onceswizzling 应该只在 dispatch_once 中完成。 由于 swizzling 改变了全局的状态，所以我们需要确保每个预防措施在运行时都是可用的。原子操作就是这样一个用于确保代码只会被执行一次的预防措施，就算是在不同的线程中也能确保代码只执行一次。Grand Central Dispatch 的 dispatch_once 满足了所需要的需求，并且应该被当做使用 swizzling 的初始化单例方法的标准。 Selectors, Methods, &amp; Implementations在 Objective-C 的运行时中，selectors, methods, implementations 指代了不同概念，然而我们通常会说在消息发送过程中，这三个概念是可以相互转换的。 下面是苹果 Objective-C Runtime Reference中的描述： Selector（typedef struct objc_selector *SEL）:在运行时 Selectors 用来代表一个方法的名字。Selector 是一个在运行时被注册（或映射）的C类型字符串。Selector由编译器产生并且在当类被加载进内存时由运行时自动进行名字和实现的映射。 Method（typedef struct objc_method *Method）:方法是一个不透明的用来代表一个方法的定义的类型。 Implementation（typedef id (*IMP)(id, SEL,...)）:这个数据类型指向一个方法的实现的最开始的地方。该方法为当前CPU架构使用标准的C方法调用来实现。该方法的第一个参数指向调用方法的自身（即内存中类的实例对象，若是调用类方法，该指针则是指向元类对象 metaclass ）。第二个参数是这个方法的名字 selector，该方法的真正参数紧随其后。 理解 selector, method, implementation 这三个概念之间关系的最好方式是：在运行时，类（Class）维护了一个消息分发列表来解决消息的正确发送。每一个消息列表的入口是一个方法（Method），这个方法映射了一对键值对，其中键值是这个方法的名字 selector（SEL），值是指向这个方法实现的函数指针 implementation（IMP）。 Method swizzling 修改了类的消息分发列表使得已经存在的 selector 映射了另一个实现 implementation，同时重命名了原生方法的实现为一个新的 selector。 注意事项：很多人认为交换方法实现会带来无法预料的结果。然而采取了以下预防措施后, method swizzling 会变得很可靠： 在交换方法实现后记得要调用原生方法的实现（除非你非常确定可以不用调用原生方法的实现）：APIs 提供了输入输出的规则，而在输入输出中间的方法实现就是一个看不见的黑盒。交换了方法实现并且一些回调方法不会调用原生方法的实现这可能会造成底层实现的崩溃。 避免冲突：为分类的方法加前缀，一定要确保调用了原生方法的所有地方不会因为你交换了方法的实现而出现意想不到的结果。 理解实现原理：只是简单的拷贝粘贴交换方法实现的代码而不去理解实现原理不仅会让 App 很脆弱，并且浪费了学习 Objective-C 运行时的机会。阅读 Objective-C Runtime Reference 并且浏览 能够让你更好理解实现原理。 持续的预防：不管你对你理解 swlzzling 框架，UIKit 或者其他内嵌框架有多自信，一定要记住所有东西在下一个发行版本都可能变得不再好使。做好准备，在使用这个黑魔法中走得更远，不要让程序反而出现不可思议的行为。 参考资料 NSHipster_Method-swizzling 关联对象associated objects]]></content>
  </entry>
  <entry>
    <title><![CDATA[RunLoop的实现原理及应用]]></title>
    <url>%2F2018%2F09%2F07%2FRunLoop%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[什么是RunLoop?为了保证线程能随时处理事件且不会退出，我们需要一个run loop 运行循环来一直保持能持续接收并处理各种事件，确保执行线程不被销毁。实现思路类似于如下代码： // Event loopfunction loop() &#123; initialize(); do &#123; var message = get_next_message(); process_message(message); &#125; while (message != quit);&#125; 当创建一个线程后，开启一个loop() 使用do-while 循环来不断的接收并处理事件，直到线程退出。实现这种模型的关键点在于：如何管理事件/消息，如何让线程在没有处理消息时休眠以避免资源占用，在有消息到来时立即唤醒。 所以，RunLoop 实际上就是一个对象，这个对象管理了其需要处理的事件和消息，并提供了一个入口函数来执行上面 Event Loop 的逻辑。线程执行了这个函数后，就会一直处于这个函数内部 “接受消息-&gt;等待-&gt;处理” 的循环中，直到这个循环结束（比如传入 quit 的消息），函数返回。 OSX/iOS 系统中，提供了这两个对象：NSRunLoop 和 CFRunLoopRef，来实现线程的运行循环。 CFRunLoopRef 是在 CoreFoundation 框架内的，它提供了纯 C 函数的 API，所有这些 API 都是线程安全的。NSRunLoop 是基于 CFRunLoopRef 的封装，提供了面向对象的 API，但是这些 API 不是线程安全的。 CFRunLoopRef 的代码是开源的，你可以在这里下载到整个 CoreFoundation 的源码来查看。 RunLoop与线程的关系在iOS中有两个线程对象pthread_t和NSThread，苹果文档中有说明NSThread只是pthread_t的封装，但是在Foundation框架中并没有发现这两个对象之间的转换接口，但是可以肯定的是pthread_t和NSThread是一一对应的，而且CFRunLoopRef 是基于pthread 来管理的，可以说是线程的管理器。 苹果不允许直接创建 RunLoop，它只提供了两个自动获取的函数：CFRunLoopGetMain() 和 CFRunLoopGetCurrent()。 这两个函数内部的逻辑大概是下面这样: /// 全局的Dictionary，key 是 pthread_t， value 是 CFRunLoopRefstatic CFMutableDictionaryRef loopsDic;/// 访问 loopsDic 时的锁static CFSpinLock_t loopsLock; /// 获取一个 pthread 对应的 RunLoop。CFRunLoopRef _CFRunLoopGet(pthread_t thread) &#123; OSSpinLockLock(&amp;loopsLock); if (!loopsDic) &#123; // 第一次进入时，初始化全局Dic，并先为主线程创建一个 RunLoop。 loopsDic = CFDictionaryCreateMutable(); CFRunLoopRef mainLoop = _CFRunLoopCreate(); CFDictionarySetValue(loopsDic, pthread_main_thread_np(), mainLoop); &#125; /// 直接从 Dictionary 里获取。 CFRunLoopRef loop = CFDictionaryGetValue(loopsDic, thread)); if (!loop) &#123; /// 取不到时，创建一个 loop = _CFRunLoopCreate(); CFDictionarySetValue(loopsDic, thread, loop); /// 注册一个回调，当线程销毁时，顺便也销毁其对应的 RunLoop。 _CFSetTSD(..., thread, loop, __CFFinalizeRunLoop); &#125; OSSpinLockUnLock(&amp;loopsLock); return loop;&#125; CFRunLoopRef CFRunLoopGetMain() &#123; return _CFRunLoopGet(pthread_main_thread_np());&#125; CFRunLoopRef CFRunLoopGetCurrent() &#123; return _CFRunLoopGet(pthread_self());&#125; 从上述代码中可以看出，线程和 RunLoop 之间是一一对应的，其关系是保存在一个全局的 Dictionary 里。线程刚创建时并没有 RunLoop，如果你不主动获取，那它一直都不会有。RunLoop 的创建是发生在第一次获取时，RunLoop 的销毁是发生在线程结束时。你只能在一个线程的内部获取其 RunLoop（主线程除外）。 RunLoop与其相关的几个类在 CoreFoundation 里面关于 RunLoop 的有5个类: CFRunLoopRef runloop结构体CFRunLoopModeRef 运行模式，有多种，下面会讲 CFRunLoopSourceRef 各种事件源（source、timer、observer）CFRunLoopTimerRef 基于事件的触发器 CFRunLoopRef：结构体定义如下： typedef struct __CFRunLoop * CFRunLoopRef;struct __CFRunLoop &#123; CFRuntimeBase _base; pthread_mutex_t _lock; /* locked for accessing mode list */ __CFPort _wakeUpPort; // used for CFRunLoopWakeUp Boolean _unused; volatile _per_run_data *_perRunData; // reset for runs of the run loop pthread_t _pthread; uint32_t _winthread; CFMutableSetRef _commonModes; // 字符串，记录所有标记为common的mode CFMutableSetRef _commonModeItems; // 所有commonMode的item(source、timer、observer) CFRunLoopModeRef _currentMode; CFMutableSetRef _modes; // CFRunLoopModeRef set struct _block_item *_blocks_head; struct _block_item *_blocks_tail; CFTypeRef _counterpart;&#125;; 从上述代码可以看出，一个runloop 对应一个pthread 线程，包含多个mode，一个mode又包含了多个mode items事件。_commonModes Set 里面存储着被标记为common的mode，标记common意味着可以同时在多种模式下执行事件。例如：在tableViewCell 中添加一个Timer，当滑动tableView时Timer任然在执行回调，这时的Timer添加在RunLoop中是以NSRunLoopCommonModesmode运行的。 CFRunLoopModeRef： 结构体定义大致如下： struct __CFRunLoopMode &#123; CFStringRef _name; // Mode Name, 例如 @"kCFRunLoopDefaultMode" CFMutableSetRef _sources0; // Set CFMutableSetRef _sources1; // Set CFMutableArrayRef _observers; // Array CFMutableArrayRef _timers; // Array ...&#125;; 一个 RunLoop 包含多个 Mode，每个 Mode 又包含若干个 Source/Timer/Observer。每次调用 RunLoop 的主函数时，只能指定其中一个 Mode，这个Mode被称作 CurrentMode。如果需要切换 Mode，只能退出 Loop，再重新指定一个 Mode 进入。这样做主要是为了分隔开不同组的 Source/Timer/Observer，让其互不影响。 CFRunLoopSourceRef：结构体定义如下： struct __CFRunLoopSource &#123; CFRuntimeBase _base; uint32_t _bits; pthread_mutex_t _lock; CFIndex _order; /* immutable */ CFMutableBagRef _runLoops; union &#123; CFRunLoopSourceContext version0; /* immutable, except invalidation */ CFRunLoopSourceContext1 version1; /* immutable, except invalidation */ &#125; _context;&#125;; 是事件产生的地方。Source有两个版本：Source0 和 Source1。 Source0：非基于 Port 的事件，只包含了一个回调（函数指针），它并不能主动触发事件。使用时，你需要先调用 CFRunLoopSourceSignal(source)，将这个 Source 标记为待处理，然后手动调用 CFRunLoopWakeUp(runloop) 来唤醒 RunLoop，让其处理这个事件。一般处理点击、触摸等事件 Source1：是基于Port的，包含了一个 mach_port 和一个回调（函数指针），被用于通过内核和其他线程相互发送消息。这种 Source 能主动唤醒 RunLoop 的线程，其原理在下面会讲到。 CFRunLoopTimerRef ：结构体定义如下： struct __CFRunLoopTimer &#123; CFRuntimeBase _base; uint16_t _bits; pthread_mutex_t _lock; CFRunLoopRef _runLoop; CFMutableSetRef _rlModes; CFAbsoluteTime _nextFireDate; CFTimeInterval _interval; /* immutable */ CFTimeInterval _tolerance; /* mutable */ uint64_t _fireTSR; /* TSR units */ CFIndex _order; /* immutable */ CFRunLoopTimerCallBack _callout; /* immutable */ CFRunLoopTimerContext _context; /* immutable, except invalidation */&#125;; 是基于时间的触发器，它和 NSTimer 是toll-free bridged 的，可以混用。其包含一个时间长度和一个回调（函数指针）。当其加入到 RunLoop 时，RunLoop会注册对应的时间点，当时间点到时，RunLoop会被唤醒以执行那个回调。 CFRunLoopObserverRef ：结构体定义如下： struct __CFRunLoopObserver &#123; CFRuntimeBase _base; pthread_mutex_t _lock; CFRunLoopRef _runLoop; CFIndex _rlCount; CFOptionFlags _activities; /* immutable */ CFIndex _order; /* immutable */ CFRunLoopObserverCallBack _callout; /* immutable */ CFRunLoopObserverContext _context; /* immutable, except invalidation */&#125;; 是观察者，每个 Observer 都包含了一个回调（函数指针），当 RunLoop 的状态发生变化时，观察者就能通过回调接受到这个变化。可以观测的时间点有以下几个： typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) &#123; kCFRunLoopEntry = (1UL &lt;&lt; 0), // 即将进入Loop kCFRunLoopBeforeTimers = (1UL &lt;&lt; 1), // 即将处理 Timer kCFRunLoopBeforeSources = (1UL &lt;&lt; 2), // 即将处理 Source kCFRunLoopBeforeWaiting = (1UL &lt;&lt; 5), // 即将进入休眠 kCFRunLoopAfterWaiting = (1UL &lt;&lt; 6), // 刚从休眠中唤醒 kCFRunLoopExit = (1UL &lt;&lt; 7), // 即将退出Loop&#125;; 上面的 Source/Timer/Observer 被统称为 mode item，一个 item 可以被同时加入多个 mode。但一个 item 被重复加入同一个 mode 时是不会有效果的。如果一个 mode 中一个 item 都没有，则 RunLoop 会直接退出，不进入循环。 RunLoopModeCFRunLoopMode 和 CFRunLoop 的结构大致如下： struct __CFRunLoopMode &#123; CFStringRef _name; // Mode Name, 例如 @"kCFRunLoopDefaultMode" CFMutableSetRef _sources0; // Set CFMutableSetRef _sources1; // Set CFMutableArrayRef _observers; // Array CFMutableArrayRef _timers; // Array ...&#125;; struct __CFRunLoop &#123; CFMutableSetRef _commonModes; // Set CFMutableSetRef _commonModeItems; // Set&lt;Source/Observer/Timer&gt; CFRunLoopModeRef _currentMode; // Current Runloop Mode CFMutableSetRef _modes; // Set ...&#125;; 这里有个概念叫 “CommonModes”：一个 Mode 可以将自己标记为”Common”属性（通过将其 ModeName（NSRunLoopCommonModes，通用/共用Mode） 添加到 RunLoop 的 “commonModes” 中）。每当 RunLoop 的内容发生变化时，RunLoop 都会自动将 _commonModeItems 里的 Source/Observer/Timer 同步到具有 “Common” 标记的所有Mode里。 应用场景举例： iOS中的主线程runloop有2个预设的Mode：kCFRunLoopDefaultMode（NSDefaultRunLoopMode） 和 UITrackingRunLoopMode（UITrackingRunLoopMode），第一个是默认的mode，也是App平时所处的状态，第二个是追踪ScrollView滑动时的状态。 例如当一个tableViewCell中添加一个运行在DefaultRunLoopMode下的Timer时，那么当滑动tableView的时候，RunLoop会将mode切换为TrackingRunLoopMode用于对scrollView页面滑动手势的跟踪，这时Timer就不会被回调执行。那么，如何让tableView在滑动的同时Timer任然在执行回调计时呢，一种方式是将Timer分别添加到这两个Mode中。 还有一种更简便的方式就是修改Timer的mode为：kCFRunLoopCommonModes (NSRunLoopCommonModes)，即将Timer添加到RunLoop的_commonModeItems中，这样Timer的定时事件会分别添加到kCFRunLoopDefaultMode（NSDefaultRunLoopMode） 和 UITrackingRunLoopMode（UITrackingRunLoopMode）中，这样不论页面是否在滑动，都不会影响Timer的计时回调。 CFRunLoop对外暴露的管理 Mode 接口只有下面2个: // 给runloop 添加modevoid CFRunLoopAddCommonMode(CFRunLoopRef runloop, CFStringRef modeName);// 获取RunLoop当前运行的modeSInt32 CFRunLoopRunInMode(CFStringRef modeName, ...); Mode 暴露的管理 mode item 的接口有下面几个： // 对runloop添加source事件源，并指定modeCFRunLoopAddSource(CFRunLoopRef rl, CFRunLoopSourceRef source, CFStringRef modeName);// 对runloop添加observer观察，并指定观察modeCFRunLoopAddObserver(CFRunLoopRef rl, CFRunLoopObserverRef observer, CFStringRef modeName);// 对runloop添加Timer定时源，并指定modeCFRunLoopAddTimer(CFRunLoopRef rl, CFRunLoopTimerRef timer, CFStringRef mode);// 移除source源CFRunLoopRemoveSource(CFRunLoopRef rl, CFRunLoopSourceRef source, CFStringRef modeName);// 移除观察者CFRunLoopRemoveObserver(CFRunLoopRef rl, CFRunLoopObserverRef observer, CFStringRef modeName);// 移除定时器TimerCFRunLoopRemoveTimer(CFRunLoopRef rl, CFRunLoopTimerRef timer, CFStringRef mode); 你只能通过 mode name 来操作内部的 mode，当你传入一个新的 mode name 但 RunLoop 内部没有对应 mode 时，RunLoop会自动帮你创建对应的 CFRunLoopModeRef。对于一个 RunLoop 来说，其内部的 mode 只能增加不能删除。 苹果公开提供的 Mode 有两个：kCFRunLoopDefaultMode (NSDefaultRunLoopMode) 和 UITrackingRunLoopMode，你可以用这两个 Mode Name 来操作其对应的 Mode。 同时苹果还提供了一个操作 Common 标记的字符串：kCFRunLoopCommonModes (NSRunLoopCommonModes)，你可以用这个字符串来操作 Common Items，或标记一个 Mode 为 “Common”。使用时注意区分这个字符串和其他 mode name。 RunLoop的内部逻辑根据苹果在文档里的说明，RunLoop 内部的逻辑大致如下：题图引用自ibireme大神的《深入理解RunLoop》博文。 可以看到，实际上 RunLoop 就是这样一个函数，其内部是一个 do-while 循环。当你调用 CFRunLoopRun() 时，线程就会一直停留在这个循环里；直到超时或被手动停止，该函数才会返回。 iOS中RunLoop实现的功能首先我们可以看一下 App 启动后 RunLoop 的状态： CFRunLoop &#123; current mode = kCFRunLoopDefaultMode common modes = &#123; UITrackingRunLoopMode kCFRunLoopDefaultMode &#125; common mode items = &#123; // source0 (manual) CFRunLoopSource &#123;order =-1, &#123; callout = _UIApplicationHandleEventQueue&#125;&#125; CFRunLoopSource &#123;order =-1, &#123; callout = PurpleEventSignalCallback &#125;&#125; CFRunLoopSource &#123;order = 0, &#123; callout = FBSSerialQueueRunLoopSourceHandler&#125;&#125; // source1 (mach port) CFRunLoopSource &#123;order = 0, &#123;port = 17923&#125;&#125; CFRunLoopSource &#123;order = 0, &#123;port = 12039&#125;&#125; CFRunLoopSource &#123;order = 0, &#123;port = 16647&#125;&#125; CFRunLoopSource &#123;order =-1, &#123; callout = PurpleEventCallback&#125;&#125; CFRunLoopSource &#123;order = 0, &#123;port = 2407, callout = _ZL20notify_port_callbackP12__CFMachPortPvlS1_&#125;&#125; CFRunLoopSource &#123;order = 0, &#123;port = 1c03, callout = __IOHIDEventSystemClientAvailabilityCallback&#125;&#125; CFRunLoopSource &#123;order = 0, &#123;port = 1b03, callout = __IOHIDEventSystemClientQueueCallback&#125;&#125; CFRunLoopSource &#123;order = 1, &#123;port = 1903, callout = __IOMIGMachPortPortCallback&#125;&#125; // Ovserver CFRunLoopObserver &#123;order = -2147483647, activities = 0x1, // Entry callout = _wrapRunLoopWithAutoreleasePoolHandler&#125; CFRunLoopObserver &#123;order = 0, activities = 0x20, // BeforeWaiting callout = _UIGestureRecognizerUpdateObserver&#125; CFRunLoopObserver &#123;order = 1999000, activities = 0xa0, // BeforeWaiting | Exit callout = _afterCACommitHandler&#125; CFRunLoopObserver &#123;order = 2000000, activities = 0xa0, // BeforeWaiting | Exit callout = _ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv&#125; CFRunLoopObserver &#123;order = 2147483647, activities = 0xa0, // BeforeWaiting | Exit callout = _wrapRunLoopWithAutoreleasePoolHandler&#125; // Timer CFRunLoopTimer &#123;firing = No, interval = 3.1536e+09, tolerance = 0, next fire date = 453098071 (-4421.76019 @ 96223387169499), callout = _ZN2CAL14timer_callbackEP16__CFRunLoopTimerPv (QuartzCore.framework)&#125; &#125;, modes ＝ &#123; CFRunLoopMode &#123; sources0 = &#123; /* same as 'common mode items' */ &#125;, sources1 = &#123; /* same as 'common mode items' */ &#125;, observers = &#123; /* same as 'common mode items' */ &#125;, timers = &#123; /* same as 'common mode items' */ &#125;, &#125;, CFRunLoopMode &#123; sources0 = &#123; /* same as 'common mode items' */ &#125;, sources1 = &#123; /* same as 'common mode items' */ &#125;, observers = &#123; /* same as 'common mode items' */ &#125;, timers = &#123; /* same as 'common mode items' */ &#125;, &#125;, CFRunLoopMode &#123; sources0 = &#123; CFRunLoopSource &#123;order = 0, &#123; callout = FBSSerialQueueRunLoopSourceHandler&#125;&#125; &#125;, sources1 = (null), observers = &#123; CFRunLoopObserver &gt;&#123;activities = 0xa0, order = 2000000, callout = _ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv&#125; )&#125;, timers = (null), &#125;, CFRunLoopMode &#123; sources0 = &#123; CFRunLoopSource &#123;order = -1, &#123; callout = PurpleEventSignalCallback&#125;&#125; &#125;, sources1 = &#123; CFRunLoopSource &#123;order = -1, &#123; callout = PurpleEventCallback&#125;&#125; &#125;, observers = (null), timers = (null), &#125;, CFRunLoopMode &#123; sources0 = (null), sources1 = (null), observers = (null), timers = (null), &#125; &#125;&#125; 可以看到，系统默认注册了5个Mode: kCFRunLoopDefaultMode: App的默认 Mode，通常主线程是在这个 Mode 下运行的。 UITrackingRunLoopMode: 界面跟踪 Mode，用于 ScrollView 追踪触摸滑动，保证界面滑动时不受其他 Mode 影响。 UIInitializationRunLoopMode: 在刚启动 App 时第进入的第一个 Mode，启动完成后就不再使用 GSEventReceiveRunLoopMode: 接受系统事件的内部 Mode，通常用不到。 kCFRunLoopCommonModes: 这是一个占位的 Mode，没有实际作用。 下面是RunnLoop在iOS开发中的相关应用 AutoreleasePoolApp启动后，苹果在主线程 RunLoop 里注册了两个 Observer，其回调都是 _wrapRunLoopWithAutoreleasePoolHandler()。 第一个 Observer 监视的事件是 Entry(即将进入Loop)，其回调内会调用 _objc_autoreleasePoolPush() 创建自动释放池。其 order 是-2147483647，优先级最高，保证创建释放池发生在其他所有回调之前。 第二个 Observer 监视了两个事件： BeforeWaiting(准备进入休眠) 时调用_objc_autoreleasePoolPop() 和 _objc_autoreleasePoolPush() 释放旧的池并创建新池；Exit(即将退出Loop) 时调用 _objc_autoreleasePoolPop() 来释放自动释放池。这个 Observer 的 order 是 2147483647，优先级最低，保证其释放池子发生在其他所有回调之后。 在主线程执行的代码，通常是写在诸如事件回调、Timer回调内的。这些回调会被 RunLoop 创建好的 AutoreleasePool 环绕着，所以不会出现内存泄漏，开发者也不必显示创建 Pool 了。 事件响应苹果注册了一个 Source1 (基于 mach port 的) 用来接收系统事件，其回调函数为 __IOHIDEventSystemClientQueueCallback()。 当一个硬件事件(触摸/锁屏/摇晃等)发生后，首先由 IOKit.framework 生成一个 IOHIDEvent 事件并由 SpringBoard 接收。这个过程的详细情况可以参考这里。SpringBoard 只接收按键(锁屏/静音等)，触摸，加速，接近传感器等几种 Event，随后用 mach port 转发给需要的App进程。随后苹果注册的那个 Source1 就会触发回调，并调用 _UIApplicationHandleEventQueue() 进行应用内部的分发。 _UIApplicationHandleEventQueue() 会把 IOHIDEvent 处理并包装成 UIEvent 进行处理或分发，其中包括识别 UIGesture/处理屏幕旋转/发送给 UIWindow 等。通常事件比如 UIButton 点击、touchesBegin/Move/End/Cancel 事件都是在这个回调中完成的。 手势识别当上面的 _UIApplicationHandleEventQueue() 识别了一个手势时，其首先会调用 Cancel 将当前的 touchesBegin/Move/End 系列回调打断。随后系统将对应的 UIGestureRecognizer 标记为待处理。 苹果注册了一个 Observer 监测 BeforeWaiting (Loop即将进入休眠) 事件，这个Observer的回调函数是 _UIGestureRecognizerUpdateObserver()，其内部会获取所有刚被标记为待处理的 GestureRecognizer，并执行GestureRecognizer的回调。 当有 UIGestureRecognizer 的变化(创建/销毁/状态改变)时，这个回调都会进行相应处理。 界面更新当在操作 UI 时，比如改变了 Frame、更新了 UIView/CALayer 的层次时，或者手动调用了 UIView/CALayer 的 setNeedsLayout/setNeedsDisplay方法后，这个 UIView/CALayer 就被标记为待处理，并被提交到一个全局的容器去。 苹果注册了一个 Observer 监听 BeforeWaiting(即将进入休眠) 和 Exit (即将退出Loop) 事件，回调去执行一个很长的函数：_ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv()。这个函数里会遍历所有待处理的 UIView/CAlayer 以执行实际的绘制和调整，并更新 UI 界面。 这个函数内部的调用栈大概是这样的： _ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv() QuartzCore:CA::Transaction::observer_callback: CA::Transaction::commit(); CA::Context::commit_transaction(); CA::Layer::layout_and_display_if_needed(); CA::Layer::layout_if_needed(); [CALayer layoutSublayers]; [UIView layoutSubviews]; CA::Layer::display_if_needed(); [CALayer display]; [UIView drawRect]; 定时器NSTimer 其实就是 CFRunLoopTimerRef，他们之间是 toll-free bridged 的。一个 NSTimer 注册到 RunLoop 后，RunLoop 会为其重复的时间点注册好事件。例如 10:00, 10:10, 10:20 这几个时间点。RunLoop为了节省资源，并不会在非常准确的时间点回调这个Timer。Timer 有个属性叫做 Tolerance (宽容度)，标示了当时间点到后，容许有多少最大误差。 如果某个时间点被错过了，例如执行了一个很长的任务，则那个时间点的回调也会跳过去，不会延后执行。就比如等公交，如果 10:10 时我忙着玩手机错过了那个点的公交，那我只能等 10:20 这一趟了。 CADisplayLink 是一个和屏幕刷新率一致的定时器（但实际实现原理更复杂，和 NSTimer 并不一样，其内部实际是操作了一个 Source）。如果在两次屏幕刷新之间执行了一个长任务，那其中就会有一帧被跳过去（和 NSTimer 相似），造成界面卡顿的感觉。在快速滑动TableView时，即使一帧的卡顿也会让用户有所察觉。Facebook 开源的 AsyncDisplayLink 就是为了解决界面卡顿的问题，其内部也用到了 RunLoop，这个稍后我会再单独写一页博客来分析。 PerformSelecter当调用 NSObject 的 performSelecter:afterDelay: 后，实际上其内部会创建一个 Timer 并添加到当前线程的 RunLoop 中。所以如果当前线程没有 RunLoop，则这个方法会失效。 当调用 performSelector:onThread: 时，实际上其会创建一个 Timer 加到对应的线程去，同样的，如果对应线程没有 RunLoop 该方法也会失效。 最后本文秉着学习RunLoop的应用及内部实现原理，阅读了大量前辈优秀的博文、以及查阅苹果开源代码进行整理学习，其中大部分参阅了ibireme大神的《深入理解RunLoop》一文，并有部分内容及图片的引用，感谢ibireme对于RunLoop文章的分享。 参考/引用 深入理解runloop iOS多线程编程指南(三)RunLoop]]></content>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入剖析Autorelease Pool (自动释放池)]]></title>
    <url>%2F2018%2F08%2F28%2F%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90Autorelease-Pool-%E8%87%AA%E5%8A%A8%E9%87%8A%E6%94%BE%E6%B1%A0%2F</url>
    <content type="text"><![CDATA[前言在MRC的内存管理模式下，可以将创建的对象加入自动释放池，程序员则无需手动调用release方法来释放对象，而是当自动释放池销毁的时候会对其中的每一个对象发送release消息，从而达到自动释放的目的。下面我们一步步揭开它的神秘面纱，深度剖析autoreleasepool的实现原理。 @autoreleasepool 实现原理main.m文件中的@autoreleasepool() 在iOS代码main.m文件中，我们可以看到@autoreleasepool{}代码块，其中包含的这一行代码将所有事件、消息全部交给了UIApplication来处理。需要注意的是：整个iOS的应用都是包含在一个自动释放池block中的。 // main.m 文件中的内容int main(int argc, char * argv[]) &#123; @autoreleasepool &#123; return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));&#125; 我们在命令行中使用 clang -rewrite-objc main.m 让编译器重新改写这个文件，可以看到该文件的c++代码实现细节，关键代码如下： ...int main(int argc,const char * argv[])&#123; /* @autoreleasepool */ &#123; __AtAutoreleasepool __autoreleasepool; &#125; return 0;&#125;... 通过分析上述代码，可以看到 {__AtAutoreleasepool __autoreleasepool;} 这段代码即是@atuoreleasepool的c++实现，通过创建一个__autoreleasepool对象来管理其他对象的自动释放操作。 分析__AtAutoreleasepool 结构体 我们在main.cpp文件中，定位到了其结构体的定义： ...struct __AtAutoreleasepool &#123; __AtAutoreleasepool() &#123; atautoreleasepoolobj = objc_autoreleasePoolPush();&#125; ~__AtAutoreleasepool() &#123; objc_autoreleasePoolPop(atautoreleasepoolpbj);&#125; void * atautoreleasepoolobj;&#125;... /*代码解释：1. __AtAutoreleasepool() 是其构造函数2. ~__AtAutoreleasepool() 是其析构函数析构函数：与构造函数相反, 析构函数是在对象被撤销时被自动调用, 用于对成员撤销时的一些清理工作, 例如在前面提到的手动释放使用 new 或 malloc 进行申请的内存空间。析构函数的特点：1. 析构函数函数名与类名相同, 紧贴在名称前面用波浪号 ~ 与构造函数进行区分, 例如: ~Point();2. 构造函数没有返回类型, 也不能指定参数, 因此析构函数只能有一个, 不能被重载;3. 当对象被撤销时析构函数被自动调用, 与构造函数不同的是, 析构函数可以被显式的调用, 以释放对象中动态申请的内存。*/ 这个结构体会在初始化时调用 objc_autoreleasePoolPush() 方法，会在析构时调用 objc_autoreleasePoolPop 方法。 这表明，我们的 main 函数在实际工作时其实是这样的： int main(int argc, const char * argv[]) &#123; &#123; void * atautoreleasepoolobj = objc_autoreleasePoolPush(); // do whatever you want objc_autoreleasePoolPop(atautoreleasepoolobj); &#125; return 0;&#125; 通过分析将@autoreleasepool{}的代码展开即可得到上述代码实现，在一个代码块中，先创建atautoreleasepoolobj 对象，然后中间插入iOS应用入口代码，最后自动调用析构函数objc_autoreleasePoolPop给当中的每一个对象发送 -release 消息销毁对象。 AutoreleasePool 实现原理从上一节我们对__AtAutoreleasepool结构体分析可以看出，自动释放池得以实现的核心是在它的构造函数和析构函数中，所以我们接下来就分析这两个函数的内部实现。 我们定位到 objc_autoreleasePoolPush 和 objc_autoreleasePoolPop 函数的实现代码如下： void *objc_autoreleasePoolPush(void) &#123; return AutoreleasePoolPage::push();&#125;void objc_autoreleasePoolPop(void *ctxt) &#123; AutoreleasePoolPage::pop(ctxt);&#125; 从函数实现中可以看出，内部使用了一个名为AutoreleasePoolPage的c++类，通过调用此类的push() 方法和pop()方法来实现被释放对象的添加和销毁操作。 既然这几个方法是拨开云雾的关键，那么我们就逐一分析：AutoreleasePoolPage的结构、objc_autoreleasePoolPush（） 方法、objc_autoreleasePoolPop（）方法。 AutoreleasePoolPage的结构 AutoreleasePoolPage的一个c++类，它在NSObject.mm 文件中的定义如下： class AutoreleasePoolPage &#123; magic_t const magic; id *next; pthread_t const thread; AutoreleasePoolPage * const parent; AutoreleasePoolPage *child; uint32_t const depth; uint32_t hiwat;&#125;;/* 类成员结构解析： magic：用来校验AutoreleasePoolPage 的结构是否完整 *next：指向最新添加的auoreleased 对象的下一个位置，初始化时指向begin() thread：指向当前线程 parent：指向父结点，第一个结点的 parent 值为 nil child：指向子结点，最后一个结点的 child 值为 nil depth：代表深度，从 0 开始，往后递增 1； hiwat：代表 high water mark 。*/ 一个空的AutoreleasePoolPage 的内存结构如下图所示： 另外，当 next == begin() 时，表示 AutoreleasePoolPage 为空；当 next == end() 时，表示 AutoreleasePoolPage 已满。 每个自动释放池都是由一系列的AutoreleasePoolPage组成的，并且每一个AutoreleasePoolPage的大小都是4096字节（16进制0x1000） AutoreleasePoolPage在自动释放池中的组织结构 AutoreleasePoolPage在自动释放池中是以双向链表的形式链接起来的： parent 和 child 就是用来构造双向链表的指针。 objc_autoreleasePoolPush() 方法解析 其中有个很重要定义POOL_SENTINEL ，它叫哨兵对象，本质是一个nil的宏定义： #define POOL_SENTINEL nil 在每个自动释放池初始化调用 objc_autoreleasePoolPush() 的时候，都会把一个 POOL_SENTINEL push 到自动释放池的栈顶，并且返回这个 POOL_SENTINEL 哨兵对象。上面讲解@autoreleasepool()代码块的时候，其中的atautoreleasepoolobj对象就是一个POOL_SENTINEL。 接下来我们分析objc_autoreleasePoolPush方法的实现，从上面的分析可以得出objc_autoreleasePoolPush方法、push()方法等的实现如下： /* 代码从上至下依次调用 */ // 1. objc_autoreleasePoolPush()void *objc_autoreleasePoolPush(void) &#123; return AutoreleasePoolPage::push();&#125;// 2. push()static inline void *push() &#123; return autoreleaseFast(POOL_SENTINEL);&#125;// 3. autoreleaseFast(), 参数obj 就是需要自动释放的对象static inline id *autoreleaseFast(id obj)&#123; AutoreleasePoolPage *page = hotPage(); if (page &amp;&amp; !page-&gt;full()) &#123; return page-&gt;add(obj); &#125; else if (page) &#123; return autoreleaseFullPage(obj, page); &#125; else &#123; return autoreleaseNoPage(obj); &#125;&#125; 上述方法autoreleaseFast:的实现中有三种选择： hotPage：可以理解为当前正在使用的 AutoreleasePoolPage 当page 存在，且没有满时：调用page-&gt;add(obj)方法将对象添加至AutoreleasePoolPage的栈中 当page存在，已经满时： 调用autoreleaseFullPage初始化一个新页 调用page-&gt;add(obj)将obj添加到新创建的page的栈中 无page时： 调用autoreleaseNoPage创建一个hotPage 调用page-&gt;add(obj)方法将对象添加至AutoreleasePoolPage的栈中 page-&gt; add() 方法的实现 id *add(id obj) &#123; id *ret = next; *next = obj; next++; return ret;&#125; 将obj对象添加到hotPage中，并移动 *next指针指向obj对象的下一个位置，本质上是一个压栈操作。 objc_autoreleasePoolPop() 方法解析 回顾上述分析，objc_autoreleasePoolPop方法的实现如下： void objc_autoreleasePoolPop(void *ctxt) &#123; if (UseGC) return; // fixme rdar://9167170 if (!ctxt) return; AutoreleasePoolPage::pop(ctxt);&#125;/*看起来传入任何一个指针都是可以的，但是在整个工程并没有发现传入其他对象的例子。不过在这个方法中传入其它的指针也是可行的，会将自动释放池释放到相应的位置。*/ pop 函数的入参就是 push 函数的返回值，也就是 POOL_SENTINEL 的内存地址 。当执行 pop 操作时，内存地址在 POOL_SENTINEL 之后的所有 autoreleased 对象都会被 release 。直到 POOL_SENTINEL 所在 page 的 next 指向 POOL_SENTINEL 为止。 下面是某个线程的 autoreleasepool 堆栈的内存结构图，在这个 autoreleasepool 堆栈中总共有两个 POOL_SENTINEL ，即有两个 autoreleasepool 。该堆栈由三个 AutoreleasePoolPage 结点组成，第一个 AutoreleasePoolPage 结点为 coldPage() ，最后一个 AutoreleasePoolPage 结点为 hotPage() 。其中，前两个结点已经满了，最后一个结点中保存了最新添加的 autoreleased 对象 objr3 的内存地址。 此时，如果执行 pop(token1) 操作，那么该 autoreleasepool 堆栈的内存结构将会变成如下图所示： autorelease 方法 最后我们分析下autorelease 方法内部的实现原理。首先，我们先看一下方法调用栈： - [obj autorelease]└── id objc_object::rootAutorelease() └── id objc_object::rootAutorelease2() └── static id AutoreleasePoolPage::autorelease(id obj) └── static id AutoreleasePoolPage::autoreleaseFast(id obj) ├── id *add(id obj) ├── static id *autoreleaseFullPage(id obj, AutoreleasePoolPage *page) │ ├── AutoreleasePoolPage(AutoreleasePoolPage *newParent) │ └── id *add(id obj) └── static id *autoreleaseNoPage(id obj) ├── AutoreleasePoolPage(AutoreleasePoolPage *newParent) └── id *add(id obj) 从上面从调用栈中可以看出， 会先调用AutoreleasePoolPage的autorelease()方法， 最后会调用上面提到autoreleaseFast方法，将obj对象添加AutoreleasePoolPage中。 下面是autorelease()方法的实现： static inline id autorelease(id obj)&#123; assert(obj); assert(!obj-&gt;isTaggedPointer()); id *dest __unused = autoreleaseFast(obj); // 最终会调用 autoreleaseFast 方法 assert(!dest || *dest == obj); return obj;&#125; 总结整个自动释放池 AutoreleasePool 的实现以及 autorelease 方法都已经分析完了，归纳总结后，得出了下面的几个要点： 自动释放池是由 AutoreleasePoolPage 以双向链表的方式实现的 当对象调用 autorelease 方法时，会将对象加入 AutoreleasePoolPage 的栈中 调用 AutoreleasePoolPage::pop 方法会向栈中的对象发送 release 消息 参考/引用 自动释放池的前世今生 —- 深入解析 autoreleasepool Objective-C Autorelease Pool 的实现原理]]></content>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[离屏渲染知多少?]]></title>
    <url>%2F2018%2F07%2F08%2F%E7%A6%BB%E5%B1%8F%E6%B8%B2%E6%9F%93%E7%9F%A5%E5%A4%9A%E5%B0%91%2F</url>
    <content type="text"><![CDATA[预备知识OpenGL中，GPU屏幕渲染有两种方式: On-Screen Rendering (当前屏幕渲染)：指的是GPU的渲染操作是在当前用于显示的屏幕缓冲区进行。 Off-Screen Rendering (离屏渲染)：指的是在GPU在当前屏幕缓冲区以外开辟一个缓冲区进行渲染操作。 当前屏幕渲染不需要额外创建新的缓存，也不需要开启新的上下文，相对于离屏渲染性能更好。但是受当前屏幕渲染的局限因素限制(只有自身上下文、屏幕缓存有限等)，当前屏幕渲染有些情况下的渲染解决不了的，就使用到离屏渲染。 相比于当前屏幕渲染，离屏渲染的代价是很高的，主要体现在两个方面： 创建新缓冲区：要想进行离屏渲染，首先要创建一个新的缓冲区。 上下文切换：离屏渲染的整个过程，需要多次切换上下文环境：先从当前屏幕切换到离屏，等待离屏渲 为什么要离屏渲染？有些效果被认为不能直接呈现于屏幕，而需要在别的地方做额外的处理预合成。图层属性的混合体没有预合成之前不能直接在屏幕中绘制，所以就需要屏幕外渲染。屏幕外渲染并不意味着软件绘制，但是它意味着图层必须在被显示之前在一个屏幕外上下文中被渲染（不论CPU还是GPU）。 在iOS开发中，当设置了以下属性时，会触发离屏渲染： 为图层设置遮罩（self.view.layer.mask = ?） 为图层设置圆角且开启遮罩属性（self.view.layer.corner = 5;self.view.layer.masksToBounds = YES） 注意：如果仅当给视图切圆角self.view.layer.corner = 5;，而没有设置遮罩属性self.view.layer.masksToBounds = YES;时，是不会触发离屏渲染的。只有设置了遮罩相关属性就会触发离屏渲染。 为图层设置阴影属性时（self.view.layer.shadow） 为图层设置栅格化（self.view.layer.shouldRasterize = YES） 设置图层不透明度属性layer.allowsGroupOpacity = YES或设置layer.opacity的值小于1.0时 图层设置了这些属性时：view.layer.edgeAntialiasingMask（设置边缘防锯齿遮罩），view.layer.allowsEdgeAntialiasing = YES（是否允许边缘防锯齿化为YES时，默认值：NO） 使用CGContext在drawRect :方法中绘制大部分情况下会导致离屏渲染，甚至仅仅是一个空的实现。 注意：这种方式触发的离屏渲染是CPU渲染，触发的CPU版本的离屏渲染，不是GPU的离屏渲染。如果我们重写了drawRect：方法并且使用任何Core Graphics Api 技术进行绘制操作时，都涉及到了CPU渲染。整个渲染过程由CPU在App内同步地完成，渲染得到的bitmap(位图)最后再交由GPU用于显示。 文本（任何种类，包括UILabel，CATextLayer，Core Text等）。 优化方案1. 圆角优化苹果官方对离屏渲染产生的性能问题也进行了优化： iOS 9.0 之前UIimageView跟UIButton设置圆角都会触发离屏渲染。 iOS 9.0 之后UIButton设置圆角会触发离屏渲染，而UIImageView里png图片设置圆角不会触发离屏渲染了，如果设置其他阴影效果之类的还是会触发离屏渲染的。 我们一般对UIView 、UIImageView 设置圆角时使用以下方式： imageView.layer.cornerRadius = 5.0;imageView.layer.masksToBounds = YES;// 注：这种设置圆角的组合方式，就会触发离屏渲染 优化方案1：使用贝塞尔曲线UIBezierPath 和Core Graphics 组合画出一个带有圆角的UIImage，如下示例： UIImageView *imageView = [[UIImageView alloc]initWithFrame:CGRectMake(0, 0, 100, 100)]; imageView.image = [UIImage imageNamed:@"myImg"]; // 开启原图大小的图形上下文UIGraphicsBeginImageContextWithOptions(imageView.bounds.size, NO, 1.0); // 使用贝塞尔曲线画出一个带有圆角的路径path[[UIBezierPath bezierPathWithRoundedRect:imageView.bounds cornerRadius:imageView.frame.size.width] addClip];// 绘制图形[imageView drawRect:imageView.bounds];imageView.image = UIGraphicsGetImageFromCurrentImageContext(); //结束画图 UIGraphicsEndImageContext();[self.view addSubview:imageView]; 优化方案2：使用CAShapeLayer和UIBezierPath设置圆角 UIImageView *imageView = [[UIImageView alloc]initWithFrame:CGRectMake(100, 100, 100, 100)]; imageView.image = [UIImage imageNamed:@"myImg"]; // 贝塞尔绘制路径UIBezierPath *maskPath = [UIBezierPath bezierPathWithRoundedRect:imageView.bounds byRoundingCorners:UIRectCornerAllCorners cornerRadii:imageView.bounds.size];// 绘制蒙版图层CAShapeLayer *maskLayer = [[CAShapeLayer alloc]init]; //设置大小 maskLayer.frame = imageView.bounds; //设置图形样子 maskLayer.path = maskPath.CGPath;// 关键一步：在原矩形图层上，添加一个带圆角的蒙层，实现圆角效果imageView.layer.mask = maskLayer; [self.view addSubview:imageView]; 对于方案2需要解释的是： CAShapeLayer继承于CALayer,可以使用CALayer的所有属性值； CAShapeLayer需要贝塞尔曲线配合使用才有意义（也就是说才有效果） 使用CAShapeLayer(属于CoreAnimation)与贝塞尔曲线可以实现不在view的drawRect（继承于CoreGraphics走的是CPU,消耗的性能较大）方法中画出一些想要的图形 CAShapeLayer动画渲染直接提交到手机的GPU当中，相较于view的drawRect方法使用CPU渲染而言，其效率极高，能大大优化内存使用情况。 总的来说就是用CAShapeLayer的内存消耗少，渲染速度快，建议使用优化方案2。 2. Shadow的优化对于shadow，如果图层是个简单的几何图形或者圆角图形，我们可以通过设置shadowPath来优化性能，能大幅提高性能。示例如下： // 对imageView添加阴影效果imageView.layer.shadowColor = [UIColor grayColor].CGColor;imageView.layer.shadowOpacity = 1.0; // 阴影不透明度，1.0表示不透明imageView.layer.shadowRadius = 2.0; // 阴影的模糊半径// 画出阴影路径UIBezierPath *path = [UIBezierPath bezierPathWithRect:imageView.frame];imageView.layer.shadowPath = path.CGPath; 我们还可以通过设置shouldRasterize属性值为YES来强制开启离屏渲染。其实就是光栅化（Rasterization）。 既然离屏渲染这么不好，为什么我们还要强制开启呢？当一个图像混合了多个图层，每次移动时，每一帧都要重新合成这些图层，十分消耗性能。 当我们开启光栅化后，会在首次产生一个位图缓存，当再次使用时候就会复用这个缓存。但是如果图层发生改变的时候就会重新产生位图缓存。所以这个功能一般不能用于UITableViewCell中，cell的复用反而降低了性能。最好用于图层较多的静态内容的图形。而且产生的位图缓存的大小是有限制的，一般是2.5个屏幕尺寸。在100ms之内不使用这个缓存，缓存也会被删除。所以我们要根据使用场景而定。 3. 其他优化建议圆角（主要针对ScrollView、TableView这种滑动视图上添加的视图） 当我们需要圆角效果时，可以使用一张中间透明图片蒙上去 直接让美工把图片切成圆角进行显示，这是效率最高的一种方案 如果能够只用cornerRadius解决，那就不要设置masksToBounds为YES，或者圆角视图数量较少且是静态页面时，也可以不用优化。 阴影、透明度等 使用ShadowPath指定layer阴影效果路径 使用异步进行layer渲染（Facebook开源的异步绘制框架AsyncDisplayKit） 设置layer的opaque值为YES，减少复杂图层合成 尽量使用不包含透明（alpha）通道的图片资源 尽量设置layer的大小值为整形值 很多情况下用户上传图片进行显示，可以让服务端处理圆角 使用代码手动生成圆角Image设置到要显示的View上，利用UIBezierPath（CoreGraphics框架）画出来圆角图片 总结文章中首先介绍了GPU的两种渲染方式，分别是当前屏幕渲染和离屏渲染，解释了为什么离屏渲染会引起UI性能问题。并且结合了iOS日常开发中，会触发离屏渲染的几种情形。最后针对会触发离屏渲染的几个要点问题，讲解了优化方案及实践思路，希望能帮助读者解决类似问题。 参考资料 iOS的离屏渲染 离屏渲染-Alibaba]]></content>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS中各种“锁”的理解及应用]]></title>
    <url>%2F2018%2F06%2F07%2FiOS%E4%B8%AD%E5%90%84%E7%A7%8D%E2%80%9C%E9%94%81%E2%80%9D%E7%9A%84%E7%90%86%E8%A7%A3%E5%8F%8A%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[前言通常在一般的iOS应用开发中会很少碰到使用“锁”的业务逻辑，但是在需要使用多线程技术，解决大多数场景写的业务逻辑时，会使用到线程锁来保证临界数据的读写安全性。当然，“锁”的概念在计算机科学及应用中也是举足轻重的，对于要写出高质量、高性能、安全可靠的代码来说，也是非常重要的。 预备知识 线程调度 计算机通常只有一个CPU,在任意时刻只能执行一条机器指令,每个线程只有获得CPU的使用权才能执行指令.所谓多线程的并发运行,其实是指从宏观上看,各个线程轮流获得CPU的使用权,分别执行各自的任务.在运行池中,会有多个处于就绪状态的线程在等待CPU,JAVA虚拟机的一项任务就是负责线程的调度,线程调度是指按照特定机制为多个线程分配CPU的使用权.线程调度有两种调度模式： 分时调度模型，分时调度模型是指让所有的线程轮流获得 CPU 的使用权，并且平均分配每个线程占用的 CPU 的时间片。 抢占式调度模型，指优先让可运行池中优先级高的线程占用 CPU，如果可运行池中的线程优先级相同，那么就随机选择一个线程，使其占用 CPU。处于运行状态的线程会一直运行，直至它不得不放弃 CPU 时间片轮转算法 时间片：（timeslice）是分时操作系统分配给每个正在运行的进程微观上的一段CPU时间（在抢占内核中是：从进程开始运行直到被抢占的时间）。现代操作系统（如：Windows、Linux、Mac OS X等）允许同时运行多个进程 —— 例如，你可以在打开音乐播放器听音乐的同时用浏览器浏览网页并下载文件。事实上，由于一台计算机通常只有一个CPU，所以永远不可能真正地同时运行多个任务。这些进程“看起来像”同时运行的，实则是轮番穿插地运行，由于时间片通常很短（在Linux上为5ms－800ms），用户不会感觉到。– 维基百科 时间片由操作系统内核的调度程序分配给每个进程。首先，内核会给每个进程分配相等的初始时间片，然后每个进程轮番地执行相应的时间，当所有进程都处于时间片耗尽的状态时，内核会重新为每个进程计算并分配时间片，如此往复。 分配算法：现代操作系统再管理普通线程时，通常采用时间片轮转算法，每个线程会被分配一段时间片，通常在 10-100 毫秒左右，当线程使用完自己的时间片之后j就被会操作系统挂起，放入等待队列中，等待下一次被分配时间片。 原子操作 狭义上的原子操作表示一条不可打断的操作，也就是说线程在执行操作过程中，不会被操作系统挂起，而是一定会执行完。在单处理器环境下，一条汇编指令显然是原子操作，因为中断也要通过指令来实现。 然而在多处理器的情况下，能够被多个处理器同时执行的操作任然算不上原子操作。因此，真正的原子操作必须由硬件提供支持，比如 x86 平台上如果在指令前面加上 “LOCK” 前缀，对应的机器码在执行时会把总线锁住，使得其他 CPU不能再执行相同操作，从而从硬件层面确保了操作的原子性。 这些非常底层的概念无需完全掌握，我们只要知道上述申请锁的过程，可以用一个原子性操作 test_and_set 来完成，它用伪代码可以这样表示: bool test_and_set (bool *target) &#123; bool rv = *target; *target = TRUE; return rv;&#125; 这段代码的作用是把 target 的值设置为 1，并返回原来的值。当然，在具体实现时，它通过一个原子性的指令来完成。 —— 参考bestswifter博客《深入理解iOS开发中的锁》 自旋锁和互斥锁 都属于CPU时间分片算法下的实现保护共享资源的一种机制。都实现互斥操作，加锁后仅允许一个访问者。区别在于自旋锁不会使线程进入wait状态，而通过轮训不停查看是否该自旋锁的持有者已经释放的锁；对应的，互斥锁在出现锁已经被占用的情况会进入wait状态，CPU会当即切换时间片。 参考资料《自旋锁和互斥锁的区别》：https://blog.csdn.net/susidian/article/details/51068858 各种锁的应用及性能对比下面讨论iOS开发中常见的几种锁。包括锁的简单介绍及使用，锁的特性及加解锁性能对比。业界大神YYKit的作者ibireme 已经在其博客中讨论了各种锁的性能，且做出一个速度由快至慢的排名进行对比。图示如下： 需要说明的是，加解锁速度不表示锁的效率，只表示加解锁操作在执行时的复杂程度，下文会通过具体的例子来解释。 OSSpinLock（自旋锁）文中指出，其中性能最好的OSSpinLock(自旋锁)，已经不再安全了，主要原因发生在低优先级线程拿到锁时，高优先级线程进入忙等(busy-wait)状态，消耗大量 CPU 时间，从而导致低优先级线程拿不到 CPU 时间，也就无法完成任务并释放锁。这种问题被称为优先级反转。 为什么忙等会导致低优先级线程拿不到时间片？这还得从操作系统的线程调度说起。 现代操作系统在管理普通线程时，通常采用时间片轮转算法(Round Robin，简称 RR)。每个线程会被分配一段时间片(quantum)，通常在 10-100 毫秒左右。当线程用完属于自己的时间片以后，就会被操作系统挂起，放入等待队列中，直到下一次被分配时间片。 实现原理 自旋锁的目的是为了确保临界区只有一个线程可以访问，它的使用可以用下面这段伪代码来描述: do &#123; Acquire Lock // 获取锁 Critical section // 临界区 Release Lock // 释放锁 Reminder section // 不需要锁保护的代码&#125; 在 Acquire Lock 这一步，我们申请加锁，目的是为了保护临界区(Critical Section) 中的代码不会被多个线程执行。 自旋锁的实现思路很简单，理论上来说只要定义一个全局变量，用来表示锁的可用情况即可，伪代码如下: bool lock = false; // 一开始没有锁上，任何线程都可以申请锁 do &#123; while(lock); // 如果 lock 为 true 就一直死循环，相当于申请锁 lock = true; // 挂上锁，这样别的线程就无法获得锁 Critical section // 临界区 lock = false; // 相当于释放锁，这样别的线程可以进入临界区 Reminder section // 不需要锁保护的代码 &#125; 这段代码存在一个问题: 如果一开始有多个线程同时执行 while 循环，他们都不会在这里卡住，而是继续执行，这样就无法保证锁的可靠性了。解决思路也很简单，只要确保申请锁的过程是原子操作即可。 至此，自旋锁的实现原理就很清楚了，在申请锁的过程中确保原子操作，代码如下： bool lock = false; // 一开始没有锁上，任何线程都可以申请锁 do &#123; while(test_and_set(&amp;lock); // test_and_set 是一个原子操作 Critical section // 临界区 lock = false; // 相当于释放锁，这样别的线程可以进入临界区 Reminder section // 不需要锁保护的代码 &#125; 如果临界区的执行时间过长，使用自旋锁不是个好主意。之前我们介绍过时间片轮转算法，线程在多种情况下会退出自己的时间片。其中一种是用完了时间片的时间，被操作系统强制抢占。除此以外，当线程进行 I/O 操作，或进入睡眠状态时，都会主动让出时间片。显然在 while 循环中，线程处于忙等状态，白白浪费 CPU 时间，最终因为超时被操作系统抢占时间片。如果临界区执行时间较长，比如是文件读写，这种忙等是毫无必要的。 自旋锁使用范例 // 需要导入的头文件#import &lt;libkern/OSAtomic.h&gt;#import &lt;os/lock.h&gt;#import &lt;AddressBook/AddressBook.h&gt;// 自旋锁 实现- (void)OSSpinLock &#123; if (@available(iOS 10.0, *)) &#123; // iOS 10以后解决了优先级反转问题 os_unfair_lock_t unfairLock = &amp;(OS_UNFAIR_LOCK_INIT); NSLog(@"线程1 准备上锁"); os_unfair_lock_lock(unfairLock); sleep(4); NSLog(@"线程1执行"); os_unfair_lock_unlock(unfairLock); NSLog(@"线程1 解锁成功"); &#125; else &#123; // 会造成优先级反转，不建议使用 __block OSSpinLock oslock = OS_SPINLOCK_INIT; //线程2 dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_LOW, 0), ^&#123; NSLog(@"线程2 befor lock"); OSSpinLockLock(&amp;oslock); NSLog(@"线程2执行"); sleep(3); OSSpinLockUnlock(&amp;oslock); NSLog(@"线程2 unlock"); &#125;); //线程1 dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0), ^&#123; NSLog(@"线程1 befor lock"); OSSpinLockLock(&amp;oslock); NSLog(@"线程1 sleep"); sleep(3); NSLog(@"线程1执行"); OSSpinLockUnlock(&amp;oslock); NSLog(@"线程1 unlock"); &#125;); // 可以看出不同的队列优先级，执行的顺序不同，优先级越高，越早被执行 &#125;&#125; dispatch_semaphore_t（信号量）信号量在GCD多线程技术中是一个重要的角色，在保证性能的情况下，可实现多线程同步功能，也可以通过初始化value=1，来实现加锁。 在实现加锁的过程中，如果线程1已经获取了锁，并在执行任务过程中，其他线程会被阻塞，直到线程1任务完成释放锁。 YY大神推荐使用信号量dispatch_semaphore作为自旋锁的替代方案。 实现原理 信号量 dispatch_semaphore_t 的实现原理，它最终会调用到 sem_wait 方法，这个方法在 glibc 中被实现如下: int sem_wait (sem_t *sem) &#123; int *futex = (int *) sem; if (atomic_decrement_if_positive (futex) &gt; 0) return 0; int err = lll_futex_wait (futex, 0); return -1;) 首先会把信号量的值减一，并判断是否大于零。如果大于零，说明不用等待，所以立刻返回。具体的等待操作在 lll_futex_wait 函数中实现，lll 是 low level lock 的简称。这个函数通过汇编代码实现，调用到 SYS_futex 这个系统调用，使线程进入睡眠状态，主动让出时间片，这个函数在互斥锁的实现中，也有可能被用到。 主动让出时间片并不总是代表效率高。让出时间片会导致操作系统切换到另一个线程，这种上下文切换通常需要 10 微秒左右，而且至少需要两次切换。如果等待时间很短，比如只有几个微秒，忙等就比线程睡眠更高效。 可以看到，自旋锁和信号量的实现都非常简单，这也是两者的加解锁耗时分别排在第一和第二的原因。再次强调，加解锁耗时不能准确反应出锁的效率(比如时间片切换就无法发生)，它只能从一定程度上衡量锁的实现复杂程度。 应用示例 // 创建sem ,value 设置为1dispatch_semaphore_t signal = dispatch_semaphore_create(1);// 设置超时时间5s，当超过5s会自动释放锁dispatch_time_t timeout = dispatch_time(DISPATCH_TIME_NOW, 5.0f * NSEC_PER_SEC); //线程1dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; NSLog(@"线程1 holding"); dispatch_semaphore_wait(signal, timeout); //signal 值 -1 NSLog(@"线程1 sleep"); sleep(4); NSLog(@"线程1"); dispatch_semaphore_signal(signal); //signal 值 +1 NSLog(@"线程1 post singal");&#125;); //线程2dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; NSLog(@"线程2 holding"); dispatch_semaphore_wait(signal, timeout); NSLog(@"线程2 sleep"); sleep(4); NSLog(@"线程2"); dispatch_semaphore_signal(signal); NSLog(@"线程2 post signal");&#125;);// 代码执行结果：class:AppDelegate+AppService.m line:162 msg:线程2 holdingclass:AppDelegate+AppService.m line:151 msg:线程1 holdingclass:AppDelegate+AppService.m line:153 msg:线程1 sleepclass:AppDelegate+AppService.m line:155 msg:线程1class:AppDelegate+AppService.m line:164 msg:线程2 sleepclass:AppDelegate+AppService.m line:157 msg:线程1 post singal Pthread_mutex（互斥锁）pthread 表示 POSIX thread，定义了一组跨平台的线程相关的 API，pthread_mutex 表示互斥锁。互斥锁的实现原理与信号量非常相似，不是使用忙等，而是阻塞线程并睡眠，需要进行上下文切换，性能不及信号量。 实现原理 互斥锁在申请锁时，调用了 pthread_mutex_lock 方法，它在不同的系统上实现各有不同，有时候它的内部是使用信号量来实现，即使不用信号量，也会调用到 lll_futex_wait 函数，从而导致线程休眠。 上文说到如果临界区很短，忙等的效率也许更高，所以在有些版本的实现中，会首先尝试一定次数(比如 1000 次)的 testandtest，这样可以在错误使用互斥锁时提高性能。 另外，由于 pthread_mutex 有多种类型，可以支持递归锁等，因此在申请加锁时，需要对锁的类型加以判断，这也就是为什么它和信号量的实现类似，但效率略低的原因。 常见用法 互斥锁的常见用法如下: #import &lt;pthread.h&gt; // 需要导入头文件pthread_mutexattr_t attr; pthread_mutexattr_init(&amp;attr); pthread_mutexattr_settype(&amp;attr, PTHREAD_MUTEX_NORMAL); // 定义锁的属性pthread_mutex_t mutex; pthread_mutex_init(&amp;mutex, &amp;attr) // 创建锁pthread_mutex_lock(&amp;mutex); // 申请锁 // 临界区pthread_mutex_unlock(&amp;mutex); // 释放锁 对于 pthread_mutex 来说，它的用法和之前没有太大的改变，比较重要的是锁的类型，可以有 PTHREAD_MUTEX_NORMAL、PTHREAD_MUTEX_ERRORCHECK、PTHREAD_MUTEX_RECURSIVE 等等，具体的特性就不做解释了，网上有很多相关资料。 一般情况下，一个线程只能申请一次锁，也只能在获得锁的情况下才能释放锁，多次申请锁或释放未获得的锁都会导致崩溃。假设在已经获得锁的情况下再次申请锁，线程会因为等待锁的释放而进入睡眠状态，因此就不可能再释放锁，从而导致死锁。 然而这种情况经常会发生，比如某个函数申请了锁，在临界区内又递归调用了自己。辛运的是 pthread_mutex 支持递归锁，也就是允许一个线程递归的申请锁，只要把 attr 的类型改成 PTHREAD_MUTEX_RECURSIVE 即可。 YTKNetworking 中就有使用这种锁方式： pthread_mutex_t lock; // 创建 lock// 宏定义，加解锁方法#define Lock() pthread_mutex_lock(&amp;_lock) #define Unlock() pthread_mutex_unlock(&amp;_lock)/* 使用范例 *///添加 request 到字典- (void)addRequestToRecord:(YTKBaseRequest *)request &#123; Lock(); _requestsRecord[@(request.requestTask.taskIdentifier)] = request; Unlock();&#125;//从字典中移除指定的 request- (void)removeRequestFromRecord:(YTKBaseRequest *)request &#123; Lock(); [_requestsRecord removeObjectForKey:@(request.requestTask.taskIdentifier)]; YTKLog(@"Request queue size = %zd", [_requestsRecord count]); Unlock();&#125; NSLockNSLock 是 Objective-C 以对象的形式暴露给开发者的一种锁，它的实现非常简单，通过宏，定义了 lock 方法: #define MLOCK \- (void) lock\&#123;\ int err = pthread_mutex_lock(&amp;_mutex);\ // 错误处理 ……&#125; NSLock 只是在内部封装了一个 pthread_mutex，属性为 PTHREAD_MUTEX_ERRORCHECK，它会损失一定性能换来错误提示。 这里使用宏定义的原因是，OC 内部还有其他几种锁，他们的 lock 方法都是一模一样，仅仅是内部 pthread_mutex 互斥锁的类型不同。通过宏定义，可以简化方法的定义。 NSLock 比 pthread_mutex 略慢的原因在于它需要经过方法调用，同时由于缓存的存在，多次方法调用不会对性能产生太大的影响。 应用范例 AFNetworking 中就是用的NSLock方式: @property (readwrite, nonatomic, strong) NSLock *lock; // 声明锁// 初始化锁self.lock = [[NSLock alloc] init];self.lock.name = AFURLSessionManagerLockName;// 应用- (void)removeDelegateForTask:(NSURLSessionTask *)task &#123; NSParameterAssert(task); AFURLSessionManagerTaskDelegate *delegate = [self delegateForTask:task]; [self.lock lock]; [delegate cleanUpProgressForTask:task]; [self removeNotificationObserverForTask:task]; [self.mutableTaskDelegatesKeyedByTaskIdentifier removeObjectForKey:@(task.taskIdentifier)]; [self.lock unlock];&#125; NSConditionNSCondition 的底层是通过条件变量(condition variable) pthread_cond_t 来实现的。条件变量有点像信号量，提供了线程阻塞与信号机制，因此可以用来阻塞某个线程，并等待某个数据就绪，随后唤醒线程，比如常见的生产者-消费者模式。 实现原理 NSCondition 其实是封装了一个互斥锁和条件变量， 它把前者的 lock 方法和后者的 wait/signal 统一在 NSCondition 对象中，暴露给使用者: - (void) signal &#123; pthread_cond_signal(&amp;_condition);&#125;// 其实这个函数是通过宏来定义的，展开后就是这样- (void) lock &#123; int err = pthread_mutex_lock(&amp;_mutex);&#125; 它的加解锁过程与 NSLock 几乎一致，理论上来说耗时也应该一样(实际测试也是如此)。在图中显示它耗时略长，我猜测有可能是测试者在每次加解锁的前后还附带了变量的初始化和销毁操作。 条件锁使用 很多介绍 pthread_cond_t 的文章都会提到，它需要与互斥锁配合使用: void consumer () &#123; // 消费者 pthread_mutex_lock(&amp;mutex); while (data == NULL) &#123; pthread_cond_wait(&amp;condition_variable_signal, &amp;mutex); // 等待数据 &#125; // --- 有新的数据，以下代码负责处理 ↓↓↓↓↓↓ // temp = data; // --- 有新的数据，以上代码负责处理 ↑↑↑↑↑↑ pthread_mutex_unlock(&amp;mutex);&#125;void producer () &#123; pthread_mutex_lock(&amp;mutex); // 生产数据 pthread_cond_signal(&amp;condition_variable_signal); // 发出信号给消费者，告诉他们有了新的数据 pthread_mutex_unlock(&amp;mutex);&#125; 自然我们会有疑问:“如果不用互斥锁，只用条件变量会有什么问题呢？”。问题在于，temp = data; 这段代码不是线程安全的，也许在你把 data 读出来以前，已经有别的线程修改了数据。因此我们需要保证消费者拿到的数据是线程安全的。 wait 方法除了会被 signal 方法唤醒，有时还会被虚假唤醒，所以需要这里 while 循环中的判断来做二次确认。 NSConditionLock（条件锁）NSConditionLock 借助 NSCondition 来实现，它的本质就是一个生产者-消费者模型。“条件被满足”可以理解为生产者提供了新的内容。NSConditionLock 的内部持有一个 NSCondition 对象，以及 _condition_value 属性，在初始化时就会对这个属性进行赋值: // 简化版代码- (id) initWithCondition: (NSInteger)value &#123; if (nil != (self = [super init])) &#123; _condition = [NSCondition new] _condition_value = value; &#125; return self;&#125; 它的 lockWhenCondition 方法其实就是消费者方法: - (void) lockWhenCondition: (NSInteger)value &#123; [_condition lock]; while (value != _condition_value) &#123; [_condition wait]; &#125;&#125; 对应的 unlockWhenCondition 方法则是生产者，使用了 broadcast 方法通知了所有的消费者: - (void) unlockWithCondition: (NSInteger)value &#123; _condition_value = value; [_condition broadcast]; [_condition unlock];&#125; NSRecursiveLock（递归锁）上文已经说过，递归锁也是通过 pthread_mutex_lock 函数来实现，在函数内部会判断锁的类型，如果显示是递归锁，就允许递归调用，仅仅将一个计数器加一，锁的释放过程也是同理。 NSRecursiveLock 与 NSLock 的区别在于内部封装的 pthread_mutex_t 对象的类型不同，前者的类型为 PTHREAD_MUTEX_RECURSIVE。 @synchronized（同步锁）这其实是一个 OC 层面的锁， 主要是通过牺牲性能换来语法上的简洁与可读。 我们知道 @synchronized 后面需要紧跟一个 OC 对象，它实际上是把这个对象当做锁来使用。这是通过一个哈希表来实现的，OC 在底层使用了一个互斥锁的数组(你可以理解为锁池)，通过对对象去哈希值来得到对应的互斥锁。 在 SDWebImage 中用的就是这种方式： - (void)cancel &#123; @synchronized (self) &#123; [self cancelInternal]; &#125;&#125; 总结文章梳理了在iOS开发中用到的各种锁，简单介绍了其实现原理、不同锁的应用场景和注意事项。希望对看到这篇文章的小伙伴有所帮助。 参考资料 https://blog.ibireme.com/2016/01/16/spinlock_is_unsafe_in_ios/ https://blog.csdn.net/susidian/article/details/51068858]]></content>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[对象、类、元类、isa指针之间的爱恨情仇]]></title>
    <url>%2F2018%2F05%2F28%2F%E5%AF%B9%E8%B1%A1%E3%80%81%E7%B1%BB%E3%80%81%E5%85%83%E7%B1%BB%E3%80%81isa%E6%8C%87%E9%92%88%E4%B9%8B%E9%97%B4%E7%9A%84%E7%88%B1%E6%81%A8%E6%83%85%E4%BB%87%2F</url>
    <content type="text"><![CDATA[前言在iOS开发中，对象、类的使用可以说是无处不在，伴随着整个项目的开发周期，也是程序的重要组成部分。但是在日常开发中，很难直观的见到元类、isa指针，那么它们究竟是谁，在开发中起着什么作用呢？下面我们就分别介绍下这几位亲兄弟的结构体定义，以及之间的关联关系。 类(class)的结构体定义类对象(Class)是由程序员定义并在运行时有编译器创建的，他没有自己的实例变量，这里需要注意的是类的成员变量和实例方法列表是属于实例对象的，但其存储于类对象当中。下图指出类的结构体定义： // An opaque type that represents an Objective-C class.typedef struct objc_class *Class;// OC1.0 class 结构体定义struct objc_class &#123; Class _Nonnull isa OBJC_ISA_AVAILABILITY;#if !__OBJC2__ Class _Nullable super_class OBJC2_UNAVAILABLE; const char * _Nonnull name OBJC2_UNAVAILABLE; long version OBJC2_UNAVAILABLE; long info OBJC2_UNAVAILABLE; long instance_size OBJC2_UNAVAILABLE; struct objc_ivar_list * _Nullable ivars OBJC2_UNAVAILABLE; struct objc_method_list * _Nullable * _Nullable methodLists OBJC2_UNAVAILABLE; struct objc_cache * _Nonnull cache OBJC2_UNAVAILABLE; struct objc_protocol_list * _Nullable protocols OBJC2_UNAVAILABLE;#endif&#125; OBJC2_UNAVAILABLE;/* Use `Class` instead of `struct objc_class *` */// OC2.0 class 结构体定义，我们注意到上面的定义后面的标识符OBJC2_UNAVAILABLE，意思是已经不适用ObjC2.0了，现在ObjC2.0 对objc_class的定义如下：struct objc_class : objc_object &#123; isa_t isa; Class superclass; cache_t cache; class_data_bits_t bits;&#125;; 我们在objc/objc.h 源码文件中找到了Class 类结构体的定义，下面我们分析并说明一下几个关键的结构体成员： isa： 是一个不能为空(null)的Class对象，它指向该类的元类(meta class)。 super_class：是一个可以为空的Class对象，它指向当前类的父类。会一直追溯到根类(NSObject)，那么根类(NSObject)的父类是指向谁的呢？通过分析根类的父类是指向空(nil)的，这样也就可以解释为什么super_class 是可以为空的。 ivars：是实例变量列表，保存着该类的所有实例变量 methodLists：是方法列表，保存着实例方法和类方法 protocols：是协议列表，保存该类的协议方法 cache：是一个缓存，用于缓存最近使用过的方法。 … 上面我们根据Class 类的结构体，分析内部成员的作用及含义。想必大家已经对Class类的内部结构有了一个初步的认识。如果想再深入理解isa和super_class在不同情况下都是如何进行指向的，我们再看下面的一个图示来逐步分析： 首先，注意图中的注释，实线的箭头(→ superclass)代表父类指针，虚线的箭头(→isa)代表isa指针，从上至下的深色方框依次代表：根类-&gt; 父类-&gt; 子类，下面咱们从上至下层层分析上图的含义： 第一层： isa指针： 根类的实例对象(instance Of Root class)的isa指向根类(Root class)，根类的isa指针指向根元类(Root meta class)，根元类的isa指向它本身。 superclass指针：根类(Root class)的superclass指向nil，根元类的父类指向根类。 第二层： isa指针：父类的实例对象(instance of superclass)的isa指向父类（superclass），父类的isa指向父元类，父元类的isa指向根元类。 superclass指针：父类的superclass指向根类，父元类的superclass指向根元类。 第三层： isa指针：子类实例对象（instance of subclass）的isa指向子类，子类的isa指向子元类，子元类的isa指向根元类。 superclass指针：子类的superclass指向父类，子元类的superclass指向父元类。 动态创建一个类 // 创建一个新类和元类Class objc_allocateClassPair ( Class superclass, const char *name, size_t extraBytes ); //如果创建的是root class，则superclass为Nil。extraBytes通常为0// 销毁一个类及其相关联的类void objc_disposeClassPair ( Class cls ); //在运行中还存在或存在子类实例，就不能够调用这个。// 在应用中注册由objc_allocateClassPair创建的类void objc_registerClassPair ( Class cls ); //创建了新类后，然后使用class_addMethod，class_addIvar函数为新类添加方法，实例变量和属性后再调用这个来注册类，再之后就能够用了。 对象(object)的结构体定义// Represents an instance of a class.struct objc_object &#123; Class _Nonnull isa OBJC_ISA_AVAILABILITY;&#125;; 我们可以看到，objc_object代表一个实例对象，它的结构体内部有一个不为空的isa指针，isa是指向对象所属类的指针。另外，我们常用的id类型是一个指向objc_object结构体的指针，它可以指向任意一个oc对象。 // A pointer to an instance of a class.typedef struct objc_object &#123; Class isa;&#125; *id; 元类(Meta class)的结构体定义元类(Meta class) 就是类对象的类，每个类都有自己的元类，也就是objc_class结构体里面的isa指针所指向的类。元类用来表述类对象本身所具备的元数据， 因为元类中存储着类对象的方法列表，即类方法。 下面将介绍实例对象、类、元类之间的关系，如下图所示： 当向对象发消息时，runtime会在这个对象所属类的实例方法列表中查找消息对应的方法实现(IMP)。但当向类发送消息时，runtime就会在这个类的元类(meta class)方法列表里查找。所有的元类(meta class)，包括根类(Root class)，父类(Superclass)，子类(Subclass)的isa最终都指向根类(Root class)的元类(meta class)，这样能够形成一个闭环。可以总结为： 当发送消息给实例对象时，runtime函数会在此实例对象所属类的实例方法列表中查找方法实现(IMP)并调用，此为实例方法调用。 当发送消息给类对象时，runtime函数会在此实例对象所属类的元类的方法列表中查找方法实例(IMP)并调用，此为类方法调用。 延伸扩展方法的调用流程 OC的方法调用本质上是给对象发送消息，即调用runtime的消息发送函数，如下所示： /* param: self(id) 接收消息的对象， param: op(SEL) 发送的消息，即方法签名(@selector(method_name))*/id _Nullable objc_msgSend(id _Nullable self, SEL _Nonnull op, ...) 通过对objc_msgSend()函数的源码分析，总结以下调用流程： 检查 selector 是否需要忽略 检查 target 是否为 nil，如果是 nil 就直接 cleanup，然后 return 在 target 的 Class 中根据 selector 去找 IMP 寻找IMP的流程 在当前 class 的方法缓存里寻找（cache methodLists） 找到了跳到对应的方法实现，没找到继续往下执行 从当前 class 的 方法列表里查找（methodLists），找到了添加到缓存列表里，然后跳转到对应的方法实现；没找到继续往下执行 从 superClass 的缓存列表和方法列表里查找，直到找到基类为止 以上步骤还找不到 IMP，则进入消息动态处理和消息转发(objc_msgForward)流程，详见这篇文章 我们从objc-class.mm 官方源码中找到了寻找IMP的实现过程，如下： IMP class_getMethodImplementation(Class cls, SEL sel)&#123;IMP imp;if (!cls || !sel) return nil;imp = lookUpImpOrNil(cls, sel, nil,YES/*initialize*/, YES/*cache*/, YES/*resolver*/);// Translate forwarding function to C-callable external versionif (!imp) &#123;return _objc_msgForward;&#125;return imp;&#125; 参考资料 http://limbank.com/2018/03/09/post18/ https://tingxins.com/2017/05/metaclass-class-relationship/]]></content>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
</search>